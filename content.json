[{"title":"Windows下安装Hadoop、Spark和HBase","date":"2018-03-26T15:45:18.000Z","path":"2018/windows-hadoop-spark-hbase.html","text":"1、Hadoop安装Hadoop：下载hadoop-2.7.1.tar.gz，并解压到你想要的目录下，我放在D:\\Library\\hadoop-2.7.1。 配置Hadoop环境变量：HADOOP_HOME为%HADOOP_HOME%\\bin;还有path加入%HADOOP_HOME%\\bin; 将hadoop.dll复制到C:\\Window\\System32下。 Hadoop配置文件写法：","tags":[]},{"title":"Kafka安装教程","date":"2018-03-26T15:13:21.000Z","path":"2018/kafka-install.html","text":"1、CentOS上的配置——关防火墙查看firewall的状态：firewall-cmd –state 停止firewall：systemctl stop firewalld.service 禁止firewall开机启动：systemctl disable firewalld.service 查看默认防火墙状态（关闭后显示not running，开启后显示running）：firewall-cmd –state 2、安装kafka下载地址：https://kafka.apache.org/downloads wget http://mirrors.shuosc.org/apache/kafka/1.0.0/kafka_2.11-1.0.0.tgz tar -zxvf kafka_2.11-1.0.0.gz mv kafka_2.11-1.0.0 /usr/local/kafka/ cd /usr/local/kafka/ nano /usr/local/kafka/config/server.properties broker.id=1 log.dir=/data/kafka/logs-1 3、启动ZKcd /usr/local/kafka/ bin/zookeeper-server-start.sh -daemon config/zookeeper.properties 启动KAFKA服务 bin/kafka-server-start.sh config/server.properties 4、话题TOPIC创建TOPIC： bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic jfzpoi bin/kafka-topics.sh –list –zookeeper localhost:2181 如果报错网络不通，改ipv6的设置 nano /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 vmcentos ::1 ip6-localhost ip6-localhost.localdomain localhost6 localhost6.localdomain6 查看TOPIC列表： cd /usr/local/kafka/ bin/kafka-topics.sh –list –zookeeper localhost:2181 产生消息： cd /usr/local/kafka/ bin/kafka-console-producer.sh –broker-list localhost:9092 –topic jfzpoi 消费消息： cd /usr/local/kafka/ bin/kafka-console-consumer.sh –zookeeper localhost:2181 –topic jfzpoi –from-beginning bin/kafka-console-consumer.sh –zookeeper localhost:2181 –topic dataPackage –from-beginning 查看描述TOPICS信息： cd /usr/local/kafka/ bin/kafka-topics.sh –describe –zookeeper localhost:2181 –topic jfzpoi 第一行给出了所有分区的摘要，每个附加行给出了关于一个分区的信息。 由于我们只有一个分区，所以只有一行。 “Leader”: 是负责给定分区的所有读取和写入的节点。 每个节点将成为分区随机选择部分的领导者。 “Replicas”: 是复制此分区日志的节点列表，无论它们是否是领导者，或者即使他们当前处于活动状态。 “Isr”: 是一组“同步”副本。这是复制品列表的子集，当前活着并被引导到领导者。 集群配置：http://www.54tianzhisheng.cn/2018/01/04/Kafka/","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"西泽保彦《谜亭论处》","date":"2018-02-20T15:40:14.000Z","path":"2018/mitinglunchu.html","text":"来自百度西泽保彦贴吧zmtrb翻译的作品。匠千晓系列不用多说，zmtrb的文章被删，不愧为垃圾百度干的好事，总是埋没精品推崇垃圾，现贴出我收集的部分翻译作品，希望zmtrb能坚持填完坑，找到更自由的分享平台。收集资料如下： 《谜亭论处》第一章 被偷走答卷的问题 1. 注意到东西没拿落在职员室的时候，边见祐辅已经开车离开了学校停车场，奔行在夜晚的大街上了。路边的灯彩宛如能激起人思恋之情的女性的艳丽微笑，在他的视野中留下残像一掠而过。 现在要不要回学校呢，祐辅有点犹豫。看了下驾驶席的数字时钟，还有几分钟就是八点了。放学后，他留在职员室给昨天刚进行的周测验的试卷打分。以前总是拖很久才把试卷发回给学生而被他们抱怨，这次奋发了一把一口气阅完卷，所以才留到这么晚。 稍微犹豫了下，结果祐辅还是开车返回了学校。“啊呀”，他不由得对自己的好色之心而咋舌，虽然没有任何人看见，还是挠着头发露出想要蒙混过关的笑容。实际上落在职员室的东西也不是什么贵重品，而是在职员室里坐在自己旁边的同事今天借给他的AV。 “这个很棒哦”，英语教师稻叶嘉彦一边把录像带交给祐辅，一边从嘴里漏出“呵呵呵”的奇妙笑声。因为用手捂着嘴的关系，原本就如同鱼板的断面图般的眼睛在金属框架的眼镜后面显得更突出了。“肯定会让你喷鼻血喷到贫血的哦，还有，这个伪装很赞吧，对吧，对吧” 录像带的标签上用文字处理机打印着“大怪兽哥斯拉”、“哥斯拉的逆袭”之类过去的特摄电影的标题。看来比起录像带的内容，稻叶更想用伪装的标签来挑起祐辅的兴趣。 不管怎么说，过去多次观赏了稻叶的“收藏品”的祐辅这次也颇为期待。没有这卷带子今晚就不知如何度过了。 说起来这个带子今天不看明天看不是也行吗，但是祐辅无论如何也想在今天看完。也不是等不及到明天了，只是明晚和好久不见的大学时代的学弟约好了一起喝酒。要问为什么不干脆和学弟一起看呢，那是因为两个寂寞的大老爷们聚在一起喝酒看AV，实在有违祐辅的“美学”，这种东西就该一个人在密室里偷偷欣赏才是。总而言之，明晚不行的话那就只有今天或后天了。对于性急的祐辅而言只能不厌其烦地返回学校了。 从大街通向住宅密集区的岔道中间一带就是就是祐辅工作的丘阳女子学园了。这是一所初中高中一贯制教育的私立学校。把车停在稍微开着的校门前，祐辅抬头看向被黑夜完全笼罩的白色校舍。好像还有谁在的样子，二楼的职员室的灯还亮着。 刚刚进入十月，白天的时候还执拗地缠绕在身上的夏日余温，到了晚上就完全地雾散而寒意袭人了。在一不当心就可能会感冒的夜风中，祐辅没关引擎就下了车赶往校舍。 穿过中庭时，突然眼前出现了数个异样的高大人影般的东西，身体不由得一缩。 仔细一看原来是美术部学生制作的立体作品群。文化祭将近，以事前展示的形式装饰在这里。不仅是文化祭，运动会也临近了。对祐辅这些男性教师是令人头痛的季节。两个活动重叠的话，平时对外隔绝的禁断的女学园向一般大众开放的机会也就大大增加了。 丘阳女子学园创立近百年，是一所规格与传统兼备的学校。从祐辅的祖父时代，不，是更以前起就是名门闺秀入学的“温室”，这样的印象在当地根深蒂固。只要穿着丘阳的制服，就算是丑女也会受到男生们的追捧——这是来自公立学校的女学生们的坏话。总之男人们对于丘阳这个名头抱着过剩的幻想（实际上在此任职目睹了实态之前的祐辅也是其中一员），闭锁保守的校风更是加剧了这一理想化。 因此，趁着运动会与文化祭之类外部人员能够光明正大地进入学园内部的稀有机会，不知从哪儿冒出来的年轻男性们蜂拥而至。理所当然的，其中也会混着些不正经的男人，必须将这种变态预备军从学园里轰出去的事态绝不少见。为此，担任监视者的男性教师们即将迎来一年之中最为伤神的季节。 祐辅进入校舍，爬上昏暗的楼梯。职员室的门打开着，灯光照到了走廊上。在这个时候还没有任何可疑之处，但是为什么会想要在进入职员室之前偷窥一下里面的情况呢，是感到什么“气息”了吗。事后回想起来，自己也不明白，也许是出于一种内疚心理吧——身为女子学校教师这一圣职中的圣职，却为了取AV这种淫秽物品而特意返回学校，万一被学生们知道了可真是要羞愧而死了。 突然祐辅吃惊地停下了脚步，因为有人正站在他的桌子旁边。不，准确地说是他隔壁桌子的旁边。祐辅右边相邻的桌子是稻叶嘉彦，左边则是名叫我孙子铃江的中年国语教师。她就是伫立在我孙子铃江的桌子前。 她名叫尼岸须美子，与祐辅一样担任国语教师。今年三月在东京有名的私立大学毕业后来此赴任，而且听说是毕业于这所丘阳学园。简直像是经过测量般的八头身，加上闪耀着绿色光泽的长长的黑发，平时一直维持着生气似的表情，大概是在担心发笑时会露出皱纹吧，总之是个异样的惊人的美女，其面无表情似乎是在瞪视着这个世界，不让任何人对她的美抱有异议。 职员室里只有须美子一人。她的侧脸看起来比平时还要僵硬。但比起这个来，祐辅更在意的是她手里拿着的东西。须美子露出奇妙的像是钻牛角尖似的表情，正要把鼓起的信封放到我孙子铃江的桌子上。正好和放入测验答题纸的信封是同样的尺寸。角度的关系看得不是很清楚，大概是抱着二、三袋的样子。 “啊。。。你好”虽然完全不明白其中的意义，但祐辅模糊地感觉到自己看见了不该看的事情。糟糕。原本就是难以应对的对象。明明都是国文教师，但因为觉得难以接近的关系，祐辅和尼岸须美子至今为止一次都没有交谈过。话虽如此，也不能一句话不说就转身离开吧：”老师你工作到这么晚啊，真、真是辛苦了，啊哈哈“ 用笑容表示自己没有恶意，总之蒙混过去就好了——祐辅的这种期待完全落空了。像是冻结般的眼眸仍旧一眨不眨地注视着祐辅的脸。 “那、那个”，不仅仅是她的面无表情，还有她身着的高价套装也对祐辅起到了压迫的作用。当然祐辅无法区分其品牌是INGEBORG还是香奈儿什么的，他只是觉得这绝对不是会出现在大甩卖中的廉价商品。“那个，老师已经完成了吧，这次周测验的打分” “是的”须美子缓缓地点了点头。这是她头一次对祐辅说的话语。宛如歌剧演员般凛然而响亮的声音。又或者是安静的职员室更加深了这种感觉，“今天早上已经发回给学生了，拜托班主任在早上的班级活动时间里发的。“ 正要把信封放到我孙子铃江的桌子上时，须美子像是想起什么似的环视周围。可能是感觉到了什么气息吧。扭头看向职员室入口的须美子突然和祐辅对上了眼。她畏缩地把本想放到桌上的信封抱回了胸前。因为面无表情的关系，她的动作像是上了发条的机械般不自然。 ”哦哦，你动作真快啊，我也得向你学习才行啊。哎呀哎呀，那个，所以说，那个，对了，平均分是多少？“ ”不到六十分“ ”咦，这可不行啊，太松懈了，真是太松懈了啊。哎呀哎呀，老实说我的学生也是差不多的分数。不过也没有办法吧，毕竟到了这个季节了啊。学生们脑子里都是即将到来的活动了。啊哈，啊哈，啊哈哈哈“ ”不好意思，已经很晚了。我告辞了“ 须美子耸着肩从一边挠头发一边高声笑着的祐辅身边穿过，离开了职员室。那几个信封也还是抱在胸前带走了。高跟鞋的声音在昏暗的廊下渐渐远去。她走过的时候，一股无法形容的甜腻香气从祐辅的鼻孔里直冲脑髓，视野中一瞬间染上了粉红色的烟霭。 回想起已经在回家路上的自己特意返回学校的理由，祐辅像是从梦中醒来一般。尼岸须美子那强烈到与毒气只有一线之隔的美貌，刺激到了祐辅微妙的男性心理，感觉有点难以下手去取那卷AV啊，祐辅叹着气走近自己的桌子。咦，放到哪里去了，对了，虽然贴了伪装的标签但也不敢放在外面，所以收进上锁的抽屉里去了。 想要取出钥匙的祐辅的动作突然停止了。（这是。。。），强烈的违和感缠上了他全身。但这究竟是什么原因，他一下子还没想明白，（这是。。。我的桌子。。。确实。。。没错。。。但是。。。有哪里不对） “噗”的一声，像是从轮胎里突然抽出空气般的声音从嘴里漏了出来，但他甚至没有余裕去察觉这是从自己嘴里发出的呻吟声。“嘎巴”一下压在自己桌上的祐辅像是在黑暗中摸索般在桌面上来回抚摸。 （没有。。。）像是感光的照片般全白的大脑中，只有这个单词空虚地回响。（没有。。。没有。。。没有。。。） 消失了，才批改完的周测验的答卷，三个班级的，全部都消失了。回去的时候确实把答卷都装入信封内，放在自己的桌上的，现在却无影无踪了。 （到。。。到哪去了），“丑闻”这两个大大的汉字在祐辅脑内的空洞里，像是除夕的钟声般“咣咣”地鸣响。（到哪里去了啊，喂喂喂喂，骗人的吧？是骗人的吧？拜托了说是骗人的啊！） 但不管再怎么找，三个班级的信封都不见踪影。祐辅语不成声地发出悲鸣，摇摇晃晃地跌落在椅子上。 “冷、冷静。。。”祐辅用手指揉着额头对自己说。“冷静、要冷静下来”。事态是一目了然的。有人偷走了周测验的答卷。这就好，不，一点也不好，总之从状况来看只能认为是被偷走了。不能从这个事实上移开眼睛，必须在此基础上考虑对策，对，没错。 问题是自己应该怎么做。嗯，究竟应该怎么处理这个事态。在考虑这个之前首先要搞清楚这算是什么程度的丑闻。祐辅拼命从混乱和恐慌中维持住自我。首先—— 首先是第一点。这是周测验，英语、国文、数学三个主要教科每周依次进行。这不仅仅是因为丘阳学园进行保守的大和抚子式的教育，也确保了它在县内名列前茅的高升学率。这周正好轮到国文。当然周测验的结果全部都会计入期末评价，但相比期中测验和期末测验等定期考察来说占的比重就小了。因此可以说比起定期考察的答卷被偷，这次的事态造成的伤害较小。 第二点——考虑到这，多少有点恢复冷静的祐辅再次脸色发青了。这就是问题了。祐辅确实批完了三个班级全体学生的试卷，但是还没有把分数记录下来，一个人都没有，平均分也还没有算，记分册完全空着，为了期末评价配点比率计算而输入电脑的工作也没有完成。本打算明天早上做的，因为祐辅明天早上第一节没有课，所以在发卷给学生前还有充分的时间一点一点地完成。 祐辅像被马踩扁的青蛙般无力地伏在桌上。“笨蛋，我真笨蛋”，祐辅一边摩擦着太阳穴一边挠着头发。为什么今晚不把分数记录下来啊，而且啊，就算是在职员室里，把答卷放在桌上不收起来也太大意了。现在再说这个也迟了。啊啊，怎么办。 就算占的比重比定期考察来的小，三个班级全体学生的分数就这么消失仍然是难以原谅的事态。这样一来学校大概就只有两种选择了：一。这次的国文周测验无效。二。重出一份试卷再测一次。不管选哪个，祐辅都是责任重大。不，责任重大是可以想象的，问题是重大到什么程度，祐辅因为缺乏经验而无法有更具体的想象。应该不会被立刻免职吧，但至少要做好惩戒处分的觉悟，是不是要递交请示去留的辞呈较好呢? 烦闷了一会儿，祐辅突然站了起来，终于有余裕去想是谁偷了答卷这个问题了。首先要怀疑的是学生。为了成绩而烦恼的学生想要修改答卷上的解答和分数也不是什么不可思议的事。不过，就算夜晚的职员室人少容易侵入，但对学生而言还是不愿靠近的“圣域”。随随便便地进入，将答卷偷走，还要装出毫不知情的样子，这需要相当的傻大胆。虽然无法断言学校中没有这样大胆的学生，但是这样的“豪杰”会在意区区测验的结果吗？祐辅这样想着。 犯人会不会是教师呢。。。还不能完全排除学生作案的可能性，但这样怀疑的祐辅开始在职员室里到处走动。不知不觉就变得蹑手蹑脚的祐辅一个个地观察教师们的桌子。没有什么目标，但也没法不这么做。每当在桌子和书架上发现相似的信封，就想说不定会是失窃的答卷，于是忍不住拿起来检查，但结果并没有这么幸运的事。就算真是同事偷了试卷，也不会蠢到放在自己桌上吧。 在宽敞的职员室里巡视了一圈后，祐辅再次束手无策了。那么，之后该怎么办呢，这样叹着气的时候，突然听见了像是微弱的哼哼声一样的声音，一看之下，发现通往复印室的门稍微开着一点，哼哼声好像是复印机工作时的声音。 2. 有人在吗。。。？祐辅从门缝间往里面窥看了一下，看见了一个男人的背影，耳朵上戴着立体声耳机，一边悠然自得地哼着歌一边一张张地大量复印着。是在制作上课用的练习试卷吗？看来他完全没有注意到祐辅在职员室里。 虽然没有看见脸，但从立体声耳机就能知道是谁了，是英语教师野岛淳，和之前的尼岸须美子一样是今年四月刚上任的新人教师。 对于这个野岛，祐辅也是难以应对，不过和尼岸须美子是完全不同意义上的。他毕业于著名大学，是位于日本首都的偏差值日本第一的某国立大学的文学部出身，父亲是县内最大的建筑企业野岛组的社长，家境非常富裕。他就是在这种无菌培养环境下长大的精英，也不知道是不是这个缘故，野岛这个男人，性格上有问题。 最大的证据就是他在学生中完全没有人气。一开始祐辅觉得很不可思议，野岛个子高，又拥有歌舞伎演员般的高鼻梁的容貌，再加上高学历和富裕的家境，肯定会吸引学生们的吧，这样想着的祐辅还有点嫉妒呢。但实际上学生们把他视如蛇蝎般地讨厌着，这真是难以理解啊。 在第一学期结束的时候，祐辅对此感到可以理解了。结业式那一天，青年教师和事务员们聚在一起召开酒会，年龄已经接近青年上限的祐辅也参与了，野岛和尼岸须美子也都出席。 在这次酒会里，野岛令人吃惊地自始至终戴着立体声耳机，完全没想要参与会话。同事要给他倒酒，他也无动于衷佯装不知，有时甚至显出露骨的不快表情。看到之后祐辅明白了，这个男人是缺乏协调性的幼儿一般的性格。 不仅如此，二次会（译者注：酒会结束后换个地方再开第二场）的时候，座位自由决定，野岛毫不犹豫地凑到尼岸须美子的身边。店里的音乐太吵，祐辅听不见他对须美子说了些什么，但他的表情变得和之前截然不同的和蔼可亲。不过，对同性冷淡，对女性亲切这一点上祐辅也有同样的倾向。从这个意义上来说，作为一个男性他也有正常的一面，祐辅安心了。 然而下一瞬间，他惊呆了——野岛就算是凑在须美子身边的时候，也没有把立体声耳机拿下来过。而且仔细观察后发现，他会主动去搭话的对象只有包括须美子和其它几人在内的美女组。除此以外的其它女性向他说话，就会受到露骨的无视，连旁观的祐辅都觉得扫兴的程度。觉得这家伙很奇怪的，当然不仅仅是祐辅一个人。如果他在和学生交流的时候也表现出这样明显的幼儿性格的话，就已经不是受人喜欢或讨厌程度的问题了吧。 数日前，从隔壁座位的我孙子铃江那里听说，学生间流行起了对野岛的爱车恶作剧。当然，祐辅在停车场看见过野岛的BMW。那个时候还想这个贷款可不得了，后来听说是他父亲当场付款买给他的。学生们踢踹这台BMW的轮胎，把冰激凌倒在挡风玻璃上，来发泄对他的郁愤之情。 “到了这种程度吗？”虽然是别人的事，祐辅也担心起来，询问铃江到。“野岛老师和学生们这么合不来吗？” “野岛太过偏心了”,铃江富态的脸表面上皱起眉头，眼镜下眯起的眼却难掩笑意。顺便一提，她是属于被野岛无视的女性之一。“不漂亮的女生，不管是向他提问还是哭鼻子什么的，都完全无视。反过来说对可爱的女生则是无原则地溺爱。我的天使啊，小猫仔啊之类，毫不害臊地这么称呼，而且还是在上课的时候。” “难道，这个算是性骚扰吗？” “没有什么难道不难道的，这个就是性骚扰“，嘎哈哈，铃江豪快地笑了起来。“完全把她们当成自己的女人了。还有传闻说他会选择看起来温顺的女生摸胸和屁股，虽然没有证据。以为是自己的后宫吗？对学生们而言已经是要怒发冲冠的程度了，不管是被无视的一方还是被溺爱的一方。那么露骨地narcissism“ ” narcissism？“ ”就是觉得自己非常可爱地自我陶醉着。要是使用了暴力的话，学生们也容易投诉了，不过他也算是个高智商罪犯，这就更加惹学生发火了。现在他那自豪的BMW已经被搞成废铁了吧？不知道还会发生什么，最近他也小心起来，乘公交来学校了” 回忆起这些话，祐辅悄悄地离开了复印室。仔细一想，现在野岛在做的大量复印应该也不是公务而是私事吧。看不出他是会留到这么晚热心工作的人，这样解释还比较合理。不管怎样，就算问野岛失窃答卷的事也是白费力气。 那么，之后要怎么办呢。想烦了的祐辅离开了校舍。今晚要是找不到答卷的话，只有向合适的对象说明事态了，之后再讨论对策。问题是首先该找谁商量呢？一下子就找校长、教头级别的实在有些胆怯，还是先找国文教科的主任或者同教科的前辈教师比较合适。烦恼了一会儿后，祐辅决定和我孙子铃江老师商量，她对这种程度的事应该不会慌乱吧。 祐辅这样想着走出校门，在人行道上走了一会后，突然停了下来。好像忘记了什么 —— 然后惊讶地想起来了。对了，车呢，把自己的车给忘了。本来打算拿了AV就立刻回来所以连引擎都没关。。。。。。 祐辅转身往校门前走，突然，像是被什么东西绊到一样，停了下来。大张着嘴，凝视着路灯照耀下的路面。那里什么都没有。祐辅确实是把他的国产轿车停在那里的，但现在却像是烟雾似的消失不见了。 被偷了。。。。。。接连遭到答卷和轿车失窃的双重打击，祐辅不由得跪倒在地。被偷了。。。被偷走了。确实，把钥匙插在车上，就像是叫人来偷一样。本来应该能在一分之内回来的，但是因为答卷失窃这个突发事件而不知所措，时间就这样过去了。。。 多么倒霉的一晚啊，真的是。。。回过神来，祐辅发现那卷AV倒是好好地抓在右手上。在这么动摇的状态下还把AV的事牢牢记在心里，祐辅觉得自己真是滑稽到不行。就算是死，色情录像也不能放手吗。。。一个人对着虚空苦笑着。这次真实亲身感受什么叫祸不单行了。 不知在原地发呆了多久，突然回过神来的祐辅看了下表，已经八点半了。算了，不管了。连给铃江打电话的事都忘了，祐辅步行着前往闹市区。在常去的小酒馆里大口大口喝着酒，总之先一醉解千愁吧。但是，偏偏在这种时候怎么喝也喝不醉。祐辅只能放弃这个打算，在十一点半左右就回家了。 在出租车上的时候，他终于想起来一件理所当然的事——公寓的钥匙没有了。和车钥匙串在一起插在被偷走的车上呢。而且祐辅所住公寓的管理人并不和他们住在一起，所以备用钥匙也没法马上拿到。 妈的，该怎么办啊。倒霉的时候，真的是倒霉到家了。感觉要哭出来了，下车的时候还自暴自弃地多给了小费。将错就错，今晚干脆在公园露宿得了。 但是，目送出租车离去后转向公寓时，祐辅不禁大叫出声。公寓前不可思议地停着一辆眼熟的轿车。祐辅擦着眼睛仔细窥看车牌，没错，是他的车，就是刚才在校门口消失不见的那辆。 祐辅像在做梦一样打开了车门。引擎已经关闭了，但自己的钥匙圈还插在上面。究竟是怎么回事啊，祐辅扭着脖子坐进了驾驶席。虽然喝了相当不少，但也不能就这么把车停在路上，必须停进停车场里。正要发动引擎的时候，他注意到了。 车内漂浮着些微甜腻的香气。从鼻孔里直冲脑髓，视野里一瞬间染上了粉红色，这种性感的香气确实是。。。。。。 祐辅甩了甩头，停止了思考。今天已经很累了。明天，用脑就等明天吧。倒是还记得要给铃江打电话的事，但已经这么晚了，而且酒劲也上来了，祐辅感觉随便什么都无所谓了。明天，等明天吧。好不容易把车停进停车场后，衣服也不换就这么钻进从来不叠的被褥里睡着了。 3. 第二天早上。祐辅一夜无梦，从熟睡中睁眼醒来，就立刻想起了答卷的事。“怎么办啊”，祐辅抱着宿醉的脑袋呻吟着。昨晚上没有向任何人报告答卷失窃的事，冷静地想想这实在是太糟糕了。没办法了，就报告说今天上班时才发现这件事的吧，祐辅怀着愧疚之情这么决定。 然而，上班后祐辅再次吃惊地下巴都要掉下来了，不由得扑倒在自己的桌子上。装着答卷的信封无可置疑地放置在桌上，就是自己昨天刚刚批改完的，三个班级的试卷。 放下心来的祐辅露出了破涕为笑般的复杂表情。“真的很棒对吧”，邻座的稻叶嘉彦似乎把他的表情当做了淫荡的微笑，发出“呵呵呵”的笑声道：“还有很多哦，欧美版的OO和XX等等，那个可厉害了。想看的话随时和我说”。（译者注：OO和XX似乎是AV术语的样子，翻不出来。。。） 听到他的话祐辅回过神来，慌慌张张地开始检查三个班级的试卷。没错，就算还回来了也不代表里面的东西就完全没事。说不定。。。。。。因为不详的预感而浑身发抖的祐辅仔仔细细地进行了检查。但是所有的答卷都在。难道是篡改了解答或分数？祐辅睁圆了双眼细看自己写下的红色笔迹。但也同样没有发现任何问题。 终于祐辅安下心来叹了口气，但随着而来的是更深的疑问。这究竟是怎么回事？原以为答卷被偷了，第二天却完璧归赵。就好像昨晚上自己的车一样。。。。。。想到这，祐辅下意识地寻找着尼岸须美子的身影。她正坐在远处自己的座位上。 须美子好像也在窥视着祐辅，两人突然对上了眼，她慌忙转开了视线。至今为止从未见过她这么慌张的样子，即使不愿意也越发怀疑起她来。 偷走自己车的毫无疑问就是须美子——祐辅这样确信。昨晚被扔在公寓前的车里漂浮的香气，那是须美子擦的香水。至少也是和她用的非常相似。她在职员室门口和自己擦肩而过，然后就把停在校门口的车开走了，这样假设不管从状况上还是从时间上来说都非常自然。 而且还有答卷的事。离开职员室时她抱在胸前的信封，那应该就是祐辅批改完的答卷吧。那么偷走答卷的犯人也是须美子了。大概就是这样了吧，想不出其它可能了，但是。 但是，须美子究竟为什么要做这样的事呢？偷走答卷开车逃跑，结果车当晚就归还了，答卷也在第二天一早放回了祐辅桌上，完全没有改动过。到底有什么理由要特意做这种事？ 祐辅的脑子被这个问题搅成一团浆糊，一整天都心不在焉。回过神来，发觉自己一直盯着须美子看都看累了。太过专心于思考这件事，以至于差点就忘了今天傍晚和匠千晓约好一起喝酒了。 4. 祐辅到达自学生时代起就经常光顾的小酒馆的时候，千晓已经进了可以说是指定席的小间里，一个人自斟自饮着。看见学弟这张像是在棉花糖上涂鸦般、毫无半点紧张感的脸，祐辅莫名其妙地生气气来。我都这么烦恼了，你这家伙也稍微给我动动脑子吧，这样想着把昨晚到今早发生的一连串事件详细地向他说明了。 …… (还有很多限于本小博客篇幅就不贴太多文字了，有兴趣的朋友可以和我邮件交流。) 其它作者拟列出的题目有： 4、被叫出来的婚约者的问题 5、不吸取教训的无礼之徒的问题 6、被关在室内的嫌疑犯的问题 7、打印出来的不幸之信件的问题 8、新啤酒之家的问题","tags":[]},{"title":"白井智之《不适合料理的少女》","date":"2018-02-20T14:51:39.000Z","path":"2018/bushiheliaolidishaonv.html","text":"来自豆瓣hayashi(林国立？)民翻的推理短篇。白井的小说以变态出名，可惜他的作品目前还没有中文作品出版，哈哈，估计以他的风格也很难在大陆出版吧。网上偶然读到这篇民翻，算是对白井风格的唯一认识渠道。自己很喜欢这种风格，于是在博客备份一篇，供自己以后重读。原文如下： 《不适合料理的少女》译者说明：处女渣翻，请不吝赐教。 这个短篇发布在2015年12月的「小説宝石」杂志上，原作题目是「料理には向かない少女」。 《不适合料理的少女》正文：[第一天] 睁开眼睛的时候，身上都是血的两名全裸少女正并排站在一起看着自己。 好像是从很高的地方掉下来了吧，doroshi从未经历过此番苦楚的身体发出痛苦的悲鸣。几乎痛到不能呼吸，就算张开嘴巴，也完全发不出声音。大口大口地吸气，夹杂着呕吐物和排泄物气味的恶臭却一阵阵地往鼻孔涌来。 见到从高处坠入的doroshi，两名少女一点不见惊讶，自顾自轻声地商量着什么事情。其中的一位颊骨突出，看起来像是拒食症患者；另一位则胖得像熟透的西红柿，每一次呼吸都会连带晃动下巴的赘肉。两人看起来都和doroshi一样是十几岁的年纪，光滑的胴体上满是鲜血和污物凝固后的痕迹。 “那么，我动手了。” 胖少女简短地交待后，转过头骑在了doroshi的裸体上，将一根足有三米长的巨型蚯蚓一样的东西缠在doroshi脖子上，两手慢慢地发力。脖颈被这干瘪的条状物绞紧，气管被压迫，苦味渐渐在口中扩散开来，扭动身体想要逃开，铅一样的少女却一动也不动。doroshi睁开眼睛，奋力挣扎，正好和咬紧牙关俯视自己的胖少女四目相对。 “等一下。” 病人一样的少女这么说着，出手阻止了胖少女的绞杀。胖少女放下巨型蚯蚓，又和病少女说了些什么，然后慢慢地从doroshi身上挪开。doroshi按着喉咙，还是一副喘不过气的样子，病少女于是双手插进doroshi的腋下，将她拉过来平躺在地板上。 “seruma死了” 病少女一边坐下一边轻声嘀咕。顺着她的方向往左边看，doroshi才发觉自己刚才摔倒的地方旁边躺着另一位头部已经扭曲的少女。 “那她就这样没问题么？” 胖少女用闪烁的眼神盯着doroshi，向同伴征求意见。 “不杀她也可以。” 病少女此言一出，胖少女抖了抖肩膀，明显是松了一口气。虽然还搞不清楚状况，但暂时没有性命之虞这件事，doroshi是可以确定了。 稍稍安心的同时，几个疑问一齐涌上来：这个幽暗的场所是什么地方？她们都是些什么人？为什么全员都裸着？这几天的记忆像罩上了雾一样模糊不清，唯独知道这样的地方不可能是自己的居所。 十几秒的沉默。 地板突然开始摇动，和下水道施工时一样的咣咣声让屋子里的空气都震动起来。两位少女一点也不惊讶，只是站靠在墙壁上。 再次向周围打量，墙壁表面的水泥已经开始脱落的这个幽暗房间里摆放着三个巨大的玻璃筒。房间是三角形，每个角各放置一个玻璃筒，每个筒里都有几名看上去十几岁的少女，自己也身处其中的一个玻璃筒中。房间的中央有一个巨大的熔炉一样的圆洞，上面只架着一把生锈的梯子，圆洞深处可见的只有无边的黑暗。 机器音从doroshi右边的玻璃筒中传出，筒中五名全裸的少女像在蜂巢中劳作一样左右晃动，咣咣的声音越变越大了。 “还是不要看比较好。”胖少女有些忧郁地低声提醒。 随即，血液像花洒里的水一样从少女们身体里喷涌出来，四肢和身体相继爆裂，涌出的内脏被绞成碎块，五名少女瞬间血肉交融，骨块和肉片铺满了玻璃筒的地面。 机器音停止后，右边的玻璃筒伴随着吱吱吱的摩擦声缓缓升起，在高约五米的地方开始倾斜，散落在玻璃地板的骨肉借着血液的润滑集中到一处，随着玻璃筒的倾斜，少女们的血肉从筒中溢出，依次掉入房间中央的圆洞里面。 —————————— 三十分钟过后，早先的剧痛渐渐缓和，没有大量的出血和骨折，doroshi已经算是幸运的了。两位少女看上去好像也没有再度袭击自己的意思，与身体上的疼痛相比，眼前和“正常”二字相去甚远的状况引起的混乱和不安更让doroshi感到在意。 在doroshi自己所在的玻璃筒里，并不是只有doroshi和两位少女，圆筒的一个角落里还堆满了数不清的少女的尸体，因为一个个叠在一起，所以无法看清脸部。只靠身体轮廓辨别的话，倒是可以确定都是十几岁的少女。眼前的这幅情景，就跟在图书馆看到的波兰集中营照片上的惨状差不多。 “那个，你们是谁？”doroshi用手掌遮住大腿间的部分，慢慢地起身。 “刚才猛绞你的脖子，真是抱歉。我是nina。”胖少女一边抚弄自己些微粘住的红发一边回答。即使只是轻轻咳嗽，也会让腹部和乳房的肉一齐动起来。doroshi自报家门后，她又接过话头介绍起自己的瘦同伴：“这位是reira。” 名叫reira的瘦少女，此时正把刚刚头部扭断的少女叠到比自己还高的少女尸山的顶部。 “只问你一个问题。你已经出不去了，是想现在死，还是要在这个晦暗的虫箱一样的地方活下去？你选哪一样？”reira用盛气凌人的声音提问完，就势坐在doroshi身前，左手无名指上的黄铜戒指闪闪发光。 “活、活下去……我想活下去。” “这样啊。那么一定要遵守规则才行噢，为了活下去一定要守规则，没有别的办法。这个胖子刚来了六天，我已经在这里十七天了，就是因为掌握了规则才活了下来。” “那，要忍耐到什么时候呢？” “我怎么知道，能从这个食品加工机里逃出去的家伙一个也没有。一定要设想一种情况的话，应该就是这个容器被尸体塞满到溢出的时候吧。” “食品加工机？” “不知道么？就是把食材切成很小的一块一块的机器啊。” “大概和绞肉或切鱼时用的搅拌机是一类东西。”nina补充道。 “你也看到那些来回转动的刀刃了，应该明白的吧。这里的三个玻璃容器其实就是人肉食品加工器。千万别问我是谁造出来的这种东西，问也是白问。每一个玻璃筒每天都会投下一名十四岁的少女，一共有三个容器，所以每天共计投下少女三名。然后，达到一定数量之后，机器就会开始运转，把玻璃罩里的人都变成肉末。”reira指着身后的罩子向doroshi说明。 半径大约三米的玻璃筒中央，竖立着一根直径约为一米的竿子。齐腰处插着两片点对称排列的刀片，长度一直延伸到doroshi的头顶，灰色的刀刃散发着黯淡的光。 “我掉入玻璃筒的时候，这里还一个人也没有。现在重新想想，应该是前一天刚绞过一次肉的缘故吧。从那以后每天都会有一名少女掉下来，大家无论肤色还是住所都相差甚远，唯有的共通之处是刚好大家都是十四岁。看到另外两个容器的情景，我们察觉到只要凑齐五个人，机器就会开动。想要逃走却发现天花板高得不行，总之是想不到别的办法，只能等死了。 但是第四天掉落的少女却因为撞到头而死掉了，第二天又有一名少女掉落，但机器却没有开动。于是我们明白了凑足的五人必须都是活人，刀片才会运转。” reira停下解说，拾起掉落在脚边的指甲丢向墙壁。玻璃筒的外围形成了一块小型洼地，沉积着呕吐物、排泄物和其他脏东西。 “后来，怎么样了？” “当然免不了一场杀戮，第二天之前不把其中的某人杀掉的话，大家通通都要变肉末。最后有两个人死掉了，包括我在内的三个人活了下来，其中就有你刚刚压死的seruma。” seruma就是刚才被reira抬到尸山的少女了，不幸当了doroshi的垫背而命丧黄泉。自己直接造成了别人的死亡这件事，也让doroshi的呼吸紧促起来。 “你也别太在意了，本来就是懈怠自己头上状况的seruma的错。杀人的时候一直后悔的话，在这里可是活不下去的。” “要说杀人的话，我也是一样在干的噢。”nina脸上泛着僵硬的笑说道。 “那么，规则到底是什么？” “轮流杀死掉进这个玻璃筒的少女。为了不让活人数量增加，最好在人刚刚掉进来的时候就杀掉。明天就由你来杀吧”，reira冷漠地说明着，“如果你不杀的话，我会先和你做个了结的。” —————————— 既没有钟也没有手机，具体的时刻根本无从知晓。除了戒指和耳钉，身上的衣服和配饰全部被取下。doroshi继续用手掌遮住两腿之间慢慢地站起来，无所事事地向筒外眺望。 天花板上吊着的裸露灯泡为三个玻璃筒投下一层稀薄的色彩。右边的玻璃筒现在空着，地板上还粘着少量模糊的血肉。与此形成鲜明对比的，左边圆筒里有四个少女正靠在一起。还没有开始互相残杀，是因为还没能明白食品加工机的规则吧？要是知道明天会发生什么的话，绝不可能像现在这样和谐。 将视线移回自己所在的玻璃筒，角落里的少女尸山正炫耀着自己大写加粗的存在感。像是垃圾场里的垃圾袋一样，少女们的尸体随意的叠在一起，数了一下，尸体一共是十四具。其中的大多数都是在掉进食品加工机之后旋即被reira或者seruma杀死的吧。 doroshi又抬头望向黑暗的顶部，自己离容器的上端大概还有六、七米左右的距离，就算弹跳力再怎么好也根本够不到边缘。要是墙壁上有凹凸的部分的话，自己的那点攀岩技能倒是可以派上用场，不巧的是别说凹进或凸起了，玻璃壁上连一点刮痕都没有。 这样一来，doroshi又把目光投向筒中的竿子，高约八十厘米的地方插进的刀刃划着弧线向上方弯曲，小心避开刀刃的话，是有可能上到刀具上的。从那里像投套索一样投出巨型蚯蚓——其实是人的肠子的话，也许可以够到容器的边缘。但是又没有能勾住肠子的地方，还是无望逃出生天。 doroshi忽然回过神，对正在冷静思考眼前状况的自己感到大为惊讶。哪怕稍稍有一点实感，自己大概会以为正在做梦或者演剧吧，但反而是因为实在太荒诞了，怀疑自己眼睛的心思一次都没有过。真讨厌既没有发狂也没有精神错乱的自己啊。 “doroshi还记得来这里之前的事情么？”背后的声音来自胖得跟桶一样的少女nina。 “虽然有些记不清楚，但午后跑到学校旁边的海这一点倒是可以确定。自由潜水（注：即不戴呼吸设备的闭气潜水）大赛就要开始了，去那里练习来着。还能记得海水凉凉的触感，之后的事情就不确定了。” doroshi谨慎地遣词造句，去海边后的记忆都丧失了是没错，练习潜水的事情却不是真的。 “没有听到救护车汽笛声的记忆么？” “这么一说好像确实有这么回事呢。”含糊不清地点着头回应的doroshi，感到鼻腔了散开一阵稀薄的薄荷香气。看病时经常去的隔壁街区医院里前院长的夫人，因为经常要使用芳香疗法治病，常常让精油的香气飘得到处都是，引得附近街坊几次三番前去投诉。恐怕自己在海里失去意识之后，就是被搬送到了那间医院吧。 “因为还留有去过诊疗室的记忆，所以在那之前应该被搬上过救护车吧。” “果然是这样么？我也记得自己被抬上过担架。那之前的一天和男朋友大吵了一架，自暴自弃地喝多了威士忌。回家的途中被车撞到了，虽然好像只是稍微撞伤了脚，却一下子来了几辆救护车和出租车。但是从那之后的事我也不记得了。” 听了这番话，doroshi才发现nina的右小腿上红黑色的淤血，行动也有些笨拙。 “我怀疑那些救护车是假的。” “恩，确实有可能是劫持我们的变态假扮的。” “真是搞不懂啊。” 躺下盯着天花板的reira突然说话了，年纪明明差不多，口气却还是那么冲：“我在校庭的草坪上小睡，惊醒时就发现自己在这里了。脑子不行的话再怎么思考都是没有用的。” “睡着的时候受了很重的伤，于是被搬上了救护车，这也不是没有可能嘛。” “喂，我不是说过再怎么推测都没有用的么？犯人是政府也好恶魔也好外星人也好，我们不是一样逃不出去么？要是有逃出去的方法就告诉我，不然赶紧闭嘴。” “reira还记得被送到这里之前的事情么？”doroshi试着打开话匣子。 “记得是记得，不过我不会告诉你的。”reira回答时眉头都不皱一下。 “reira真会刁难人，是AB血型吧？”nina有些嫌弃地问道。 “是的噢。” “啊，果然是这样。那一定有弟弟或者妹妹吧，绝对是这样。”nina说得唾沫星子四溅。 reira有点扭捏地答道：“我是独生女。” “诶？真是意外呢。” “光靠血型就能明白性格什么的，别再说这些东洋人令人作呕的鬼话了。你就是这样才被男朋友甩掉的不是么？”reira狠狠地反击。 “好过分，才不是这样呢！”nina急得直跺脚，象一样的屁股随之剧烈抖动。 “别吵了，喷气也差不多要来了。明天见。”reira保持着刚才的姿势闭上了眼睛，照明合拍地转暗了，头顶响起了和喷射灭火器时一样的泄漏声。 “一到晚上这里就会喷出催眠气体噢。”doroshi的脚边传来nina的声音，不知道什么时候起她已经躺下了。 虽然觉得应该还没有那么快入夜，但因为没有时钟，也无法确认自己的想法。感觉到两名少女身体和附近洼地里粪便的doroshi也就势躺下，氨水一样的恶臭一阵阵涌向鼻腔。 拼命按下不断涌上心头的不安，doroshi闭上了眼睛。 —————————— …… (限于博客服务器的负载考量，不想贴太多文字，有兴趣去豆瓣原作者那看吧！)","tags":[{"name":"推理","slug":"推理","permalink":"http://blog.jfz.me/tags/推理/"}]},{"title":"C++封装的基于WinSock2的TCP服务端、客户端","date":"2017-08-29T08:34:55.000Z","path":"2017/cpp-winsock2-tcp.html","text":"无聊研究Winsock套接字编程，用原生的C语言接口写出来的代码看着难受，于是自己简单用C++封装一下，把思路过程理清，方便自己后续翻看和新手学习。 只写好了TCP通信服务端，有空把客户端流程也封装一下。 先上主函数： // main.cpp : 异想家sandeepin poi！ #include “stdafx.h” #include extern int JTCPserver();extern int JTCPclient();int main(){ JTCPserver(); // 两者选一// JTCPclient(); return 0;} JTCPserver.cpp内容： // JTCPserver.cpp : 蒋方正封装的TCP服务端 #include “stdafx.h” #include #include #include &lt;WinSock2.h&gt; // WinSocket #include &lt;WS2tcpip.h&gt; // IP地址转换用到inet_pton #pragma comment(lib,”ws2_32.lib”)using namespace std; // 【1】初始化WinSockbool initWinSock();// 【2】创建socketbool createSocket(SOCKET &amp;listenScok);// 【3】socket绑定本机地址信息bool bindIPandPort(SOCKET &amp;listenScok, const string ip, const unsigned short port);// 【4】侦听socket，接收客户端请求bool listenSocket(SOCKET &amp;listenScok);// 【5】等待客户端连接-阻塞bool waitClientConnect(SOCKET &amp;listenScok, SOCKET &amp;clientSock);// 【6】接收数据-阻塞bool receiveData(SOCKET &amp;clientSock, string &amp;data);// 【7】停止套接字的接收、发送bool shutdownSocket(SOCKET &amp;clientSock);// 【8】发送信息bool sendData(SOCKET &amp;clientSock, const string &amp;data); int JTCPserver(){ SOCKET listenScok; // 服务端Socket SOCKET clientSock; // 客户端Socket string data; // 收到的数据 // 【1】初始化WinSock initWinSock(); // 【2】创建socket createSocket(listenScok); // 【3】socket绑定本机地址信息 bindIPandPort(listenScok, &quot;127.0.0.1&quot;, 1994); // 【4】侦听socket，接收客户端请求 listenSocket(listenScok); // 坐等客户端连接 bool isClientSockConnect = false; // 是否有客户端连进来 bool isReceiveData = false; // 是否接收数据成功 while (true) { if (!isClientSockConnect) { // 【5】等待客户端连接 isClientSockConnect = waitClientConnect(listenScok, clientSock); } else { if(!isReceiveData) { // 【6】接收数据-阻塞 isReceiveData = receiveData(clientSock, data); // 如果接收数据失败则断开 if(!isReceiveData) { // 【7】停止套接字的接收、发送 shutdownSocket(clientSock); cout &lt;&lt; &quot;等待客户端再连接...&quot; &lt;&lt; endl; isClientSockConnect = false; // 可以重连了 } } if(isReceiveData &amp;&amp; data != &quot;jfzpoi&quot; &amp;&amp; data != &quot;@end#&quot;) { isReceiveData = false; } if(isReceiveData &amp;&amp; data == &quot;jfzpoi&quot;) { // 【8】发送信息(收的数据为jfzpoi) sendData(clientSock, &quot;sandeepin!\\\\r\\\\n&quot;); isReceiveData = false; } if (isReceiveData &amp;&amp; data == &quot;@end#&quot;) { // 【9】关闭相关 int err; // err = shutdown(listenScok, 2);// if (err == SOCKET_ERROR)// {// cout &lt;&lt; “关闭失败！” &lt;&lt; endl;// } // 关闭套接字，释放资源 err = closesocket(listenScok); if (err == SOCKET_ERROR) { cout &lt;&lt; “关闭socket失败！” &lt;&lt; endl; } // 停止使用WinSock库，释放对应资源 if (WSACleanup() != 0) { cout &lt;&lt; “WSA清空失败！” &lt;&lt; endl; } cout &lt;&lt; “关完了，坐等关机！poi” &lt;&lt; endl; return 0; } } }} // 【1】初始化WinSockbool initWinSock(){ WORD verision = MAKEWORD(2, 2); WSADATA lpData; int intEr = WSAStartup(verision, &amp;lpData); // 指定winsock版本并初始化 if (intEr != 0) { cout &lt;&lt; “WinSock初始化失败！” &lt;&lt; endl; return false; } cout &lt;&lt; “WinSock初始化成功！” &lt;&lt; endl; return true;} // 【2】创建socketbool createSocket(SOCKET &amp;listenScok){ // 创建侦听socket listenScok = socket(AF_INET, SOCK_STREAM, 0); if (listenScok == INVALID_SOCKET) { cout &lt;&lt; “socket创建失败！” &lt;&lt; endl; return false; } cout &lt;&lt; “socket创建成功！” &lt;&lt; endl; return true;} // 【3】socket绑定本机地址信息bool bindIPandPort(SOCKET &amp;listenScok, const string ip, const unsigned short port){ // 制作sockaddr_in结构体 // 在bind函数，connect函数里提到了套接字编程网络地址信息结构体const struct sockaddr和const struct sockaddr_i sockaddr_in hostAddr; hostAddr.sin_family = AF_INET; hostAddr.sin_port = htons(port);//转换成网络字节序 //hostAddr.sin_addr.S_un.S_addr = inet_addr(SERVERIP);//转换成网络字节序 //cout &lt;&lt; “net IP:” &lt;&lt; hostAddr.sin_addr.S_un.S_addr &lt;&lt; endl; /* inet_addr()版本太低，被弃用使用inet_pton(协议族，字符串IP地址，void目标in_addr) 头文件：WS2tcpip.h / in_addr addr; inet_pton(AF_INET, ip.c_str(), (void*)&amp;addr); hostAddr.sin_addr = addr; cout &lt;&lt; “ip(网络字节序):” &lt;&lt; addr.S_un.S_addr &lt;&lt; endl; cout &lt;&lt; “ip(常规形式):” &lt;&lt; ip.c_str() &lt;&lt; endl; // 侦听套接字listenSock绑定本机地址信息 int err = bind(listenScok, (struct sockaddr*)&amp;hostAddr, sizeof(sockaddr)); if (err != 0) { cout &lt;&lt; &quot;本地IP绑定失败！&quot; &lt;&lt; endl; return false; } return true; } // 【4】侦听socket，接收客户端请求bool listenSocket(SOCKET &amp;listenScok){ // 设定套接字为侦听状态，准备接收客户机进程发送来的连接请求 int err = listen(listenScok, 3); if (err != 0) { cout &lt;&lt; “socket监听失败！” &lt;&lt; endl; return false; } cout &lt;&lt; “监听客户端连接中……” &lt;&lt; endl; return true;} // 【5】等待客户端连接-阻塞bool waitClientConnect(SOCKET &amp;listenScok, SOCKET &amp;clientSock){ sockaddr_in clientAddr; int len = sizeof(struct sockaddr); // 必须指定长度，否则会导致accept返回10014错误 // accept会循环等待客户端连接 clientSock = accept(listenScok, (struct sockaddr*)&amp;clientAddr, &amp;len); cout &lt;&lt; “客户端Socket编号:” &lt;&lt; clientSock &lt;&lt; endl; if (clientSock == INVALID_SOCKET) { cout &lt;&lt; “客户端连接失败！” &lt;&lt; endl; cout &lt;&lt; WSAGetLastError() &lt;&lt; endl; return false; } return true;} // 【6】接收数据-阻塞bool receiveData(SOCKET &amp;clientSock, string &amp;data){ static int cnt = 1; // 接收数据编号-静态 // 通过已建立连接的套接字，接收数据 设定缓冲1024字节 char buf[1024] = “\\0”; // flags操作方式（0正常数据，MSG_PEED系统缓冲区的数据复制到所提供的接收缓冲区内，系统缓冲区数据未删除，MSG_OOB处理带外数据，通常用参数0即可） int buflen = recv(clientSock, buf, 1024, 0); if (buflen == SOCKET_ERROR) { cout &lt;&lt; “接收失败！” &lt;&lt; endl; return false; } // 一切正常则显示接收数据 data = string(buf); cout &lt;&lt; “收到第” &lt;&lt; cnt++ &lt;&lt; “次，内容为:\\n” &lt;&lt; buf &lt;&lt; endl; return true;} // 【7】停止套接字的接收、发送bool shutdownSocket(SOCKET &amp;clientSock){ //（收完就关）停止套接字的接收、发送功能（0禁止接收，1禁止发送，2禁制接收发送） int err = shutdown(clientSock, 2); if (err == SOCKET_ERROR) { cout &lt;&lt; “关闭Socket失败！” &lt;&lt; endl; return false; } return true;} // 【8】发送信息bool sendData(SOCKET &amp;clientSock, const string &amp;data){ int err = send(clientSock, data.c_str(), data.size(), 0); if (err == SOCKET_ERROR) { cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl; return false; } cout &lt;&lt; &quot;发送数据为:\\\\n&quot; &lt;&lt; data &lt;&lt; endl; return true; } JTCPclient.cpp内容： // JTCPclient.cpp : 蒋方正封装的TCP客户端代码 #include “stdafx.h” #include #include &lt;WinSock2.h&gt; #include &lt;WS2tcpip.h&gt; #pragma comment(lib,”ws2_32.lib”)using namespace std; // 【1】初始化WinSockbool initWinSockC();// 【2】创建socketbool createSocketC(SOCKET &amp;listenScok);// 【3】连接到服务器bool connectSocketC(SOCKET &amp;conSock, const string ip, const unsigned short port);// 【4】发送数据bool sendDataC(SOCKET &amp;clientSock, const string &amp;data);// 【5】接收数据bool receiveDataC(SOCKET &amp;clientSock, string &amp;data); int JTCPclient(){ SOCKET clientSock; // 客户端Socket string data; // 收到的数据 bool isCreateSocket = false; // 是否创建了Socket bool isConnectSocket = false; // 是否连上了服务器 bool isSendDataOK = false; // 是否发送成功数据 bool isReceiveDataOK = false; // 是否接收成功数据 // 【1】初始化WinSock if(initWinSockC()) { while (true) { if(!isCreateSocket) { // 【2】创建socket createSocketC(clientSock); isCreateSocket = true; } else { if(!isConnectSocket) { // 【3】连接到服务器 connectSocketC(clientSock, &quot;127.0.0.1&quot;, 1994); isConnectSocket = true; } else { if(!isSendDataOK) { // 【4】发送数据 isSendDataOK = sendDataC(clientSock, &quot;jfz hello\\\\r\\\\n&quot;); } else { if(!isReceiveDataOK) { // 【5】接收数据 isReceiveDataOK = receiveDataC(clientSock, data); } else { if(data == &quot;@end#&quot;) { WSACleanup(); return 0; } isReceiveDataOK = false; isSendDataOK = false; } } } } } } return 0; } // 【1】初始化WinSockbool initWinSockC(){ WORD verision = MAKEWORD(2, 2); WSADATA lpData; int intEr = WSAStartup(verision, &amp;lpData); // 指定winsock版本并初始化 if (intEr != 0) { std::cout &lt;&lt; “WinSock初始化失败！” &lt;&lt; endl; return false; } std::cout &lt;&lt; “WinSock初始化成功！” &lt;&lt; endl; return true;} // 【2】创建socketbool createSocketC(SOCKET &amp;listenScok){ // 创建侦听socket listenScok = socket(AF_INET, SOCK_STREAM, 0); if (listenScok == INVALID_SOCKET) { cout &lt;&lt; “socket创建失败！” &lt;&lt; endl; return false; } cout &lt;&lt; “socket创建成功！” &lt;&lt; endl; return true;} // 【3】连接到服务器bool connectSocketC(SOCKET &amp;conSock, const string ip, const unsigned short port){ // 建立地址结构体 sockaddr_in hostAddr; hostAddr.sin_family = AF_INET; hostAddr.sin_port = htons(port);//转换成网络字节序 //hostAddr.sin_addr.S_un.S_addr = inet_addr(SERVERIP);//转换成网络字节序 //cout &lt;&lt; “net IP:” &lt;&lt; hostAddr.sin_addr.S_un.S_addr &lt;&lt; endl; /* inet_addr()版本太低，被弃用使用inet_pton(协议族，字符串IP地址，void目标in_addr) 头文件：WS2tcpip.h / in_addr addr; inet_pton(AF_INET, ip.c_str(), (void*)&amp;addr); hostAddr.sin_addr = addr; cout &lt;&lt; “ip(网络字节序):” &lt;&lt; addr.S_un.S_addr &lt;&lt; endl; cout &lt;&lt; “ip(常规形式):” &lt;&lt; ip.c_str() &lt;&lt; endl; // 向服务器提出连接请求 int err = connect(conSock, (sockaddr*)&amp;hostAddr, sizeof(sockaddr)); if (err == INVALID_SOCKET) { cout &lt;&lt; &quot;连接服务器失败！&quot; &lt;&lt; endl; return false; } return true; } // 【4】发送数据bool sendDataC(SOCKET &amp;clientSock, const string &amp;data){ int err = send(clientSock, data.c_str(), data.size(), 0); if (err == SOCKET_ERROR) { cout &lt;&lt; “发送失败！” &lt;&lt; endl; return false; } cout &lt;&lt; “发送数据为:\\n” &lt;&lt; data.c_str() &lt;&lt; endl; return true;} // 【5】接收数据bool receiveDataC(SOCKET &amp;clientSock, string &amp;data){ static int cnt = 1; // 接收数据编号-静态 // 通过已建立连接的套接字，接收数据 设定缓冲1024字节 char buf[1024] = “\\0”; // flags操作方式（0正常数据，MSG_PEED系统缓冲区的数据复制到所提供的接收缓冲区内，系统缓冲区数据未删除，MSG_OOB处理带外数据，通常用参数0即可） int buflen = recv(clientSock, buf, 1024, 0); if (buflen == SOCKET_ERROR) { cout &lt;&lt; “接收失败！” &lt;&lt; endl; return false; } // 一切正常则显示接收数据 data = string(buf); cout &lt;&lt; “收到第” &lt;&lt; cnt++ &lt;&lt; “次，内容为:\\n” &lt;&lt; buf &lt;&lt; endl; return true;}","tags":[]},{"title":"Qt使用QAxObject快速批量读取Excel内容","date":"2017-05-05T08:28:15.000Z","path":"2017/qt-qaxobject-excel.html","text":"网上各种教程用的方法主要是如下这一句： QAxObject * range = worksheet-&gt;querySubObject(“Cells(int,int)”, 1, 1 ); 这种方法当然也行，可以一项一项地读，但是当读取数量很大的时候就很慢了，在我的电脑上测试读5000个数据大约168s左右。看资料找到一种批量读取的方法，经测试读10000行的数据才3s多，效果超级棒，充分发挥了QAxobject读取的优势。 核心代码在于这一句： QAxObject *range = worksheet-&gt;querySubObject(“Range(QString)”, “B13:C1000”); 用Range(QString)实现选取一大块区域，一次性读一个数组出来当然快啦。 附上完整的源码供大家交流学习： pro中加一句：QT+=axcontainer 核心代码： #include // 批量读取xls到mapint readEnvXlsFile(QString FileName, QMap&lt;QString,float&gt; &amp;map){ QAxObject excel = NULL; QAxObject workbooks = NULL; QAxObject workbook = NULL; excel = new QAxObject(“Excel.Application”); if (!excel) { qDebug() &lt;&lt; “EXCEL对象丢失!”; } excel-&gt;dynamicCall(“SetVisible(bool)”, false); workbooks = excel-&gt;querySubObject(“WorkBooks”); workbook = workbooks-&gt;querySubObject(“Open(QString, QVariant)”, FileName); QAxObject worksheet = workbook-&gt;querySubObject(“WorkSheets(int)”, 1);//打开第一个sheet QAxObject usedrange = worksheet-&gt;querySubObject(“UsedRange”);//获取该sheet的使用范围对象 QAxObject rows = usedrange-&gt;querySubObject(“Rows”); QAxObject * columns = usedrange-&gt;querySubObject(“Columns”); int intRows = rows-&gt;property(“Count”).toInt(); int intCols = columns-&gt;property(“Count”).toInt(); qDebug() &lt;&lt; “xls行数：”&lt;&lt;intRows; qDebug() &lt;&lt; “xls列数：”&lt;&lt;intCols; // 批量载入数据，这里默认读取B13:C最后 QString Range = &quot;B13:C&quot; +QString::number(intRows); QAxObject *allEnvData = worksheet-&gt;querySubObject(&quot;Range(QString)&quot;, Range); QVariant allEnvDataQVariant = allEnvData-&gt;property(&quot;Value&quot;); QVariantList allEnvDataList = allEnvDataQVariant.toList(); for(int i=0; i&lt;= intRows-13; i++) { QVariantList allEnvDataList_i = allEnvDataList\\[i\\].toList() ; //qDebug()&lt;&lt; allEnvDataList\\_i\\[0\\].toString()&lt;&lt; allEnvDataList\\_i\\[1\\].toFloat(); map.insert(allEnvDataList\\_i\\[0\\].toString(),allEnvDataList\\_i\\[1\\].toFloat()); } workbooks-&gt;dynamicCall(&quot;Close()&quot;); return 0; } Update 2017-05-06: 看了一下百度的这一篇已经提到了此方法。","tags":[]},{"title":"用Python实现根据角4点进行矩阵二维插值并画出伪彩色图","date":"2017-04-10T08:25:29.000Z","path":"2017/python-mat-difference-2d-plot.html","text":"哈哈，题目取得这么绕，其实就是自己写了一个很渣的类似图像放大的算法。已知矩阵四周的4点，扩展成更大的矩阵，中间的元素值均匀插入，例如： 矩阵： 1 2 3 4 扩展成3x3的： 1 1.5 2 2 2.5 3 3 3.5 4 不说废话，直接上代码： # -- coding: utf-8 --“””异想家二维插值算法。“””import matplotlibimport matplotlib.pyplot as pltimport numpy as npfrom numpy import * # 一维插值def yiweichazhi(inputmat): i = 0 for _ in inputmat: inputmat[i] = inputmat[0] + (inputmat[-1] - inputmat[0]) * i / (len(inputmat) - 1) i = i + 1 return inputmat # 画伪彩色图def 伪彩色图(zz): Row = zz.shape[0] Col = zz.shape[1] xx, yy = np.meshgrid(np.linspace(0, 10, Col), np.linspace(0, 10, Row)) # 图像xy范围和插值 cmap = matplotlib.cm.jet # 指定colormap plt.imshow(zz, origin=’lower’, extent=[xx.min(), xx.max(), yy.min(), yy.max()], cmap=cmap) # 伪彩色图 plt.show() # 由角4点扩展为插值大矩阵def 异想家插值(a): # 扩张矩阵 10x10 pointRow = 100 # 插值点数-行 pointCol = 100 # 插值点数-行 aa = np.zeros(\\[pointRow, pointCol\\], dtype=float) # 四周点直接赋值 aa\\[0\\]\\[0\\] = a\\[0\\]\\[0\\] aa\\[0\\]\\[-1\\] = a\\[0\\]\\[1\\] aa\\[-1\\]\\[0\\] = a\\[1\\]\\[0\\] aa\\[-1\\]\\[-1\\] = a\\[1\\]\\[1\\] # 四周先插值 aa\\[0\\] = yiweichazhi(aa\\[0\\]) aa\\[-1\\] = yiweichazhi(aa\\[-1\\]) aa\\[:, 0\\] = yiweichazhi(aa\\[:, 0\\]) aa\\[:, -1\\] = yiweichazhi(aa\\[:, -1\\]) # 全部插值 for i in range(len(aa)): aa\\[i\\] = yiweichazhi(aa\\[i\\]) i = i + 1 return aa # 未插值前4点矩阵a = np.array([ [1, 2], [3, 4]], dtype=float) aa = 异想家插值(a) # 打印aaprint(aa, “\\n”)# 画图伪彩色图(aa)","tags":[]},{"title":"CentOS7安装MySQL、Tomcat和GitBlit记录","date":"2017-03-26T08:22:44.000Z","path":"2017/centos7-mysql-tomcat-gitblit.html","text":"一、安装MySQL1、安装这个发布包 yum localinstall mysql-community-release-el6-5.noarch.rpm 可以通过下面的命令来确认这个仓库被成功添加： yum repolist enabled | grep “mysql.-community. 2、安装MySQL服务器 yum -y install mysql-server 3、设置开机启动 chkconfig mysqld on 4、启动MySql服务 service mysqld start 5、设置MySQL的root用户设置密码 mysql -u root 进入后用下面的命令设置root的密码为root： mysql&gt; set password for root@localhost=password（’root’）； mysql&gt; exit 6、用新密码登陆 mysql -u root -p 7、确认版本信息： mysql -V 8、基本命令 show databases; // 查看系统已存在的数据库 use databasesname; // 选择需要使用的数据库 drop database databasename; // 删除选定的数据库 exit // 退出数据库的连接 create database test01; // 建立名为test的数据库 show tables; // 列出当前数据库下的表 其他基本的增删改查使用标准SQL即可。 9、开放远程登录权限 全部（在MySQL界面输入）： GRANT ALL PRIVILEGES ON _._ TO ‘root‘@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION; FLUSH PRIVILEGES; 指定IP的写法： GRANT ALL ON _._ to root@’192.168.1.103’ IDENTIFIED BY ‘root’; FLUSH PRIVILEGES; 二、安装Tomcat1、下载地址，下载文件： http://tomcat.apache.org/ apache-tomcat-7.0.76.tar.gz 2、在usr/tomcat中解压 tar -zxvf apache-tomcat-7.0.76.tar.gz 3、进bin目录，运行tomcat： sh startup.sh Tomcat部署成功，访问页面正常： 127.0.0.1:8080 4、停止Tomcat： sh shutdown.sh 5、修改tomcat 8080端口为80： nano conf/server.xml 找到对应改端口的地方改为80。 6、放Web项目 直接将web项目文件件拷贝到webapps目录中，完毕！ 7、再启动Tomcat sh startup.sh 三、安装GitBlit1、下载GitBlit GitBlit的默认输出目录是这里，所以就创建这个目录： mkdir -p /opt/gitblit cd /opt/gitblit wget http://dl.bintray.com/gitblit/releases/gitblit-1.8.0.tar.gz 如果下载过程中出现提示：-bash: wget: command not foundls 说明没有安装wget程序，用yum库装一个即可： yum install wget 2、解压缩Gitblit 使用命令tar将下载到的gitblit压缩包解压缩到目标目录，我是解压缩到/opt/gitblit目录下： tar -zxvf gitblit-1.8.0.tar.gz 3、修改需要的配置文件 nano data/defaults.properties 根据自己的需要修改配置信息，我只修改了以下几个地方： git.repositoriesFolder = /opt/gitblit/data/git server.httpPort = 10101 server.httpBindInterface = 192.168.1.200 server.httpsBindInterface = 修改完以后保存，退出。 4、修改service-centos.sh nano service-centos.sh 根据自己的服务器的设置： GITBLIT_PATH = /opt/gitblit GITBLIT_BASE_FOLDER = /opt/gitblit/data GITBLIT_HTTP_PORT = 10101 修改完以后保存，退出。 5、启动gitblit 5.1、直接启动gitblit服务 通过java执行gitblit服务，要注意执行的命令参数，可以参考以下命令 java -jar gitblit.jar –baseFolder data # 当前在/opt/gitblit目录下 如果命令执行无误，则可以打开浏览器输入设置的站点信息即可打开GitBlit的管理界面。 5.2、通过service启动gitblit服务 新版本Gitblit已经帮我们封装了服务安装脚本，我们只需要执行安装脚本： sh install-service-centos.sh 和服务启动脚本： sh service-centos.sh 即可。如果在执行shell脚本时出现权限问题，只需要给文件增加读写权限即可。如果配置正确的话，则可以打开浏览器输入设置的站点信息即可打开GitBlit的管理界面。 四、出现问题结束进程查询端口占用： netstat -apn | grep 10101 杀进程： kill -9 26105","tags":[]},{"title":"Hbase与Maven工程的Spring配置笔记","date":"2017-03-25T08:17:04.000Z","path":"2017/hbase-maven-spring.html","text":"1、HBase基本操作hbase shell： 连接到正在运行的HBase实例help： 显示一些基本的使用信息以及命令示例。 需要注意的是: 表名, 行, 列都必须使用引号括起来create ‘test’, ‘cf’： 创建一个新表, 必须要指定表明和列族名list ‘test’： 列出 test 表的信息put ‘test’, ‘row1’, ‘cf:a’, ‘value1’ 往表中插入数据，put ‘test’, ‘row2’, ‘cf:b’, ‘value2’ 我们插入了三行数据, 第一行的row key 是 row1, 列是 cf:a, 其值是 value1.HBase 中的列是由列族前缀, 冒号以及列名后缀组成put ‘test’, ‘row3’, ‘cf:c’, ‘value3’scan ‘test’ 一次扫描 HBase 表中的所有数据get ‘test’, ‘row1’ 一次获取一行数据disable ‘test’ 在某些情况下如果你想要删除表或是改变其设置, 需要先禁用表enable ‘test’ 启用表drop ‘test’ 删除表 quit： 退出HBase Shell, 但是 HBase 实例仍然在后台运行stop-hbase.sh bin/start-hbase.sh 脚本可以很方便的启动所有 HBase 守护进程, 同样的, bin/stop-hbase.sh 脚本可以很方便的停止所有 HBase 守护进程jps 来确保 HMaster 和 HRegionServer 进程都已经关闭 2、示例工程配置【pom.xml】自己结合工程： &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;hbase.version&gt;2.5.1&lt;/hbase.version&gt; &lt;spring-data-hadoop.version&gt;2.4.0.RELEASE&lt;/spring-data-hadoop.version&gt; t;!– Hadoop–&gt; org.springframework.data spring-data-hadoop 2.4.0.RELEASElt;dependency&gt; org.apache.hbase hbase-client 1.2.1 网上例子： &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;hbase.version&gt;1.2.2&lt;/hbase.version&gt; &lt;spring-data-hadoop.version&gt;2.4.0.RELEASE&lt;/spring-data-hadoop.version&gt; org.apache.hbase hbase-client ${hbase.version} org.springframework.data spring-data-hadoop ${spring-data-hadoop.version} 【Spring配置文件-直接指定】 web.xml中到applicationContext.xml： contextConfigLocation classpath:applicationContext.xml 创建一个 Spring 配置文件 spring-hbase.xml，在该文件中配置与 HBase 连接相关的信息。直接指定 HDFS 地址以及 ZooKeeper 的地址和端口号。 自己结合工程 写到了applicationContext.xml中，不建立spring-hbase.xml： xmlns:hdp=”http://www.springframework.org/schema/hadoop&quot;xsi:schemaLocation中加：http://www.springframework.org/schema/hadoophttp://www.springframework.org/schema/hadoop/spring-hadoop.xsd &lt;!\\-\\- 配置hbase连接 --&gt; &lt;!\\-\\- HDFS配置 --&gt; &lt;hdp:configuration id=&quot;hadoopConfiguration&quot;&gt;fs.default.name=hdfs://192.168.1.100:9001&lt;/hdp:configuration&gt; &lt;!\\-\\- HBase连接配置 --&gt; &lt;hdp:hbase-configuration id=&quot;hbaseConfiguration&quot; zk-quorum=&quot;192.168.1.101,192.168.1.101,192.168.1.102&quot; zk-port=&quot;2181&quot;/&gt; &lt;!\\-\\- HbaseTemplate Bean配置--&gt; &lt;bean id=&quot;hbaseTemplate&quot; class=&quot;org.springframework.data.hadoop.hbase.HbaseTemplate&quot;&gt; &lt;property name=&quot;configuration&quot; ref=&quot;hbaseConfiguration&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 网上例子： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!-- HDFS配置 –&gt; &lt;hdp:configuration id=”hadoopConfiguration”&gt; fs.defaultFS=”hdfs://localhost:9000” &lt;/hdp:configuration&gt; &lt;!-- HBase连接配置 –&gt; &lt;hdp:hbase-configuration id=”hbaseConfiguration” zk-quorum=”127.0.0.1” zk-port=”2181”/&gt; &lt;!-- HbaseTemplate Bean配置–&gt; 3、测试代码自己结合工程-测试： package com.whut.monitor.hbase.test;import 略; //@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration(locations = “classpath:applicationContext.xml”)public class HBaseTest { private static final String TABLE_NAME = &quot;test&quot;; private static final String ROW_KEY = &quot;row1&quot;; private static final String COLUMN_FAMILY = &quot;cf&quot;; private static final String QUALIFIER = &quot;a&quot;; @Test public void test() { // 加载Spring配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 获取HbaseTemplate HbaseTemplate hbaseTemplate = (HbaseTemplate) applicationContext.getBean(&quot;hbaseTemplate&quot;); // 通过表名和rowKey获取最近一行数据 String result = hbaseTemplate.get(TABLE\\_NAME, ROW\\_KEY, new RowMapper&lt;String&gt;() { public String mapRow(Result result, int rowNum) throws Exception { return Bytes.toString(result.getValue(COLUMN_FAMILY.getBytes(), QUALIFIER.getBytes())); } }); System.out.println(result); // 输出结果是：value1 } } 自己结合工程-IHBaseDao.java中写法： public interface IHBaseDao { String find(String tableName, String key, final String family, final String qualifier);} HBaseDaoImpl.java:package com.whut.monitor.dao.impl;import 略; @Componentpublic class HBaseDaoImpl implements IHBaseDao { @Resource(name=”hbaseTemplate”) private HbaseTemplate hbaseTemplate; @Override public String find(String tableName, String key, final String family, final String qualifier) { String result = hbaseTemplate.get(tableName, key, new RowMapper&lt;String&gt;() { public String mapRow(Result result, int rowNum) throws Exception { return Bytes.toString(result.getValue(family.getBytes(), qualifier.getBytes())); } }); return result; } } 添加数据： public Boolean execute(String tableName, final String key,final String family,final String qualifier,final String value) { return hbaseTemplate.execute(tableName, new TableCallback() { public Boolean doInTable(HTableInterface table) throws Throwable { boolean flag = false; try{ byte[] rowkey = key.getBytes(); Put put = new Put(rowkey); put.add(Bytes.toBytes(family),Bytes.toBytes(qualifier), Bytes.toBytes(value)); table.put(put); flag = true; }catch(Exception e){ e.printStackTrace(); } return flag; } }); System.out.println(“test poi jfz sandeepin”);; return true; } 可以测试了，以上是最简单的调通流程，真正使用得还好翻官方文档，不断深入！","tags":[]},{"title":"CentOS7.0+Hadoop2.7.2+Hbase1.2.1搭建教程","date":"2017-03-23T08:15:11.000Z","path":"2017/centos7-hadoop272-hbase121-step.html","text":"1、软件版本CentOS-7.0-1406-x86_64-DVD.iso jdk-7u80-linux-x64.tar.gz hadoop-2.7.2.tar.gz hbase-1.2.1-bin.tar.gz 2、集群配置主机：Master.Hadoop IP地址：192.168.1.100 主机：Slave1.Hadoop IP地址：192.168.1.101 主机：Slave2.Hadoop IP地址：192.168.1.102 用户设置：系统用了GUI，新版非得建立一个账户。例如随便建一个jfz，密码1，但操作时使用root（密码root）直接进行，装好后重启，以后用SSH进root。 3、配置本地hosts输入指令： nano /etc/hosts 将以下数据复制进入各个主机中： 192.168.1.100 Master.Hadoop 192.168.1.101 Slave1.Hadoop 192.168.1.102 Slave2.Hadoop 使用以下指令在Master主机中进行测试，可使用类似指令在Slave主机测试： ping Master.Hadoop ping Slave1.Hadoop ping Slave2.Hadoop 4、关闭防火墙三台机器均关闭防火墙。 停止firewall： systemctl stop firewalld.service 禁止firewall开机启动： systemctl disable firewalld.service 5、Java安装（1）卸载自带的OpenJDK v1.7： java -version yum remove java-1.7.0-openjdk 重启。 （2） JDK安装： 在/usr下创建java文件夹，将jdk-7u80-linux-x64.tar.gz文件放到这个文件夹中。 使用以下指令进行解压 tar zxvf jdk-7u80-linux-x64.tar.gz 解压后可以删除掉gz文件 rm jdk-7u80-linux-x64.tar.gz 配置JDK环境变量： nano /etc/profile 添加Java环境变量，将以下数据复制到文件底部： export JAVA_HOME=/usr/java/jdk1.7.0_80 export JRE_HOME=/usr/java/jdk1.7.0_80/jre export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin 重载使配置生效： source /etc/profile 验证安装成功： java -version 如果出现对应版本信息，则配置成功：java version “1.7.0_80” 6、SSH免密码登录因为Hadoop需要通过SSH登录到各个节点进行操作，本集群用的是root用户，每台服务器都生成公钥，再合并到authorized_keys。 （1）修改sshd_config配置 CentOS默认没有启动SSH无密登录，去掉/etc/ssh/sshd_config其中2行的注释，每台服务器都要设置。 nano /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes （2）生成key 输入命令： ssh-keygen -t rsa 生成key，都不输入密码，一直回车，/root就会生成。ssh文件夹，每台服务器都要设置。 （3）合并key 合并公钥到authorized_keys文件，在Master服务器，进入/root/.ssh目录，通过SSH命令合并。 cat id_rsa.pub》 authorized_keys ssh root@192.168.1.101 cat ~/.ssh/id_rsa.pub》 authorized_keys ssh root@192.168.1.102 cat ~/.ssh/id_rsa.pub》 authorized_keys （4）拷贝key 把Master服务器的authorized_keys、known_hosts复制到Slave服务器的/root/.ssh目录。 scp authorized_keys known_hosts root@192.168.1.101:/root/.ssh scp authorized_keys known_hosts root@192.168.1.102:/root/.ssh （5）检证免密登陆 ssh root@192.168.1.101 ssh root@192.168.1.102 以后就不需要输入密码了。 7、Hadoop安装流程（1）下载hadoop安装包 将下载“hadoop-2.7.2.tar.gz”文件上传至到/home/hadoop目录下。 注意：一定要在Linux下解压，否则执行权限问题很麻烦。 （2）解压压缩包 tar -xzvf hadoop-2.7.2.tar.gz （3）在/home/hadoop目录下创建目录 创建数据存放的文件夹，tmp、hdfs、hdfs/data、hdfs/name mkdir -p tmp hdfs/name hdfs/data （4）配置core-site.xml 指令： nano /home/hadoop/hadoop-2.7.2/etc/hadoop/core-site.xml 内容： fs.defaultFS hdfs://192.168.1.100:9000 hadoop.tmp.dir file:/home/hadoop/tmp io.file.buffer.size 131702 （5）配置hdfs-site.xml 指令： nano /home/hadoop/hadoop-2.7.2/etc/hadoop/hdfs-site.xml 内容： dfs.namenode.name.dir file:/home/hadoop/hdfs/name dfs.datanode.data.dir file:/home/hadoop/hdfs/data dfs.replication 2 dfs.namenode.secondary.http-address 192.168.1.100:9001 dfs.webhdfs.enabled true （6）配置mapred-site.xml 指令： nano /home/hadoop/hadoop-2.7.2/etc/hadoop/mapred-site.xml 内容： mapreduce.framework.name yarn mapreduce.jobhistory.address 192.168.1.100:10020 mapreduce.jobhistory.webapp.address 192.168.1.100:19888 （7）配置yarn-site.xml 指令： nano /home/hadoop/hadoop-2.7.2/etc/hadoop/yarn-site.xml 内容： yarn.nodemanager.aux-services mapreduce_shuffle yarn.nodemanager.auxservices.mapreduce.shuffle.class org.apache.hadoop.mapred.ShuffleHandler yarn.resourcemanager.address 192.168.1.100:8032 yarn.resourcemanager.scheduler.address 192.168.1.100:8030 yarn.resourcemanager.resource-tracker.address 192.168.1.100:8031 yarn.resourcemanager.admin.address 192.168.1.100:8033 yarn.resourcemanager.webapp.address 192.168.1.100:8088 yarn.nodemanager.resource.memory-mb 2048 注意：yarn.nodemanager.resource.memory-mb值要大于1024，否则影响进程！ （8）配置hadoop-env.sh、yarn-env.sh的JAVA_HOME 配置/home/hadoop/hadoop-2.7.2/etc/hadoop目录下： hadoop-env.sh、yarn-env.sh的JAVA_HOME，不设置的话，启动不了。 export JAVA_HOME=/usr/java/jdk1.7.0_80 （9）配置slaves nano /home/hadoop/hadoop-2.7.2/etc/hadoop/slaves 删除默认的localhost，增加2个从节点： 192.168.1.101 192.168.1.102 （10）传送Hadoop至其它节点 将配置好的Hadoop复制到各个节点对应位置上，通过scp传送： scp -r /home/hadoop 192.168.1.101:/home/ scp -r /home/hadoop 192.168.1.102:/home/ （11）启动Hadoop 在Master服务器启动hadoop，从节点会自动启动。 进入/home/hadoop/hadoop-2.7.2目录，初始化，输入命令： bin/hdfs namenode -format 全部启动： sbin/start-all.sh 也可以分开启动sbin/start-dfs.sh、sbin/start-yarn.sh。 Hadoop环境变量配置，需要在/etc/profile 中添加HADOOP_HOME内容，之前已经配置过，所以这一步已经节省下来，那么可重启 source /etc/profile。 （12）验证Hadoop jps运行成功结果： 8、Hbase安装流程（1）复制安装包至Master节点/home/hbase目录下 通过SFTP或是直接拷贝至Master节点，软件推荐在Linux下解压！ （2）解压压缩包 tar zxvf hbase-1.2.1-bin.tar.gz （3）添加到环境变量 将hbase添加到环境变量/etc/profile中，配环境变量方便使用指令： nano /etc/profile 内容： export HBASE_HOME=/home/hbase/hbase-1.2.1 export PATH=$HBASE_HOME/bin:$PATH export HBASE_MANAGES_ZK=true export HBASE_CLASSPATH=/home/hbase/hbase-1.2.1/conf （4）修改配置文件hbase-env.sh nano /home/hbase/hbase-1.2.1/conf/hbase-env.sh 内容： export JAVA_HOME=/usr/java/jdk1.7.0_80 （5）修改配置文件hbase-site.xml hbase.rootdir hdfs://192.168.1.100:9000/hbase hbase.cluster.distributed true hbase.zookeeper.quorum Master.Hadoop,Slave1.Hadoop,Slave2.Hadoop hbase.temp.dir /home/hbase/hbase-1.2.1/tmp hbase.zookeeper.property.dataDir /home/hbase/hbase-1.2.1/tmp/zookeeper hbase.master.info.port 60010 （6）修改配置文件regionservers： nano regionservers 将文件内容设置为： Master.Hadoop Slave1.Hadoop Slave2.Hadoop （7）Hbase复制到从节点 差不多要成功了，别忘了最后一步！ scp -r /home/hbase/hbase-1.2.1 root@192.168.1.101:/home/hbase/ scp -r /home/hbase/hbase-1.2.1 root@192.168.1.102:/home/hbase/ （8）验证Hbase 1、用jps命令看进程对不对。 2、测试Web访问 http://Master.Hadoop:8088/ http://Master.Hadoop:50070/ http://Master.Hadoop:60010/","tags":[]},{"title":"利用Python进行博客图片压缩","date":"2017-03-09T12:45:24.000Z","path":"2017/python-blog-img.html","text":"自己写博客的时候常常要插入一些手机拍的照片，都是几M的大小，每张手动压缩太费事了，于是根据自己博客的排版特点用Python写了一个简单的图片压缩脚本，功能是将博客图片生成缩略图，横屏的图片压缩为宽度最大1280像素，竖屏的图片压缩为宽度最大1000像素。 代码如下： #!/usr/bin/env python3# coding=utf-8‘ 蒋方正Python函数库 ‘__author__ = ‘Sandeepin’ import mathimport osfrom PIL import Image # 功能：博客图片生成缩略图，1280横屏压缩，1000竖屏压缩# 参数：图片名称# 返回：OK，保存同名文件在thumb目录下def JfzBlogImgThumb(ImgName): im = Image.open(ImgName) print(‘格式’,im.format, ‘，分辨率’,im.size, ‘，色彩’,im.mode) if max(im.size[0], im.size[1]) &gt; 1000: if im.size[0] &gt; im.size[1]: im.thumbnail((1280, 1280)) else: im.thumbnail((1000, 1000)) if ImgName.endswith(‘.JPG’): ImgName = ImgName.replace(‘.JPG’,’.jpg’) if ImgName.endswith(‘.png’): ImgName = ImgName.replace(‘.png’,’.jpg’) if ImgName.endswith(‘.PNG’): ImgName = ImgName.replace(‘.PNG’,’.jpg’) im.save(‘thumb\\\\’+ImgName, ‘JPEG’, quality=90) #if max(im.size\\[0\\], im.size\\[1\\]) &lt;= 1000: # im.save(&apos;thumb\\\\\\&apos;+ImgName, &apos;JPEG&apos;, quality=100) return &apos;OK&apos; # JfzBlogImgThumb(‘1.jpg’)# JfzBlogImgThumb(‘2.jpg’) # 列出当前目录所有jpg文件lst=os.listdir(os.getcwd())imgname = [c for c in lst if os.path.isfile(c) and (c.endswith(‘.jpg’) or c.endswith(‘.JPG’) or c.endswith(‘.png’) or c.endswith(‘.PNG’))]print(imgname) # 全处理OutCheck = map(JfzBlogImgThumb,imgname)print(list(OutCheck))","tags":[]},{"title":"Qt下Armadillo矩阵函数库的添加","date":"2017-03-08T12:42:44.000Z","path":"2017/qt-armadillo.html","text":"其实本文严格说只能算VS2013添加Armadillo教程，因为为了省事，用的是VS2013编译器版本的Qt，Armadillo也直接用了自带例子中的blas_win64_MT.dll、blas_win64_MT.lib、lapack_win64_MT.dll、lapack_win64_MT.lib，没有完整编译Armadillo，仅是调用举例。 版本信息： qt-opensource-windows-x86-msvc2013_64-5.8.0.exe、Armadillo v7.500.2、VS2013 第1步：下载一个Armadillo文件包，在官网下即可： http://arma.sourceforge.net/download.html 第2步：用Qt随便建一个Console工程，在.pro下添加如下代码，路径就是解压Armadillo的那个路径： INCLUDEPATH+= D:/Library/Armadillo/include \\ LIBS += D:\\Library\\Armadillo\\examples\\lib_win64\\blas_win64_MT.lib\\ D:\\Library\\Armadillo\\examples\\lib_win64\\lapack_win64_MT.lib\\ 第3步：cpp文件中添加（例子代码直接用Armadillo自带的）： #include #include #include using namespace std;using namespace arma; // Armadillo在线文档在这里:// http://arma.sourceforge.net/docs.html int main(int argc, char *argv[]){ QCoreApplication a(argc, argv); // 【0】Armadillo版本 cout &lt;&lt; &quot;Armadillo 版本: &quot; &lt;&lt; arma\\_version::as\\_string() &lt;&lt; endl; // 【1】矩阵初始化 mat A(2,3); // 直接指定矩阵大小(元素未初始化) cout &lt;&lt; &quot;A的行数: &quot; &lt;&lt; A.n_rows &lt;&lt; endl; // 行、列值只读 cout &lt;&lt; &quot;A的列数: &quot; &lt;&lt; A.n_cols &lt;&lt; endl; // 【2】矩阵赋值 A(1,2) = 456.0; // 直接访问一个元素(索引从0开始) A.print(&quot;直接访问一个元素A(1,2) = 456.0;A:&quot;); A = 5.0; // 标量被当作一个 1x1 的矩阵 A.print(&quot;标量被当作一个 1x1 的矩阵A = 5.0;A:&quot;); A.set_size(4,5); // 改变矩阵尺寸(数据不保存) A.fill(5.0); // 所有元素设置为一个特定的值 A.print(&quot;所有元素设置为一个特定的值A.fill(5.0); A:&quot;); // endr表示“行”的终结 A &lt;&lt; 0.165300 &lt;&lt; 0.454037 &lt;&lt; 0.995795 &lt;&lt; 0.124098 &lt;&lt; 0.047084 &lt;&lt; endr &lt;&lt; 0.688782 &lt;&lt; 0.036549 &lt;&lt; 0.552848 &lt;&lt; 0.937664 &lt;&lt; 0.866401 &lt;&lt; endr &lt;&lt; 0.348740 &lt;&lt; 0.479388 &lt;&lt; 0.506228 &lt;&lt; 0.145673 &lt;&lt; 0.491547 &lt;&lt; endr &lt;&lt; 0.148678 &lt;&lt; 0.682258 &lt;&lt; 0.571154 &lt;&lt; 0.874724 &lt;&lt; 0.444632 &lt;&lt; endr &lt;&lt; 0.245726 &lt;&lt; 0.595218 &lt;&lt; 0.409327 &lt;&lt; 0.367827 &lt;&lt; 0.385736 &lt;&lt; endr; A.print(&quot;用endr每行赋值A:&quot;); // 【3】矩阵存取 // 将矩阵保存为一个文本文件 A.save(&quot;A.txt&quot;, raw_ascii); // 从文件载入矩阵 mat B; B.load(&quot;A.txt&quot;); // 【4】取子矩阵 cout &lt;&lt; &quot;子矩阵(指定左上角和右下角)B( span(0,2), span(3,4) ):&quot; &lt;&lt; endl &lt;&lt; B( span(0,2), span(3,4) ) &lt;&lt; endl; cout &lt;&lt; &quot;子矩阵(指定左上角和大小)B( 0,3, size(3,2) ):&quot; &lt;&lt; endl &lt;&lt; B( 0,3, size(3,2) ) &lt;&lt; endl; cout &lt;&lt; &quot;取一行B.row(0): &quot; &lt;&lt; endl &lt;&lt; B.row(0) &lt;&lt; endl; cout &lt;&lt; &quot;取一列B.col(1): &quot; &lt;&lt; endl &lt;&lt; B.col(1) &lt;&lt; endl; // 【5】矩阵基本运算 // 行列式 cout &lt;&lt; &quot;行列式det(A): &quot; &lt;&lt; det(A) &lt;&lt; endl; // 矩阵的逆 cout &lt;&lt; &quot;矩阵的逆inv(A): &quot; &lt;&lt; endl &lt;&lt; inv(A) &lt;&lt; endl; // 转置 cout &lt;&lt; &quot;转置B.t(): &quot; &lt;&lt; endl &lt;&lt; B.t() &lt;&lt; endl; // 每一列的最大值(遍历行) cout &lt;&lt; &quot;每一列的最大值max(B): &quot; &lt;&lt; endl &lt;&lt; max(B) &lt;&lt; endl; // 每一行的最大值(遍历列) cout &lt;&lt; &quot;每一行的最大值max(B,1): &quot; &lt;&lt; endl &lt;&lt; max(B,1) &lt;&lt; endl; // 矩阵的最大值 cout &lt;&lt; &quot;矩阵的最大值max(max(B)) = &quot; &lt;&lt; max(max(B)) &lt;&lt; endl; // 每一列的总和(遍历行) cout &lt;&lt; &quot;每一列的总和sum(B): &quot; &lt;&lt; endl &lt;&lt; sum(B) &lt;&lt; endl; // 每一行的总和(遍历列) cout &lt;&lt; &quot;每一行的总和sum(B,1) =&quot; &lt;&lt; endl &lt;&lt; sum(B,1) &lt;&lt; endl; // 所有元素的和 cout &lt;&lt; &quot;所有元素的和accu(B): &quot; &lt;&lt; accu(B) &lt;&lt; endl; // 矩阵的迹 = 对角线的值之和 cout &lt;&lt; &quot;矩阵的迹trace(B): &quot; &lt;&lt; trace(B) &lt;&lt; endl; // 单位矩阵 mat C = eye&lt;mat&gt;(4,4); C.print(&quot;单位矩阵C:&quot;); // 值均匀分布于\\[0,1\\]之间的随机矩阵 mat D = randu&lt;mat&gt;(4,4); D.print(&quot;随机矩阵D:&quot;); // 行向量当作一个矩阵的一行 rowvec r; r &lt;&lt; 0.59119 &lt;&lt; 0.77321 &lt;&lt; 0.60275 &lt;&lt; 0.35887 &lt;&lt; 0.51683; r.print(&quot;行向量当作一个矩阵的一行r:&quot;); // 列向量当作一个矩阵的一列 vec q; q &lt;&lt; 0.14333 &lt;&lt; 0.59478 &lt;&lt; 0.14481 &lt;&lt; 0.58558 &lt;&lt; 0.60809; q.print(&quot;列向量当作一个矩阵的一列q:&quot;); // 矩阵转换为向量,矩阵中的数据一行一行依次排到向量中 vec v = vectorise(A); v.print(&quot;矩阵转换为向量v:&quot;); // 内积(点积)-矩阵乘法 cout &lt;&lt; &quot;内积(点积)as\\_scalar(r\\*q): &quot; &lt;&lt; as\\_scalar(r\\*q) &lt;&lt; endl; // 外积(叉积)-笛卡尔积 cout &lt;&lt; &quot;外积(叉积)q\\*r: &quot; &lt;&lt; endl &lt;&lt; q\\*r &lt;&lt; endl; // 乘法和累加运算 (不创建临时矩阵) (A % B 等效 A .* B，最后累加) cout &lt;&lt; &quot;accu(A % B) = &quot; &lt;&lt; accu(A % B) &lt;&lt; endl; // 【6】例子和其它 // 一个复合操作的例子 B += 2.0 * A.t(); B.print(&quot;B:&quot;); // imat指定一个整数矩阵 imat AA; imat BB; AA &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; endr &lt;&lt; 4 &lt;&lt; 5 &lt;&lt; 6 &lt;&lt; endr &lt;&lt; 7 &lt;&lt; 8 &lt;&lt; 9; BB &lt;&lt; 3 &lt;&lt; 2 &lt;&lt; 1 &lt;&lt; endr &lt;&lt; 6 &lt;&lt; 5 &lt;&lt; 4 &lt;&lt; endr &lt;&lt; 9 &lt;&lt; 8 &lt;&lt; 7; // 矩阵比较 (每个元素比较); 输出一个关系算子umat umat ZZ = (AA &gt;= BB); ZZ.print(&quot;矩阵比较结果ZZ:&quot;); // 【7】三维矩阵 cube Q( B.n\\_rows, B.n\\_cols, 2 ); Q.slice(0) = B; Q.slice(1) = 2.0 * B; Q.print(&quot;三维矩阵Q:&quot;); // 【8】场 // 矩阵的2D场，3D场也支持 field&lt;mat&gt; F(4,3); for(uword col=0; col &lt; F.n_cols; ++col) for(uword row=0; row &lt; F.n_rows; ++row) { F(row,col) = randu&lt;mat&gt;(2,3); // field&lt;mat&gt;的每一个元素是一个矩阵 } F.print(&quot;场F:&quot;); system(&quot;pause&quot;); return a.exec(); } 第4步：先清除，执行qmake一下，构建，运行。 第5步：已经成功了！","tags":[]},{"title":"Qt下Eigen矩阵函数库的添加","date":"2017-03-05T12:39:39.000Z","path":"2017/qt-eigen.html","text":"第1步：下载一个Eigen文件包，在官网下即可： http://eigen.tuxfamily.org/ 第2步：用Qt随便建一个GUI工程，在.pro下添加如下代码，路径就是解压Eigen的那个路径： INCLUDEPATH+=D:\\Library\\Eigen\\Eigen 第3步：cpp文件中添加： // Qt下Eigen矩阵函数库的添加 #include #include主函数内部添加： Eigen::MatrixXd aaa(2,3); aaa&lt;&lt;1,2,4, 8,16,32; std::cout&lt;&lt;aaa&lt;&lt;std::endl; 第4步：先清除，执行qmake一下，构建，运行。 第5步：已经成功了！","tags":[]},{"title":"OpenCV2.4.13+VS2013配置方法","date":"2017-03-02T12:38:33.000Z","path":"2017/opencv2-4-13-vs2013.html","text":"VC版本编号： 先说一下VC几代表的对应版本： vc8 = Visual Studio 2005 vc9 = Visual Studio 2008 vc10 = Visual Studio 2010 vc11 = Visual Studio 2012 vc12 = Visual Studio 2013 vc14 = Visual Studio 2015 本文重点讲OpenCV2.4.13 配 VS2013，因为OpenCV2没3坑多，VS2013又智能又兼容老旧工程： 环境变量： D:\\Soft\\OpenCV2\\build\\x86\\vc12\\bin; 包含目录： D盘版本：D:\\Soft\\OpenCV2\\build\\include;D:\\Soft\\OpenCV2\\build\\include\\opencv;D:\\Soft\\OpenCV2\\build\\include\\opencv2; C盘版本：C:\\Soft\\OpenCV2\\build\\include;C:\\Soft\\OpenCV2\\build\\include\\opencv;C:\\Soft\\OpenCV2\\build\\include\\opencv2; 库目录： D盘版本：D:\\Soft\\OpenCV2\\build\\x86\\vc12\\lib;D:\\Soft\\OpenCV2\\build\\x86\\vc12\\staticlib; C盘版本：C:\\Soft\\OpenCV2\\build\\x86\\vc12\\lib;C:\\Soft\\OpenCV2\\build\\x86\\vc12\\staticlib; 链接器-&gt;输入-&gt;附加依赖项(Release)： opencv_objdetect2413.lib opencv_ts2413.lib opencv_video2413.lib opencv_nonfree2413.lib opencv_ocl2413.lib opencv_photo2413.lib opencv_stitching2413.lib opencv_superres2413.lib opencv_videostab2413.lib opencv_calib3d2413.lib opencv_contrib2413.lib opencv_core2413.lib opencv_features2d2413.lib opencv_flann2413.lib opencv_gpu2413.lib opencv_highgui2413.lib opencv_imgproc2413.lib opencv_legacy2413.lib opencv_ml2413.lib 链接器-&gt;输入-&gt;附加依赖项(Debug)： opencv_ml2413d.lib opencv_calib3d2413d.lib opencv_contrib2413d.lib opencv_core2413d.lib opencv_features2d2413d.lib opencv_flann2413d.lib opencv_gpu2413d.lib opencv_highgui2413d.lib opencv_imgproc2413d.lib opencv_legacy2413d.lib opencv_objdetect2413d.lib opencv_ts2413d.lib opencv_video2413d.lib opencv_nonfree2413d.lib opencv_ocl2413d.lib opencv_photo2413d.lib opencv_stitching2413d.lib opencv_superres2413d.lib opencv_videostab2413d.lib","tags":[]},{"title":"OpenCV2.4.13+Qt5.6.2配置方法","date":"2017-03-01T12:34:49.000Z","path":"2017/opencv2-4-13-qt5-6-2.html","text":"1、环境变量D:\\Soft\\OpenCV2\\MinGW_build\\bin; C:\\Qt\\Qt5.6.2\\Tools\\mingw492_32\\bin; D:\\Soft\\Programming\\CMake3.7.0\\bin; 2、OpenCV2.4.13的MinGW_build版本位置D:\\Soft\\OpenCV2\\MinGW_build\\ 3、Qt5.6.2位置C:\\Qt\\Qt5.6.2\\ 4、Qt的pro文件写法QT += coreQT -= gui INCLUDEPATH+= D:/Soft/OpenCV2/build/include\\ D:/Soft/OpenCV2/build/include/opencv\\ D:/Soft/OpenCV2/build/include/opencv2 LIBS += D:\\Soft\\OpenCV2\\MinGW_build\\lib\\libopencv_core2413.dll.a\\ D:\\Soft\\OpenCV2\\MinGW_build\\lib\\libopencv_highgui2413.dll.a\\ D:\\Soft\\OpenCV2\\MinGW_build\\lib\\libopencv_imgproc2413.dll.a TARGET = JfzOpenCVCONFIG += consoleCONFIG -= app_bundle TEMPLATE = app SOURCES += main.cpp 5、Qt的main.cpp函数写法#include&lt;opencv2/opencv.hpp&gt; #include”opencv/cv.h” #include”opencv/cxcore.h” #include”opencv/highgui.h” using namespace cv;int main(){ //OpenCV2代码测试 Mat image=imread(“D:\\\\1.png”); //载入图片 namedWindow(“OpenCV2代码测试”); //创建窗口 imshow(“OpenCV2代码测试”,image); //显示图像 imwrite(“FuckPOI2.png”,image); //保存图像 //OpenCV1代码测试 IplImage *pImg; //声明IplImage指针 pImg = cvLoadImage(&quot;D:\\\\\\1.png&quot;, 0); //载入图片 cvNamedWindow(&quot;OpenCV1代码测试&quot;,1); //创建窗口 cvShowImage(&quot;OpenCV1代码测试&quot;,pImg); //显示图像 cvSaveImage(&quot;FuckPOI1.jpg&quot;,pImg); //保存图像 cvWaitKey(0); //等待按键 cvDestroyWindow(&quot;Image&quot;); //销毁窗口 cvReleaseImage(&amp;pImg); //释放图像 waitKey(0); }","tags":[]},{"title":"异想家Win10系统安装的软件与配置","date":"2017-02-16T12:32:07.000Z","path":"2017/sandeepin-win10-soft.html","text":"1、C盘推荐一个硬盘，256G，安装好驱动，显卡配置好高性能，激活Win10，屏蔽Win10驱动更新，改电脑名称为Sandeepin-PC。QHCPT-N6P3F-8WTP2-R277X-XKXTT 2、安装我的个性字体、韩语字体。时间同步：开始-&gt;运行-&gt;CMD(管理员)： Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 3、桌面图标：此电脑、我的文档、回收站。桌面、下载、文档移到D盘。 4、显示器分辨率设置、盘符设置。 5、使用【一分钟解决英文字体模糊，对话框拉长变马脸】，再替换字体。 6、文件夹选项——打开文件资源管理器时打开“此电脑”；“隐私”选项都去掉。 7、关闭Windows Defender、防火墙： 运行——gpedit.msc——计算机配置——管理模板——Windows组件——Windows Defender——关闭Windows Defender。 【不关服务中的Windows防火墙(Firewall)，否则问题多多。】 把“索引服务”禁用(即关闭Windows Search服务)。 8、关闭Windows安全机制： Win键+R–运行gpedit.msc； 用户配置–管理模版–Windows组件–附件管理器； 文件类型的默认风险级别，设置为“启用”，选择“低风险”； 低风险文件类型的包含列表，设置为“启用”，扩展名增加比如：.exe;.rar;.zip;.7z； 文件附件值中不保留区域信息，设置为“启用”。 9、关闭所有维护消息(通知和操作——不获取通知)、关闭任务栏搜索框、小娜等。 10、删除Metro应用：以管理员身份运行Powershell Get-AppxPackage -AllUsers | Remove-AppxPackage 找回应用商店、计算器：WindowsApps增加Everyone的权限 add-appxpackage -register “C:\\Program Files\\WindowsApps\\Microsoft.WindowsStore_11606.1001.39.0_x64__8wekyb3d8bbwe\\AppxManifest.xml” -disabledevelopmentmode add-appxpackage -register “C:\\Program Files\\WindowsApps\\Microsoft.WindowsCalculator_10.1605.1582.0_x64__8wekyb3d8bbwe\\AppxManifest.xml” -disabledevelopmentmode 11、修复Win10图片查看器：执行【修复Win10图片查看器.reg】。 12、安装.NET Framework 3.5： 12.1、Win+X（或者鼠标右键点击屏幕左下角处）选择命令提示符（管理员模式）。 12.2、输入如下命令： DISM /Online /Enable-Feature /FeatureName:NetFx3 /All /LimitAccess /Source:E:\\Win10安装\\【03、Framework3.5】 13、关闭磁盘碎片整理： 开始——管理工具——磁盘碎片整理程序——配置计划——去掉“按计划运行”。 14、偏好设置： 显示星期(yyyy/M/d dddd)； 个人头像设置； 删除不要的输入法； 任务管理器调节大小、窗口默认最大化、画图默认缩小； 系统最佳外观、系统还原关闭、屏幕30分钟黑； IP固定192.168.1.200； 显示隐藏文件和后缀名、操作中心各种提示消息全部关掉。 15、系统相关必备组件： Flash、.NET v3.5(已经装了)、JDK、VC运行库 16、最基础软件： WinRAR(默认配置：最大压缩、密码) PDF-XChange Viewer 手心输入法(或搜狗输入法)、导入配置词库 XnView Shell Extension(右键看图) NetSpeedMonitor(网速显示) QQ软件管理 输入法切换快捷键修改：控制面板\\时钟、语言和区域\\语言\\高级设置 更改热键 切换键盘布局，不设置 17、WPS、Microsoft Office、Visio、MathType等办公软件。 18、设置、注册绿色软件： 设置右键：Everything、FileMenu Tools安装配置(高级重命名大小调整，导入配置) 配置注册：去广告软件(阿呆喵、adbyby等选择)、Notepad2、EverEdit(关联文件类型、右键打开)、排版助手、Flash播放器、虚拟光驱、WinSnap、Image Optimizer(设置中文)、SPX Instant Screen Capture注册、SolveigMM Video Splitter注册 放开始菜单：Notepad2、EverEdit、计算器、画图、Winsnap、WPS、Office、Visio、MathType 19、Potplayer、千千静听、网易云音 20、迅雷(设置下载文件到：我的文档-下载)、迅雷快鸟 21、腾讯QQ(文件保存在我的文档) 22、魔方优化 23、文件关联、浏览器放在任务栏 24、桌面图标： 腾讯QQ、迅雷、Visual Studio 2013、Qt Creator、Keil uVision4、Spyder、PortHelper、远程桌面连接、Virtual Serial Port、MATLAB等，根据需求摆放。 弄好备份一次系统(基础)！ 25、安装编程、同步等生活工作软件： 同步工具：坚果云、百度云 编程环境：MinGW、OpenCV、Qt、Matlab、Java、Boost、Python(Anaconda)…… IDE：Visual Studio 2013、Qt Creator、Keil uVision4、Spyder、PyCharm …… 26、部分环境变量设置： JAVA_HOME中加入：C:\\Program Files (x86)\\Java\\jdk1.8.0_112\\ classpath中加入：.;%JAVA_HOME%lib\\dt.jar;%JAVA_HOME%lib\\toos.jar;%JAVA_HOME%jre\\lib\\rt.jar; Path中加入： ;%JAVA_HOME%bin; D:\\Library\\OpenCV2\\MinGW_build\\bin; D:\\Library\\OpenCV2\\build\\x86\\vc12\\bin; D:\\Library\\Boost; D:\\Library\\Boost\\stage\\lib; C:\\Qt\\Qt5.6.2\\Tools\\mingw492_32\\bin; C:\\Qt\\Qt5.6.2\\5.6\\mingw49_32\\bin; C:\\Qt\\Qt5.6.2\\Tools\\mingw492_32\\i686-w64-mingw32\\bin; D:\\Soft\\Matlab\\bin; D:\\Soft\\Matlab\\runtime\\win64; D:\\Soft\\Matlab\\polyspace\\bin; C:\\ProgramData\\Anaconda3; C:\\ProgramData\\Anaconda3\\Scripts; C:\\ProgramData\\Anaconda3\\Library\\bin; 运行常见软件进行测试，弄好后备份一次系统(完整)！ 27、VMware Workstation 28、【应用商店软件推荐】 贴吧极速版Beta 不要直接下应用商店里的贴吧！ QQ 手机淘宝 UWP UWP播放器/ACG播放器 vlc for windowsphone IT之家UWP 网易云音乐 Office全家桶 微软必应词典 CanKnockDown3 游戏 B站 换成winsows 神一般的软件 美团 微信","tags":[]},{"title":"异想家Win7系统安装的软件与配置","date":"2017-02-11T12:29:46.000Z","path":"2017/sandeepin-win7-soft.html","text":"C盘推荐一个硬盘，256G以上，安装好驱动，激活Win7，备份一次系统(纯净)！ 1、Mac、Linux时间同步(双系统时配置)： 开始-&gt;运行-&gt;CMD，打开命令行程序(以管理员方式打开命令行)，在命令行中输入下面命令并回车： Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 2、自己喜欢的字体安装。 3、关闭磁盘碎片整理： 开始——所有程序——附件——系统工具——磁盘碎片整理程序——配置计划-去掉“按计划运行”的对号，或者更改设置。 4、把“索引服务”禁用(即关闭Windows Search服务)、系统不更新、防火墙关。 5、关闭Windows安全机制： Win键+R——运行gpedit.msc； 用户配置——管理模版——Windows组件——附件管理器； 文件类型的默认风险级别，设置为“启用”，选择“低风险”； 低风险文件类型的包含列表，设置为“启用”，扩展名增加比如：.exe;.rar;.zip;.7z； 文件附件值中不保留区域信息，设置为“启用”。 6、偏好设置： 显示星期(yyyy/M/d dddd)； 桌面放“计算机”“我的文档”“回收站”； 开始菜单隐私保护、开始菜单文件夹链接及图标摆放； 个人头像设置； 删除不要的输入法； 任务管理器调节大小、窗口默认最大化、画图默认缩小； 系统最佳外观、系统还原关闭、屏幕30分钟黑； IP固定192.168.1.200； 显示隐藏文件和后缀名、操作中心各种提示消息全部关掉。 7、系统相关必备组件： Win7摄像头、Flash插件(IE、第三方)、NET.Framework、Java JDK、VC运行库、DirectX、IE浏览器升级 8、最基础软件： WinRAR(默认配置：最大压缩、密码) PDF-XChange Viewer (PXP40-4O031-1514Y-KRJM6-6A6E8-6WLE2) 手心输入法(或搜狗输入法)、导入配置词库 XnView Shell Extension(右键看图) NetSpeedMonitor(网速显示) QQ软件管理 9、WPS、Microsoft Office、Visio、MathType等办公软件。 10、设置、注册绿色软件： 设置右键：Everything、FileMenu Tools安装配置(高级重命名大小调整，导入配置) 配置注册：去广告软件(阿呆喵、adbyby等选择)、Notepad2、EverEdit(关联文件类型)、排版助手、Flash播放器、虚拟光驱、WinSnap、Image Optimizer(设置中文)、SPX Instant Screen Capture注册、SolveigMM Video Splitter注册 放开始菜单：Notepad2、EverEdit、计算器、画图、Winsnap、WPS、Office、Visio、MathType 11、Potplayer、千千静听、网易云音乐 12、迅雷(设置下载文件到：我的文档-下载)、迅雷快鸟 13、腾讯QQ(文件保存在安装目录) 14、魔方优化、扁平化主题、破解主题文件 15、文件关联、浏览器放在任务栏 16、桌面图标： 腾讯QQ、迅雷、Visual Studio 2013、Qt Creator、Keil uVision4、Spyder、PortHelper、远程桌面连接、Virtual Serial Port、MATLAB等，根据需求摆放。 弄好备份一次系统(基础)！ 17、安装编程、同步等生活工作软件： 同步工具：坚果云、百度云 编程环境：MinGW、OpenCV、Qt、Matlab、Java、Boost、Python(Anaconda)…… IDE：Visual Studio 2013、Qt Creator、Keil uVision4、Spyder、PyCharm …… 18、部分环境变量设置： JAVA_HOME中加入：C:\\Program Files (x86)\\Java\\jdk1.8.0_112\\ classpath中加入：.;%JAVA_HOME%lib\\dt.jar;%JAVA_HOME%lib\\toos.jar;%JAVA_HOME%jre\\lib\\rt.jar; Path中加入： ;%JAVA_HOME%bin; D:\\Library\\OpenCV2\\MinGW_build\\bin; D:\\Library\\OpenCV2\\build\\x86\\vc12\\bin; D:\\Library\\Boost; D:\\Library\\Boost\\stage\\lib; C:\\Qt\\Qt5.6.2\\Tools\\mingw492_32\\bin; C:\\Qt\\Qt5.6.2\\5.6\\mingw49_32\\bin; C:\\Qt\\Qt5.6.2\\Tools\\mingw492_32\\i686-w64-mingw32\\bin; D:\\Soft\\Matlab\\bin; D:\\Soft\\Matlab\\runtime\\win64; D:\\Soft\\Matlab\\polyspace\\bin; C:\\ProgramData\\Anaconda3; C:\\ProgramData\\Anaconda3\\Scripts; C:\\ProgramData\\Anaconda3\\Library\\bin; 运行常见软件测试，弄好后备份一次系统(完整)！","tags":[]},{"title":"Qt常用UI控件读取、写入方法","date":"2017-01-16T12:25:24.000Z","path":"2017/qt-e5-b8-b8-e7-94-a8ui-e6-8e-a7-e4-bb-b6-e8-af-bb-e5-8f-96-e3-80-81-e5-86-99-e5-85-a5-e6-96-b9-e6-b3-95.html","text":"本文用途：快速备忘，方便调用，写熟了自然就记下了。 【1、标签label】 读取：ui-&gt;label-&gt;text() 写入：ui-&gt;label-&gt;setText(“poi”) 【2、单行文本框lineEdit】 读取：ui-&gt;lineEdit-&gt;text() 写入：ui-&gt;lineEdit-&gt;setText(“poi”) 【3、单行文本框textEdit】 读取(文本)：ui-&gt;textEdit-&gt;toPlainText() 读取(富文本)：ui-&gt;textedit-&gt;toHtml() 写入：ui-&gt;textEdit-&gt;setText(“poi”) 追加：ui-&gt;textEdit-&gt;append(“jfz”) 【4、spinBox】 读取：ui-&gt;spinBox-&gt;text() 【5、doubleSpinBox】 读取：ui-&gt;doubleSpinBox-&gt;text() 【6、comboBox】 读取：ui-&gt;comboBox-&gt;currentText() 【7、radioButton】 读取：ui-&gt;radioButton-&gt;isChecked() 【8、checkBox】 读取：checkBox-&gt;checkState() == Qt::Checked","tags":[]},{"title":"完美实现STM32单总线挂多个DS18B20","date":"2016-12-14T12:24:31.000Z","path":"2016/stm32-ds18b20s.html","text":"一般常见的STM32的关于DS18B20的例程都是检测一个传感器，代码一般都是跳过ROM检测，直接获取温度值。这种写法并不适用于单总线上挂载多个DS18B20的情况，Sandeepin的这个代码就是针对这种情况完善的单总线挂多个DS18B20检测，实现获取每个DS18B20的ID和温度。 主要的DS18B20时序代码没变，增加了搜索ROM函数，获取温度时先匹配ID。 核心代码如下： DS18B20.c文件代码： #include “DS18B20.h” #include “Delay.h” #include “stdio.h” // printf用 #define DS18B20_GPIO_NUM GPIO_Pin_5 #define DS18B20_GPIO_X GPIOC #define RCC_APB2Periph_DS18B20_GPIO_X RCC_APB2Periph_GPIOC #define DS18B20_DQ_OUT_Low GPIO_ResetBits(DS18B20_GPIO_X,DS18B20_GPIO_NUM) #define DS18B20_DQ_OUT_High GPIO_SetBits(DS18B20_GPIO_X,DS18B20_GPIO_NUM) #define DS18B20_DQ_IN GPIO_ReadInputDataBit(DS18B20_GPIO_X,DS18B20_GPIO_NUM) #define MaxSensorNum 8unsigned char DS18B20_ID[MaxSensorNum][8]; // 存检测到的传感器DS18B20_ID的数组,前面的维数代表单根线传感器数量上限unsigned char DS18B20_SensorNum; // 检测到的传感器数量(从1开始，例如显示1代表1个，8代表8个) // 配置DS18B20用到的I/O口void DS18B20_GPIO_Config(void){ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_DS18B20_GPIO_X, ENABLE); GPIO_InitStructure.GPIO_Pin = DS18B20_GPIO_NUM; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(DS18B20_GPIO_X, &amp;GPIO_InitStructure); GPIO_SetBits(DS18B20_GPIO_X, DS18B20_GPIO_NUM);} // 引脚输入void DS18B20_Mode_IPU(void){ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = DS18B20_GPIO_NUM; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(DS18B20_GPIO_X, &amp;GPIO_InitStructure);} // 引脚输出void DS18B20_Mode_Out(void){ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = DS18B20_GPIO_NUM; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(DS18B20_GPIO_X, &amp;GPIO_InitStructure); } // 复位，主机给从机发送复位脉冲void DS18B20_Rst(void){ DS18B20_Mode_Out(); DS18B20_DQ_OUT_Low; // 产生至少480us的低电平复位信号 Delay_us(480); DS18B20_DQ_OUT_High; // 在产生复位信号后，需将总线拉高 Delay_us(15);} // 检测从机给主机返回的应答脉冲。从机接收到主机的复位信号后，会在15~60us后给主机发一个应答脉冲u8 DS18B20_Answer_Check(void){ u8 delay = 0; DS18B20_Mode_IPU(); // 主机设置为上拉输入 // 等待应答脉冲（一个60~240us的低电平信号 ）的到来 // 如果100us内，没有应答脉冲，退出函数，注意：从机接收到主机的复位信号后，会在15~60us后给主机发一个存在脉冲 while (DS18B20_DQ_IN&amp;&amp;delay &lt; 100) { delay++; Delay_us(1); } // 经过100us后，如果没有应答脉冲，退出函数 if (delay &gt;= 100)//Hu200 return 1; else delay = 0; // 有应答脉冲，且存在时间不超过240us while (!DS18B20_DQ_IN&amp;&amp;delay &lt; 240) { delay++; Delay_us(1); } if (delay &gt;= 240) return 1; return 0;} // 从DS18B20读取1个位u8 DS18B20_Read_Bit(void){ u8 data; DS18B20_Mode_Out(); DS18B20_DQ_OUT_Low; // 读时间的起始：必须由主机产生 &gt;1us &lt;15us 的低电平信号 Delay_us(2); DS18B20_DQ_OUT_High; Delay_us(12); DS18B20_Mode_IPU();// 设置成输入，释放总线，由外部上拉电阻将总线拉高 if (DS18B20_DQ_IN) data = 1; else data = 0; Delay_us(50); return data;} // 从DS18B20读取2个位u8 DS18B20_Read_2Bit(void)//读二位 子程序{ u8 i; u8 dat = 0; for (i = 2; i &gt; 0; i–) { dat = dat &lt;&lt; 1; DS18B20_Mode_Out(); DS18B20_DQ_OUT_Low; Delay_us(2); DS18B20_DQ_OUT_High; DS18B20_Mode_IPU(); Delay_us(12); if (DS18B20_DQ_IN) dat |= 0x01; Delay_us(50); } return dat;} // 从DS18B20读取1个字节u8 DS18B20_Read_Byte(void) // read one byte{ u8 i, j, dat; dat = 0; for (i = 0; i &lt; 8; i++) { j = DS18B20_Read_Bit(); dat = (dat) | (j &lt;&lt; i); } return dat;} // 写1位到DS18B20void DS18B20_Write_Bit(u8 dat){ DS18B20_Mode_Out(); if (dat) { DS18B20_DQ_OUT_Low;// Write 1 Delay_us(2); DS18B20_DQ_OUT_High; Delay_us(60); } else { DS18B20_DQ_OUT_Low;// Write 0 Delay_us(60); DS18B20_DQ_OUT_High; Delay_us(2); }} // 写1字节到DS18B20void DS18B20_Write_Byte(u8 dat){ u8 j; u8 testb; DS18B20_Mode_Out(); for (j = 1; j &lt;= 8; j++) { testb = dat &amp; 0x01; dat = dat &gt;&gt; 1; if (testb) { DS18B20_DQ_OUT_Low;// 写1 Delay_us(10); DS18B20_DQ_OUT_High; Delay_us(50); } else { DS18B20_DQ_OUT_Low;// 写0 Delay_us(60); DS18B20_DQ_OUT_High;// 释放总线 Delay_us(2); } }} //初始化DS18B20的IO口，同时检测DS的存在u8 DS18B20_Init(void){ DS18B20_GPIO_Config(); DS18B20_Rst(); return DS18B20_Answer_Check();} // 从ds18b20得到温度值，精度：0.1C，返回温度值（-550~1250），Temperature1返回浮点实际温度float DS18B20_Get_Temp(u8 i){ //u8 flag; u8 j;//匹配的字节 u8 TL, TH; short Temperature; float Temperature1; DS18B20_Rst(); DS18B20_Answer_Check(); DS18B20_Write_Byte(0xcc);// skip rom DS18B20_Write_Byte(0x44);// convert DS18B20_Rst(); DS18B20_Answer_Check(); // DS18B20\\_Write\\_Byte(0xcc);// skip rom //匹配ID，i为形参 DS18B20\\_Write\\_Byte(0x55); for (j = 0; j &lt; 8; j++) { DS18B20\\_Write\\_Byte(DS18B20_ID\\[i\\]\\[j\\]); } DS18B20\\_Write\\_Byte(0xbe);// convert TL = DS18B20\\_Read\\_Byte(); // LSB TH = DS18B20\\_Read\\_Byte(); // MSB if (TH &amp; 0xfc) { //flag=1; Temperature = (TH &lt;&lt; 8) | TL; Temperature1 = (~Temperature) + 1; Temperature1 *= 0.0625; } else { //flag=0; Temperature1 = ((TH &lt;&lt; 8) | TL)*0.0625; } return Temperature1; } // 自动搜索ROMvoid DS18B20_Search_Rom(void){ u8 k, l, chongtuwei, m, n, num; u8 zhan[5]; u8 ss[64]; u8 tempp; l = 0; num = 0; do { DS18B20_Rst(); //注意：复位的延时不够 Delay_us(480); //480、720 DS18B20_Write_Byte(0xf0); for (m = 0; m &lt; 8; m++) { u8 s = 0; for (n = 0; n &lt; 8; n++) { k = DS18B20_Read_2Bit();//读两位数据 k = k &amp; 0x03; s &gt;&gt;= 1; if (k == 0x01)//01读到的数据为0 写0 此位为0的器件响应 { DS18B20\\_Write\\_Bit(0); ss\\[(m * 8 + n)\\] = 0; } else if (k == 0x02)//读到的数据为1 写1 此位为1的器件响应 { s = s | 0x80; DS18B20\\_Write\\_Bit(1); ss\\[(m * 8 + n)\\] = 1; } else if (k == 0x00)//读到的数据为00 有冲突位 判断冲突位 { //如果冲突位大于栈顶写0 小于栈顶写以前数据 等于栈顶写1 chongtuwei = m * 8 + n + 1; if (chongtuwei &gt; zhan\\[l\\]) { DS18B20\\_Write\\_Bit(0); ss\\[(m * 8 + n)\\] = 0; zhan\\[++l\\] = chongtuwei; } else if (chongtuwei &lt; zhan\\[l\\]) { s = s | ((ss\\[(m * 8 + n)\\] &amp; 0x01) &lt;&lt; 7); DS18B20\\_Write\\_Bit(ss\\[(m * 8 + n)\\]); } else if (chongtuwei == zhan\\[l\\]) { s = s | 0x80; DS18B20\\_Write\\_Bit(1); ss\\[(m * 8 + n)\\] = 1; l = l - 1; } } else { //没有搜索到 } } tempp = s; DS18B20_ID\\[num\\]\\[m\\] = tempp; // 保存搜索到的ID } num = num + 1;// 保存搜索到的个数 } while (zhan\\[l\\] != 0 &amp;&amp; (num &lt; MaxSensorNum)); DS18B20_SensorNum = num; //printf(&quot;DS18B20\\_SensorNum=%d\\\\r\\\\n&quot;,DS18B20\\_SensorNum); } DS18B20.h文件代码： #ifndef __DS18B20_H #define __DS18B20_H #include “stm32f10x.h” u8 DS18B20_Init(void);u8 DS18B20_Read_Byte(void);u8 DS18B20_Read_Bit(void);u8 DS18B20_Answer_Check(void);void DS18B20_GPIO_Config(void);void DS18B20_Mode_IPU(void);void DS18B20_Mode_Out(void);void DS18B20_Rst(void);void DS18B20_Search_Rom(void);void DS18B20_Write_Byte(u8 dat);float DS18B20_Get_Temp(u8 i); #endif main.c文件代码： #include “stm32f10x.h” #include “stdio.h” #include “string.h”//strlen、memset用到 #include “USART.h” #include “Delay.h” #include “DS18B20.h” extern unsigned char DS18B20_ID[8][8];//检测到的传感器ID存数组extern unsigned char DS18B20_SensorNum; int main(void){ u8 num=0; USART1_init(9600); while(DS18B20_Init())//初始化DS18B20,兼检测18B20 { printf(“DS18B20 Check Failed!\\r\\n”); } printf(“DS18B20 Ready!\\r\\n”); while(1) { DS18B20_Search_Rom(); printf(“DS18B20_SensorNum:%d\\r\\n”,DS18B20_SensorNum); for(num=0;num&lt;DS18B20_SensorNum;num++) { printf(“ID:%02x%02x%02x%02x%02x%02x%02x%02x TM:%.2f\\r\\n”,DS18B20_ID[num][0],DS18B20_ID[num][1],DS18B20_ID[num][2],DS18B20_ID[num][3],DS18B20_ID[num][4],DS18B20_ID[num][5],DS18B20_ID[num][6],DS18B20_ID[num][7],DS18B20_Get_Temp(num)); } printf(“\\r\\n”); Delay_s(2); }} 运行结果如图： 帮严博士出本科题的时候，出了一个DS18B20的分布式温度检测系统，要求肯定不仅仅是这篇文章的简略例子了。不仅单总线，一块单片机还要挂多总线，实现更多传感器数据采集，最好还配上上位机，反正把自己能想到的东西都加进来了，把一个简单的DS18B20包装得高大上。","tags":[]},{"title":"C语言字符串处理","date":"2016-12-01T12:21:25.000Z","path":"2016/c-string-code.html","text":"本文主要记录自己学习C语言字符串处理时常用的函数，方便以后使用查找，代码如下： #include &lt;stdio.h&gt; #include &lt;string.h&gt;//字符串需调用 #include &lt;stdlib.h&gt;//字符串、整型转换要用 int main(int argc, char *argv[]){ //1、strlen(字符串);测试字符串长度 char str1[] = “sandeepin !”; printf(“字符串str1为：%s\\n”, str1); int str1len = strlen(str1);//strlen求字符串实际长度，即不含’\\0’，str1实际长度为11，sizeof包括所有长度 printf(“字符串长度:%d\\n”, str1len); //2、strcat(字符串1,字符串2);把字符串2连接到字符串1后面，结果放在字符串1中，字符串2不变 char cat1\\[30\\] = &quot;jfz&quot;, cat2\\[4\\] = &quot;kxy&quot;; printf(&quot;\\\\n字符串1为：%s，字符串2为：%s\\\\n&quot;, cat1, cat2); printf(&quot;连接后为：%s \\\\n&quot;, strcat(cat1, cat2));//字符数组1要有容纳两个字符串的空间。字符串1原有的&apos;\\\\0&apos;被字符串2第一个字符代替。 //3、memset(字符串,&apos;字符&apos;,字符数n);将字符串前n个字节设置成&apos;字符&apos; memset(str1, &apos;X&apos;, 3); printf(&quot;\\\\n字符串str1前3个设为X效果：%s\\\\n&quot;, str1); //4、strcpy(字符串Out,字符串In);将字符串In复制到字符串Out中,字符串Out原有内容被清空 char str2\\[\\] = &quot;12345678901234567890&quot;; printf(&quot;\\\\n字符串str2为：%s\\\\n&quot;, str2); strcpy(str2, str1); printf(&quot;字符串str1复制到字符串str2中效果：%s\\\\n&quot;, str2); //5、strlwr(字符串);将字符串转换为小写形式 //6、strupr(字符串);将字符串转换为大写形式 strlwr(str1); printf(&quot;\\\\nstr1全小写：%s&quot;, str1); strupr(str1); printf(&quot;\\\\nstr1全大写：%s\\\\n&quot;, str1); //7、strrev(字符串);将字符串所有字符的顺序颠倒过来（不包括空字符NULL） strrev(str1); printf(&quot;\\\\nstr1颠倒：%s\\\\n&quot;, str1); //8、strset(字符串,&apos;字符&apos;);把字符串中的所有字符都设置成&apos;字符&apos;。 strset(str2, &apos;6&apos;); printf(&quot;\\\\nstr2全设置为6：%s\\\\n&quot;, str2); //9、strtok(字符串1,字符串2);分解字符串为一组标记串。字符串1为要分解的字符串，字符串2为分隔符字符串 //10、itoa(整数,字符串,进制数);(要用stdlib.h)将整数赋值到字符串，最后要定义进制数，一般十进制 int num = 1994; char str4\\[5\\]; itoa(num, str4, 10); printf(&quot;\\\\n整数为：%d\\\\n&quot;, num); printf(&quot;字符串为：%s\\\\n&quot;, str4); //11、atof(字符串);(要用stdlib.h)字符串转double双精度浮点数 char str5\\[8\\] = &quot;1.23456&quot;; double num2; num2 = atof(str5); printf(&quot;\\\\ndouble双精度浮点数为：%f\\\\n&quot;, num2); system(&quot;pause&quot;); return 0; } 这里只列出了常用的一些，推荐大家参考《C参考手册》、《C语言库函数速查手册》，网上有人都做成了.chm文件，方便查询。","tags":[]},{"title":"异想家纯C语言矩阵运算库","date":"2016-11-30T11:06:56.000Z","path":"2016/jfz-cmatlib.html","text":"Sandeepin最近做的项目中需要在嵌入式芯片里跑一些算法，而这些单片机性能不上不下，它能跑些简单的程序，但又还没到上Linux系统的地步。所以只好用C语言写一些在高级语言里一个函数就解决的算法了，由于算法需要运用矩阵运算，自己就先用纯C语言写了个简单的矩阵运算库。 代码只实现了矩阵最基本的运算，包括矩阵的加、减、乘、数乘、转置、行列式、逆矩阵、代数余子式、伴随矩阵等运算。此外增加了一些实用函数，如显示矩阵、从csv文件读取保存矩阵等函数。具体的例子在主函数中体现，其中还用自己这个矩阵运算库做了一个简单的应用，利用公式β=(X’X)^(-1)X’Y来进行多元线性回归系数计算，大家可以参考参考，欢迎批评。 JfzMatLib.c文件代码： #include “JfzMatLib.h” int main(int argc, char* argv){ //矩阵的基本运算：加、减、乘、数乘、转置、行列式、逆矩阵、代数余子式、伴随矩阵 //初始实验矩阵 double A[] = { -3, 2, -5, -1, 0, -2, 3, -4, 1 }; double B[] = { 1, 4, 7, 3, 0, 5, -1, 9, 11 }; double C[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //计算结果矩阵 double \\Add = (double*)malloc(sizeof(double) 9); double \\Sub = (double*)malloc(sizeof(double) 9); double \\Mul = (double*)malloc(sizeof(double) 9); double \\kMat = (double*)malloc(sizeof(double) 9); double \\CT = (double*)malloc(sizeof(double) 9); double \\AInv = (double*)malloc(sizeof(double) 9); double \\Adj = (double*)malloc(sizeof(double) 9); //显示矩阵A、B、C printf(“A：\\n”); MatShow(A, 3, 3); printf(“B：\\n”); MatShow(B, 3, 3); printf(“C：\\n”); MatShow(C, 3, 3); //矩阵相加 printf(“A+B：\\n”); Add = MatAdd(A, B, 3, 3); MatShow(Add, 3, 3); //矩阵相减 printf(“A-B：\\n”); Sub = MatSub(A, B, 3, 3); MatShow(Sub, 3, 3); //矩阵相乘 printf(“AB：\\n”); Mul = MatMul(A, 3, 3, B, 3, 3); MatShow(Mul, 3, 3); //矩阵数乘 printf(“2*C：\\n”); kMat = MatMulk(C, 3, 3, 2); MatShow(kMat, 3, 3); //矩阵转置 printf(“C的转置：\\n”); CT = MatT(C, 3, 3); MatShow(CT, 3, 3); //矩阵行列式值 printf(“B的行列式值：\\n”); printf(“%16lf\\n”, MatDet(B, 3)); printf(“C的行列式值：\\n”); printf(“%16lf\\n”, MatDet(C, 3)); //矩阵的逆 printf(“A的逆：\\n”); AInv = MatInv(A, 3, 3); MatShow(AInv, 3, 3); printf(“C的逆：\\n”); MatInv(C, 3, 3); //矩阵代数余子式 printf(“C的(0,0)元素的代数余子式：\\n”); printf(“%16lf\\n”, MatACof(C, 3, 0, 0)); //矩阵伴随矩阵 printf(“A的伴随矩阵：\\n”); Adj = MatAdj(A, 3, 3); MatShow(Adj, 3, 3); //蒋方正矩阵库应用：多元线性回归 //多元线性回归公式：β=(X&apos;X)^(-1)X&apos;Y double X\\[15\\]\\[5\\] = { 1, 316, 1536, 874, 981,//第一列要补1 1, 385, 1771, 777, 1386, 1, 299, 1565, 678, 1672, 1, 326, 1970, 785, 1864, 1, 441, 1890, 785, 2143, 1, 460, 2050, 709, 2176, 1, 470, 1873, 673, 1769, 1, 504, 1955, 793, 2207, 1, 348, 2016, 968, 2251, 1, 400, 2199, 944, 2390, 1, 496, 1328, 749, 2287, 1, 497, 1920, 952, 2388, 1, 533, 1400, 1452, 2093, 1, 506, 1612, 1587, 2083, 1, 458, 1613, 1485, 2390 }; double Y\\[15\\]\\[1\\] = { 3894, 4628, 4569, 5340, 5449, 5599, 5010, 5694, 5792, 6126, 5025, 5924, 5657, 6019, 6141 }; //多元线性回归公式：β=(X&apos;X)^(-1)X&apos;Y double \\*XT = (double\\*)malloc(sizeof(double) * 5 * 15); double \\*XTX = (double\\*)malloc(sizeof(double) * 5 * 5); double \\*InvXTX = (double\\*)malloc(sizeof(double) * 5 * 5); double \\*InvXTXXT = (double\\*)malloc(sizeof(double) * 5 * 15); double \\*InvXTXXTY = (double\\*)malloc(sizeof(double) * 5 * 1); XT = MatT((double*)X, 15, 5); XTX = MatMul(XT, 5, 15, (double*)X, 15, 5); InvXTX = MatInv(XTX, 5, 5); InvXTXXT = MatMul(InvXTX, 5, 5, XT, 5, 15); InvXTXXTY = MatMul(InvXTXXT, 5, 15, (double*)Y, 15, 1); printf(&quot;多元线性回归β系数：\\\\n&quot;); MatShow(InvXTXXTY, 5, 1); //保存矩阵到csv MatWrite(&quot;XTX.csv&quot;, XTX, 5, 5); MatWrite(&quot;InvXTXXTY.csv&quot;, InvXTXXTY, 5, 1); MatWrite(&quot;Fuck.csv&quot;, A, 3, 3); MatWrite(&quot;Fuck2.csv&quot;, A, 9, 1); //从csv读取矩阵 double \\*Fuck = (double\\*)malloc(sizeof(double) * 3 * 3); Fuck = MatRead(&quot;Fuck.csv&quot;); MatShow(Fuck, 3, 3); double \\*Fuck2 = (double\\*)malloc(sizeof(double) * 9 * 1); Fuck2 = MatRead(&quot;Fuck2.csv&quot;); MatShow(Fuck2, 9, 1); double \\*InvXTXXTYread = (double\\*)malloc(sizeof(double) * 5 * 1); InvXTXXTYread = MatRead(&quot;InvXTXXTY.csv&quot;); MatShow(InvXTXXTYread, 5, 1); double \\*XTXread = (double\\*)malloc(sizeof(double) * 5 * 5); XTXread = MatRead(&quot;XTX.csv&quot;); MatShow(XTXread, 5, 5); system(&quot;pause&quot;); } JfzMatLib.h头文件代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void MatShow(double Mat, int row, int col);double MatAdd(double A, double B, int row, int col);double MatSub(double A, double B, int row, int col);double MatMul(double A, int Arow, int Acol, double B, int Brow, int Bcol);double MatMulk(double A, int row, int col, double k);double MatT(double A, int row, int col);double MatDet(double A, int row);double MatInv(double A, int row, int col);double MatACof(double A, int row, int m, int n);double MatAdj(double A, int row, int col);double *MatRead(char *csvFileName, int row, int col);void MatWrite(char *A, int row, int col); // (det用)功能：求逆序对的个数int inver_order(int list[], int n){ int ret = 0; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt; i; j++) if (list[j] &gt; list[i]) ret++; return ret;} // (det用)功能：符号函数，正数返回1，负数返回-1int sgn(int order){ return order % 2 ? -1 : 1;} // (det用)功能：交换两整数a、b的值void swap(int *a, int *b){ int m; m = a; \\a = *b; *b = m;} // 功能：求矩阵行列式的核心函数double det(double p, int n, int k, int list[], double sum){ if (k &gt;= n) { int order = inver_order(list, n); double item = (double)sgn(order); for (int i = 0; i &lt; n; i++) { //item = p[i][list[i]]; item = (p + i * n + list[i]); } return sum + item; } else { for (int i = k; i &lt; n; i++) { swap(&amp;list[k], &amp;list[i]); sum = det(p, n, k + 1, list, sum); swap(&amp;list[k], &amp;list[i]); } } return sum;} // 功能：矩阵显示// 形参：(输入)矩阵首地址指针Mat，矩阵行数row和列数col。// 返回：无void MatShow(double Mat, int row, int col){ for (int i = 0; i &lt; rowcol; i++) { printf(“%16lf “, Mat[i]); if (0 == (i + 1) % col) printf(“\\n”); }} // 功能：矩阵相加// 形参：(输入)矩阵A首地址指针A，矩阵B首地址指针B，矩阵A(也是矩阵B)行数row和列数col// 返回：A+Bdouble MatAdd(double A, double B, int row, int col){ double \\Out = (double*)malloc(sizeof(double) row col); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) Out[col*i + j] = A[col*i + j] + B[col*i + j]; return Out;} // 功能：矩阵相减// 形参：(输入)矩阵A，矩阵B，矩阵A(也是矩阵B)行数row和列数col// 返回：A-Bdouble MatSub(double A, double B, int row, int col){ double \\Out = (double*)malloc(sizeof(double) row col); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) Out[col*i + j] = A[col*i + j] - B[col*i + j]; return Out;} // 功能：矩阵相乘// 形参：(输入)矩阵A，矩阵A行数row和列数col，矩阵B，矩阵B行数row和列数col// 返回：ABdouble MatMul(double A, int Arow, int Acol, double B, int Brow, int Bcol){ double *Out = (double*)malloc(sizeof(double) Arow Bcol); if (Acol != Brow) { printf(“ Shit!矩阵不可乘!\\n”); return NULL; } if (Acol == Brow) { int i, j, k; for (i = 0; i &lt; Arow; i++) for (j = 0; j &lt; Bcol; j++) { Out[Bcoli + j] = 0; for (k = 0; k &lt; Acol; k++) Out[Bcol\\i + j] = Out[Bcol*i + j] + A[Acol*i + k] * B[Bcol*k + j]; } return Out; }} // 功能：矩阵数乘(实数k乘以矩阵A)// 形参：(输入)矩阵A首地址指针，矩阵行数row和列数col，实数k// 返回：kAdouble MatMulk(double A, int row, int col, double k){ double *Out = (double*)malloc(sizeof(double) row col); for (int i = 0; i &lt; row col; i++) { \\Out = *A k; Out++; A++; } Out = Out - row col; return Out;} // 功能：矩阵转置// 形参：(输入)矩阵A首地址指针A，行数row和列数col// 返回：A的转置double MatT(double A, int row, int col){ double *Out = (double*)malloc(sizeof(double) row col); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) Out[row*j + i] = A[col*i + j]; return Out;} // 功能：求行列式值// 形参：(输入)矩阵A首地址指针A，行数row// 返回：A的行列式值double MatDet(double A, int row){ int \\list = (int*)malloc(sizeof(int) * row); for (int i = 0; i &lt; row; i++) list[i] = i; double Out = det(A, row, 0, list, 0.0); free(list); return Out;} // 功能：矩阵的逆// 形参：(输入)矩阵A首地址指针A，行数row和列数col// 返回：A的逆double *MatInv(double *A, int row, int col){ double *Out = (double*)malloc(sizeof(double) row col); double det = MatDet(A, row); //求行列式 if (det == 0) { printf(“ Fuck!矩阵不可逆!\\n”); return NULL; } if (det != 0) { Out = MatAdj(A, row, col); //求伴随矩阵 int len = row row; for (int i = 0; i &lt; len; i++) (Out + i) /= det; return Out; }} // 功能：求代数余子式// 形参：(输入)矩阵A首地址指针A，矩阵行数row, 元素a的下标m，n(从0开始)，// 返回：NxN 矩阵中元素A(mn)的代数余子式double MatACof(double A, int row, int m, int n){ int len = (row - 1) (row - 1); double *cofactor = (double*)malloc(sizeof(double) * len); int count = 0; int raw_len = row * row; for (int i = 0; i &lt; raw_len; i++) if (i / row != m &amp;&amp; i % row != n) *(cofactor + count++) = *(A + i); double ret = MatDet(cofactor, row - 1); if ((m + n) % 2) ret = -ret; free(cofactor); return ret; } // 功能：求伴随矩阵// 形参：(输入)矩阵A首地址指针A，行数row和列数col// 返回：A的伴随矩阵double *MatAdj(double *A, int row, int col){ double *Out = (double*)malloc(sizeof(double) row col); int len = row row; int count = 0; for (int i = 0; i &lt; len; i++) { (Out + count++) = MatACof(A, row, i % row, i / row); } return Out;} // 读取文件行数int FileReadRow(const char filename){ FILE f = fopen(filename, “r”); int i = 0; char str[4096]; while (NULL != fgets(str, 4096, f)) ++i; printf(“数组行数：%d\\n”, i); return i;} // 读取文件每行数据数(逗号数+1)int FileReadCol(const char filename){ FILE f = fopen(filename, “r”); int i = 0; char str[4096]; fgets(str, 4096, f); for (int j = 0; j &lt; strlen(str); j++) { if (‘,’ == str[j]) i++; } i++;// 数据数=逗号数+1 printf(“数组列数：%d\\n”, i); return i;} // 逗号间隔数据提取void GetCommaData(char str_In[4096], double double_Out[1024]){ int str_In_len = strlen(str_In); //printf(“str_In_len:%d\\n”, str_In_len); char str_Data_temp[128]; int j = 0; int double_Out_num = 0; for (int i = 0; i &lt; str_In_len; i++) { //不是逗号，则是数据，存入临时数组中 if (‘,’ != str_In[i]) str_Data_temp[j++] = str_In[i]; //是逗号或\\n(最后一个数据)，则数据转换为double，保存到输出数组 if (‘,’ == str_In[i] || ‘\\n’ == str_In[i]) { str_Data_temp[j] = ‘\\0’; j = 0; /*printf(“str_Data_temp:%s\\n”, str_Data_temp); */double_Out[double_Out_num++] = atof(str_Data_temp); memset(str_Data_temp, 0, sizeof(str_Data_temp)); } }} // 功能：从csv文件读矩阵，保存到指针中// 形参：(输入)csv文件名，预计行数row和列数col// 返回：矩阵指针Adouble *MatRead(char *csvFileName){ int row = FileReadRow(csvFileName); int col = FileReadCol(csvFileName); double *Out = (double*)malloc(sizeof(double) row col); FILE f = fopen(csvFileName, “r”); char buffer[4096]; while (fgets(buffer, sizeof(buffer), f)) { //printf(“buffer[%s]\\n”,buffer); double double_Out[128] = { 0 }; GetCommaData(buffer, double_Out); for (int i = 0; i &lt; col; i++) { //printf(“double_Out:%lf\\n”, double_Out[i]); Out = double_Out[i]; Out++; } } Out = Out - row * col;//指针移回数据开头 fclose(f); return Out; } // 功能：将矩阵A存入csv文件中// 形参：(输入)保存的csv文件名，矩阵A首地址指针A，行数row和列数col// 返回：无void MatWrite(const char *csvFileName, double *A, int row, int col){ FILE DateFile; double Ap = A; DateFile = fopen(csvFileName, “w”);//追加的方式保存生成的时间戳 for (int i = 0; i &lt; rowcol; i++) { if ((i+1) % col == 0) fprintf(DateFile, “%lf\\n”, Ap);//保存到文件，到列数换行 else fprintf(DateFile, “%lf,”, *Ap);//加逗号 Ap++; } fclose(DateFile);} 运行结果如图：","tags":[]},{"title":"2014年末Mac mini装Win7的方法","date":"2016-07-01T03:56:52.000Z","path":"2016/macmini-win7-install.html","text":"最近和同学玩心灵终结，然而Win10对此游戏兼容性太差，又黑屏又不能切出，所以想试试Win7下跑这款游戏，顺便也想了解集显带零几年的游戏的性能。 可惜装Win7并不顺利。由于Mac mini都为USB3.0接口，Win7不带驱动，进入安装界面后鼠标键盘无效，进入不下去了。不过知道了进行不下去的原因，自然也就有了解决方法，这几天我探究的能成功装机的方法如下： 1、BootCamp最正常装机BootCamp里做镜像，利用BootCamp自己的分区重启功能进入装系统界面。这样做重启的时候苹果会自动加载USB3.0驱动，然后装机过程一切正常。 2、使用蓝牙鼠标键盘蓝牙驱动Win7自带，而且蓝牙配对后就硬件关联了，就算重装系统，配对了的硬件还能连上。用这种方法装Win7，就规避了USB3.0驱动的问题。 3、Win7镜像注入USB3.0驱动我在网上找了一份脚本，按照它的步骤走就能傻瓜化为Win7注入USB3.0驱动，不过脚本运行不支持Win10，找一个Win7或Win8的系统按视频教程写入U盘就完成了，亲测制作好的镜像安装时能操作键盘鼠标。 4、直接镜像恢复方法优点是最傻瓜最便捷，但是看教程操作还需花点时间学习，大家可到看看以下几篇文章和论坛，自己折腾吧！","tags":[]},{"title":"Win10x64电脑安装USB转TTL驱动(PL2303)","date":"2016-05-18T03:54:57.000Z","path":"2016/win10x64-usb-to-ttl-pl2303.html","text":"首先使用这个驱动文件进行安装，如果安装好后正常，那就OK了。若安装完以后此时还是感叹号，则打开设备管理器，右键点更新驱动，按照下述步骤设置，亲测没问题。 网上搜索到另一种解决方法，我在自己另一台电脑上遇到了，没截图，大家也可试试：选高版本(3.6.78)装完以后依然是感叹号，可以从计算机的设备驱动列表选取，选3.3.5.112版本的然后就OK了。 另外提一下，Win7串口驱动一般装HL-340，点这里下载。","tags":[]},{"title":"STM32控制4种灯质闪烁","date":"2016-05-09T03:56:04.000Z","path":"2016/stm32-led-flash.html","text":"上次做的STM32项目中要求实现4种灯的闪烁效果，并能控制闪烁模式的切换。实现4种灯的闪烁效果并不难，用很精确的延时函数配合高低电平控制就能实现了。控制端使用引脚输入控制，类似3-8译码器，三个输入即可控制8种闪烁效果。 4种灯质闪烁闪烁的规则如下图： 简单说就是要设定灯关闭、常亮、快闪、慢闪、亮灭时间不同闪和混合效果闪。难点在于控制。如果在一个函数中设定一个周期的灯闪烁循环，那么如果周期长的话，切换模式后也得等到周期执行完了才能进入下一种闪烁模式，于是自己写了一个以闪烁中最小周期为循环节的循环显示效果，这样发出控制命令后，能及时切换到其它模式。虽然也会延时最小变化周期，但是应该够用了，更精确的写法可以试试中断。本代码的优点就在于在于简洁易懂，无需其它配置。 代码中设定的输入控制信号为：PC1、PC2、PC3，输出的灯接PE5。定义的几种闪烁效果为： 丹顿光：亮3秒，灭1秒等明暗光：亮、灭各2秒连续快闪光：亮、灭各0.5秒联甚块闪光：亮0.5秒，灭0.5秒，循环6次；亮2秒，灭2秒 PC1、PC2、PC3设定与对应模式：000灭、010常亮、100丹顿光Oc、101等明暗光Iso、110连续快闪光QFlash、111联甚快闪光VQLFI 代码如下： #include “stm32f10x.h” #define Delay_ms(msec) Delay_us(msec*1000) //延时毫秒级 #define PC1 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1) //读PC1 #define PC2 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2) //读PC2 #define PC3 GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_3) //读PC3 void LED_GPIO_Config(void) //配置LED用到的I/O口{ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOE, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOE, GPIO_Pin_5);} void Input_GPIO_Config(void)//输入I/O口配置{ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);// GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3; // GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //IPU;上拉、IPD下拉 GPIO_Init(GPIOC, &amp;GPIO_InitStructure);} void Delay_us(u32 ntimes){ u32 flag; SysTick-&gt;LOAD=9*ntimes; SysTick-&gt;VAL=0; SysTick-&gt;CTRL=0x00000001; do { flag=SysTick-&gt;CTRL; } while(flag&amp;0x01&amp;&amp;!(flag&amp;(1&lt;&lt;16))); SysTick-&gt;CTRL=0;} //丹顿光：亮3秒，灭1秒//等明暗光：亮、灭各2秒//连续快闪光：亮、灭各0.5秒//联甚块闪光：亮0.5秒，灭0.5秒，循环6次；亮2秒，灭2秒//PC1 PC2 PC3// 0 0 0 灭// 0 1 0 常亮// 1 0 0 丹顿光Oc// 1 0 1 等明暗光Iso// 1 1 0 连续快闪光QFlash// 1 1 1 联甚快闪光VQLFI//灯接的是PE5void LED_FLASH_Simple(u8 l,u8 m,u8 s) //灯闪烁，l为亮的时间，m为灭的时间。s为亮灭模式切换{ u8 i; if(s==1) { GPIO_SetBits(GPIOE , GPIO_Pin_5); for(i=0;i&lt;l;i++) Delay_ms(500); } if(s==0) { GPIO_ResetBits(GPIOE,GPIO_Pin_5); for(i=0;i&lt;m;i++) Delay_ms(500); }} u8 s=1,j=0;int main(void){ LED_GPIO_Config(); Input_GPIO_Config(); while(1) { if(PC3==0 &amp;&amp; PC1==0 ) { GPIO_ResetBits(GPIOE,GPIO_Pin_5); j=0; } if(PC3==0 &amp;&amp; PC1==1 ) { GPIO\\_SetBits(GPIOE , GPIO\\_Pin_5); j=0; } if(PC3==1) { if(PC1==0 &amp;&amp; PC2==0) { j=0; LED\\_FLASH\\_Simple(6,2,s); if(s==1) s=0; else s=1; } if(PC1==0 &amp;&amp; PC2==1) { j=0; LED\\_FLASH\\_Simple(4,4,s); if(s==1) s=0; else s=1; } if(PC1==1 &amp;&amp; PC2==0) { j=0; LED\\_FLASH\\_Simple(1,1,s); if(s==1) s=0; else s=1; } if(PC1==1 &amp;&amp; PC2==1) { if(j&lt;12) { LED\\_FLASH\\_Simple(1,1,s); if(s==1) s=0; else s=1; j++; } if(j==12) { LED\\_FLASH\\_Simple(4,4,s); if(s==1) s=0; else s=1; j++; } if(j==13) { LED\\_FLASH\\_Simple(4,4,s); if(s==1) s=0; else s=1; j=0; } } } } }","tags":[]},{"title":"NotePad++配合TDM-GCC搭建C++开发环境","date":"2016-05-07T03:53:53.000Z","path":"2016/notepad-tdm-gcc-cpp.html","text":"1、安装TDM-GCC编译器TDM-GCC官网为：http://tdm-gcc.tdragon.net 安装软件，安装完会自动配置环境变量(可能需要重启后生效)，cmd中输入g++ –version看看是否安装好。 2、打开Notepad++，编写一段C++代码并保存例如： #includeusing namespace std; int main(void){ cout&lt;&lt;”Sandeepin异想家！”&lt;&lt;endl; return 0;} 3、编写编译指令菜单栏-&gt;运行-&gt;运行，弹出框中输入： cmd /k g++ -o $(NAME_PART).exe “$(FULL_CURRENT_PATH)” &amp; PAUSE &amp; EXIT 选择快捷键(我选择Alt+G)后保存为：G++编译。注意快捷键不要有重复，在点击弹出框的运行，关闭Notepad++，再打开Notepad++； 4、编写运行指令菜单栏-&gt;运行-&gt;运行，弹出框中输入： cmd /k “$(NAME_PART)” &amp; PAUSE &amp; EXIT 选择快捷键(我选择Alt+R)后保存为：G++运行。再点运行程序就会执行了。 5、开始体验吧！以后写好cpp文件后，点击“G++编译”，如果有错可看到提示，没错则显示“请按任意键继续. . .”。 关闭，再点击“G++运行”，即可看到运行结果：","tags":[]},{"title":"PCB设计学习笔记：Altium Designer入门","date":"2016-05-01T03:52:46.000Z","path":"2016/pcb-study-altium-designer.html","text":"本PCB学习笔记是我听金沙滩工作室“PCB设计基础指南”总结而成的，主要介绍了Altium Designer的基本使用方法。本文不是视频版的文字复述，也不是在线教程，只记录了视频中基本设计方法和一些小技巧，供以后参考。Altium Designer这类软件的学习光看光记是不够的，必须亲自动手操作，只有多做多练，遇到问题多上网查，在实践挫折中才能成长！ 先来一句装逼的话：“画PCB，不是一门技术，而是艺术！” PCB的种类单面板（只在一个面走线） 双面板（在两个面都走线） 多层板（4、6、8、10……）（出两个面外还有内层） 柔性PCB（触摸屏等的连接） PCB的制作步骤绘制电路原理图——绘制PCB图——(为了保密导出为制板文件Gerber等)——将PCB图交由加工厂制作——焊接器件并调试验证 绘制PCB的工具软件Altium公司产品：Protel、Altium Designer (中低端) MentorGraphics公司产品：PADS、MentorWG Cadence公司产品：OrCAD、Allegro SPB (高端) Altium Designer PCB设计步骤绘制电路原理图(需要原理图器件库的支持)——将原理图导入到PCB中(需要PCB器件库的支持)——PCB布局布线——PCB电气规则检查DRC 设置中文方法：DXP-&gt;Preferences-&gt;System-&gt;General-&gt;Localization-&gt;Use Localized resources (不推荐中文，习惯英文好，术语翻译不准确) 1、新建PCB工程 File-&gt;New-&gt;Project-&gt;PCB Project-&gt; .PrjPCB(Protel99: .ddb) 2、添加所需文件到工程中Projec-&gt;Add New to Project-&gt;…(或Projec-&gt;Add Existing to Project-&gt;…) 文件类型主要有： 原理图 .SchDoc、原理图库 .SchLib PCB图 .PcbDoc、PCB图库 .PcbLib (Protel99中文件后缀: .sch、.pcb、*.lib) 3、保存工程和文件 Altium Designer 实例演示设计目标：STC89C52最小系统板 大致评估所需资源：主芯片、电阻、电容、晶振、排针、按键、LED 进行的事：创建器件的原理图库、绘制电路原理图、创建器件的PCB库、绘制PCB图、DRC检查 快捷键：pageup pagedown 放大缩小 1、画SCH元件库画STC89C52，封装：PDIP-40，第一个P代表塑料。 快捷键：Tab键 调出属性对话框。 快捷键：空格键 元件旋转 快捷键：X、Y键 镜像旋转 一个元件有名字和编号。 上划线输入：P\\S\\E\\N ,显示效果如下： 【图】 元件默认编号Default Designator： 芯片：U? (加?可实现最后软件进行自动编号) 画电阻RES、画电容CAP用线画，设置线移动粗细：Tools-&gt;Document Options-&gt;Snap捕捉设置为2。 画晶振CRYSTAL可以直接在做了的的文件中Copy到自己的工程中。 画排针孔CON8/4、按键KEY、灯LED排针孔封装SIP(单列直插)。 2、画SCH原理图放元件点【图】图标。 用网络节点可逻辑连两点。 可用“手动节点”连三根线交点。十字交叉点默认不连，强制连用“手动节点Manual Junction”。 设置纸张大小：Design-&gt;Document Options 默认往左下角缩，元件最好摆在左下角。 【图】 技巧：Tools-&gt;Annotate Schematic 自动给元件编号 3、画PCB库 快捷键：Ctrl+End 快速回到原点(或View-&gt;Fit Document)。 定孔英制为整数单位，0.1英寸=100 mil Place Pad焊盘可以改Hole Size(孔径)=30 mil 每隔100坐标放一个，怕放不准，可以改：Tools-&gt;Library Option-&gt;Snap Grid为100 定轮廓、加弧线角轮廓定在Top Overlay(顶层的丝印层)，这层用来标注器件形状，写一些字，画框画在这一层。 快捷键：Ctrl+M 量尺寸(或Reports-&gt;Measure Distance) 添加一个新封装注意：改动了库后要右键更新到Sch原理图(Update Schematic Sheets)。 注意：不小心关闭了左栏(PCB library、Projects、Navigator等)，点View-&gt;Desktop Layouts-&gt;Default可还原。 常见的0805中08表示0.08英寸，05表示0.05英寸，代表长和宽。 贴片元件Layer：Top Layer 晶振PCB库，金属外壳，丝印层铺满。 一些总结： 0805 电容、电阻 DIP40 40个引脚的芯片 SIP4 4针排针孔 XTAL-2 晶振 KET-6x6 按键 0805LD LED(有方向) 4、画PCB图由原理图导入PCB图：Design-&gt;Import Changes From xxx.PrjPCB，注意要把没用的“Add Component Classes”、“Add Rooms”去掉再导入。 导入后元件都在黑框外，点元件，出来属性，把Hide去掉，可显示10K、0.1uF之类信息。 批量改字体大小：Edit-&gt;Find Similar Object-&gt;选图中要改的文字。 其中String Type填Same ，Text Width填Same ，接下来的对话框里Text Width改为5，Text Hight改为30，Stroke Font改为Sans Serif，若Hide改为False全不隐藏。 技巧：点住元件按空格键可旋转，方便布线。 找元件方法：在原理图中找，找到后点Tools-&gt;Cross Probe-&gt;选择要找的元件-&gt;会一闪闪到PCB位置(点右下角Clear后，才可拖动) 文字注释放置技巧：U1、U2之类标注放在外面，芯片名字(1K、0.1uF)放在里面，可不让人看到。 布线布局思路一般先布局再布线，随机应变，常要修修补补，基本上同时都要做。 画线点【图】，注意设置线的宽度。 去耦电容与VCC放得近些。电源线一般设20 mil。地线一般用大面积覆铜。 Place Via放置过孔：用于连线钻孔往下走，Hole Size：20 Diameter：40 注意要设置网络节点，忘了的话会连不上，成为一个孤立元件。 快捷键：S-&gt;Net-&gt;选中一个5V的VCC，则所有5V的VCC都标出。 画轮廓机械层确定板子外形(也有厂家接受Keep-Out Layer)。画线点【图】图标。 覆铜在Top Layer顶层、Bottom Layer底层覆铜，覆之前要切换到选定的层。注意设置覆铜选GND。 调整黑框大小最好和板子一样大。Design-&gt;Board Shape-&gt;Redefine Board Shared 调节原点：Edit-&gt;Origin-&gt;Set 检查Tools-&gt;Design Rule Checke-&gt;Batch只勾选Clearance、Width、Short-Circuit、Un-Routed Net、Hole Size足够检查出一般错误了。 Hole Size最大最小设定：Design-&gt;Rules-&gt;Width-&gt;Min/Max Width 设置为10、20。","tags":[]},{"title":"STM32操纵DHT11湿度传感器","date":"2016-04-25T03:51:49.000Z","path":"2016/stm32-dht11.html","text":"网上的例子不是说不能用，而是各种坑爹引用，搞得想移植都要改半天。现贴出一份经过Sandeepin精心整理的、清晰明了的代码供大家直观学习。 其实DHT11传感器不仅可测湿度，温度也能测，所以代码中包括了两种数据。 不多废话，直接上代码： #include “stm32f10x.h” #include “stdio.h” #define HIGH 1 #define LOW 0 #define DHT11_CLK RCC_APB2Periph_GPIOC #define DHT11_PIN GPIO_Pin_2 #define DHT11_PORT GPIOC #define DHT11_DATA_IN() GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2) //读取引脚的电平//带参宏，可以像内联函数一样使用,输出高电平或低电平 #define DHT11_DATA_OUT(a) if (a) \\ GPIO_SetBits(GPIOC,GPIO_Pin_2);\\ else \\ GPIO_ResetBits(GPIOC,GPIO_Pin_2) u32 TimingDelay; typedef struct{ uint8_t humi_int; //湿度的整数部分 uint8_t humi_deci; //湿度的小数部分 uint8_t temp_int; //温度的整数部分 uint8_t temp_deci; //温度的小数部分 uint8_t check_sum; //校验和}DHT11_Data_TypeDef; void Delay_us(u32 ntimes){ u32 flag; SysTick-&gt;LOAD=9*ntimes; //时间加载 SysTick-&gt;VAL=0; //清空计数器 SysTick-&gt;CTRL=0x00000001; //bit2清空,选择外部时钟HCLK/8, bit0位清空,开启倒计时 do { flag=SysTick-&gt;CTRL; } while(flag&amp;0x01&amp;&amp;!(flag&amp;(1&lt;&lt;16)));//等待时间到达 SysTick-&gt;CTRL=0;//关闭计数器} int fputc(int ch, FILE *f)//重定向c库函数printf到USART1{ USART_SendData(USART1, (unsigned char) ch);//将Printf内容发往串口 while( USART_GetFlagStatus(USART1,USART_FLAG_TC)!= SET); return (ch);} void USART1_Config(unsigned int bound){ GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, &amp;USART_InitStructure); USART_Cmd(USART1, ENABLE);} void DHT11_GPIO_Config(void)//DHT11的GPIO配置{ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(DHT11_CLK, ENABLE); GPIO_InitStructure.GPIO_Pin = DHT11_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(DHT11_PORT, &amp;GPIO_InitStructure); GPIO_ResetBits(DHT11_PORT, GPIO_Pin_2);} static void DHT11_Mode_IPU(void)//使DHT11-DATA引脚变为上拉输入模式{ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = DHT11_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_Init(DHT11_PORT, &amp;GPIO_InitStructure);} static void DHT11_Mode_Out_PP(void)//使DHT11-DATA引脚变为推挽输出模式{ GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = DHT11_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(DHT11_PORT, &amp;GPIO_InitStructure);} static uint8_t Read_Byte(void)//从DHT11读取一个字节，MSB先行{ uint8_t i, temp=0; for(i=0;i&lt;8;i++) { while(DHT11_DATA_IN()==Bit_RESET);//每bit以50us低电平标置开始，轮询直到从机发出 的50us 低电平 结束 //DHT11 以26~28us的高电平表示“0”，以70us高电平表示“1”， //通过检测 x us后的电平即可区别这两个状 ，x 即下面的延时 Delay_us(40); //延时x us 这个延时需要大于数据0持续的时间即可 if(DHT11_DATA_IN()==Bit_SET)// x us后仍为高电平表示数据“1” { while(DHT11_DATA_IN()==Bit_SET);//等待数据1的高电平结束 temp|=(uint8_t)(0x01&lt;&lt;(7-i)); //把第7-i位置1，MSB先行 } else // x us后为低电平表示数据“0” { temp&amp;=(uint8_t)~(0x01&lt;&lt;(7-i)); //把第7-i位置0，MSB先行 } } return temp;} uint8_t Read_DHT11(DHT11_Data_TypeDef *DHT11_Data)//一次完整的数据传输为40bit，高位先出,8bit 湿度整数 + 8bit 湿度小数 + 8bit 温度整数 + 8bit 温度小数 + 8bit 校验和{ DHT11_Mode_Out_PP(); DHT11\\_DATA\\_OUT(LOW);//主机拉低 Delay_us(18000);//延时18ms DHT11\\_DATA\\_OUT(HIGH); //总线拉高 主机延时30us Delay_us(30); //延时30us DHT11\\_Mode\\_IPU();//主机设为输入 判断从机响应信号 if(DHT11\\_DATA\\_IN()==Bit_RESET)//判断从机是否有低电平响应信号 如不响应则跳出，响应则向下运行 { while(DHT11\\_DATA\\_IN()==Bit_RESET);//轮询直到从机发出 的80us 低电平响应信号结束 while(DHT11\\_DATA\\_IN()==Bit_SET);//轮询直到从机发出的 80us 高电平 标置信号结束 DHT11\\_Data-&gt;humi\\_int= Read_Byte();//开始接收数据 DHT11\\_Data-&gt;humi\\_deci= Read_Byte(); DHT11\\_Data-&gt;temp\\_int= Read_Byte(); DHT11\\_Data-&gt;temp\\_deci= Read_Byte(); DHT11\\_Data-&gt;check\\_sum= Read_Byte(); DHT11\\_Mode\\_Out_PP();//读取结束，引脚改为输出模式 DHT11\\_DATA\\_OUT(HIGH);//主机拉高 //检查读取的数据是否正确 if(DHT11\\_Data-&gt;check\\_sum == DHT11\\_Data-&gt;humi\\_int + DHT11\\_Data-&gt;humi\\_deci + DHT11\\_Data-&gt;temp\\_int+ DHT11\\_Data-&gt;temp\\_deci) return SUCCESS; else return ERROR; } else { return ERROR; } } DHT11_Data_TypeDef DHT11_Data;int main(void){ USART1_Config(9600); DHT11_GPIO_Config(); while(1){//调用Read_DHT11读取温湿度，若成功则输出该信息 if( Read_DHT11(&amp;DHT11_Data)==SUCCESS) { printf(“Relative Humidity: %d.%d Temperature: %d.%d \\r\\n”,\\ DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci); Delay_us(500000); } else { printf(“Read DHT11 ERROR! \\r\\n”); Delay_us(500000); } }} 实现效果：在PC2接湿度传感器，通过串口1打印出湿度值、温度值。","tags":[]},{"title":"STM32操纵2.4寸液晶(ILI9325)","date":"2016-04-16T03:50:28.000Z","path":"2016/stm32-ili9325.html","text":"我做的毕设是自动指纹采集识别系统，当然现在还不能把代码放出来。不过在做的过程中用到了液晶显示，配套的例子里刚好有TFTLCD显示实验代码，但它的代码只能显示英文，为了急用，我懒得调用字库，于是自己折腾了一套方法显示中文，现把过程简单记录一下。 液晶屏上的中文显示(Sandeepin的办法)原理：利用两个16x8的显示格子拼凑一个汉字。 用到的字模软件：字模III v3.9。我转换异想家的“异”字得到如下字模： 用字模III v3.9生成的是16x16横向排的字模，且镜像反转了，不配合本液晶系统，需要用到我制作的C语言算法转换： #include “stdafx.h”int revse32int(int a, int len) //len是要旋转的数字位数，从右侧起{ int tmp = 0, i, j; for (i = 0, j = len - 1; i &lt; len; ++i, –j) { if ((a &gt;&gt; i) &amp; 1) tmp |= ((a &gt;&gt; i) &amp; 1) &lt;&lt; j; } return tmp;} int main(void){ //字模软件直接得到的字模 int yuan[32] = { 0x00,0x00,0x3F,0xF0,0x20,0x10,0x20,0x10,0x3F,0xF0,0x20,0x04,0x20,0x04,0x1F,0xFC, 0x00,0x00,0x08,0x20,0x08,0x20,0xFF,0xFE,0x08,0x20,0x10,0x20,0x20,0x20,0x40,0x20 }; int i = 0,j = 0; int jishu[16] = {};//奇数编号数存数组 int oushu[16] = {};//偶数编号数存数组 for (i = 0; i &lt; 32; i++) { if (i % 2 == 0) { jishu[j] = yuan[i]; j++; } } printf(“奇数编号数提取(字符前半边)：\\r\\n”); for (i = 0; i &lt; 16; i++) printf(“,0x%x”, jishu[i]);//奇数编号数提取(字符前半边) printf(“\\r\\n”); j = 0; for (int i = 0; i &lt; 32; i++) { if (i % 2 != 0) { oushu\\[j\\] = yuan\\[i\\]; j++; } } printf(&quot;\\\\r\\\\n偶数编号数提取(字符后半边)：\\\\r\\\\n&quot;); for (int i = 0; i &lt; 16; i++) printf(&quot;,0x%x&quot;, oushu\\[i\\]);//偶数编号数提取(字符后半边) printf(&quot;\\\\r\\\\n&quot;); printf(&quot;\\\\r\\\\n字符前半边翻转:\\\\r\\\\n&quot;); for (int i = 0; i &lt; 16; i++) printf(&quot;,0x%x&quot;, revse32int(jishu\\[i\\], 8));//字符前半边翻转 printf(&quot;\\\\r\\\\n&quot;); printf(&quot;\\\\r\\\\n字符后半边翻转:\\\\r\\\\n&quot;); for (int i = 0; i &lt; 16; i++) printf(&quot;,0x%x&quot;, revse32int(oushu\\[i\\], 8));//字符后半边翻转 printf(&quot;\\\\r\\\\n&quot;); printf(&quot;\\\\r\\\\n格式化显示效果:\\\\r\\\\n&quot;); printf(&quot;{&quot;); for (int i = 0; i &lt; 16; i++) { if (i == 0) printf(&quot;0x%x&quot;, revse32int(jishu\\[i\\], 8)); else printf(&quot;,0x%x&quot;, revse32int(jishu\\[i\\], 8)); } printf(&quot;},/*\\\\&quot;异1\\\\&quot;,01*/&quot;); printf(&quot;\\\\n&quot;); printf(&quot;{&quot;); for (int i = 0; i &lt; 16; i++) { if (i == 0) printf(&quot;0x%x&quot;, revse32int(oushu\\[i\\], 8)); else printf(&quot;,0x%x&quot;, revse32int(oushu\\[i\\], 8)); } printf(&quot;},/*\\\\&quot;异2\\\\&quot;,02*/&quot;); getchar(); return 0; } 效果如下： 张帮我写了个Python版本，更好用，也把代码附上： #!/usr/bin/env python3# -- coding: utf-8 -- def ch(x): x = ((x&amp;0x55)&lt;&lt;1)|((x&amp;0xaa)&gt;&gt;1) x = ((x&amp;0x33)&lt;&lt;2)|((x&amp;0xcc)&gt;&gt;2) x = ((x&amp;0x0f)&lt;&lt;4)|((x&amp;0xf0)&gt;&gt;4) return x def change(): nums = eval(input(‘ctrl+c退出或者继续输入:’)) L1 = [] L2 = [] l = len(nums) i = 0 j = 1 k = 1 for i in range(l): if i % 2 == 0: L1.append(ch(nums[i])) if i % 2 != 0: L2.append(ch(nums[i])) le = len(L1) print(&apos;{&apos;,end = &apos;&apos;,file = f) for i in L1: if j &lt;= 15: print(&apos;0x%02x,&apos; % i, end = &apos;&apos;,file = f) else: print(&apos;0x%02x},&apos; % i, end = &apos;&apos;,file = f) j = j + 1 print(file = f) le = len(L2) print(&apos;{&apos;,end = &apos;&apos;,file = f) for i in L2: if k &lt;= 15: print(&apos;0x%02x,&apos; % i, end = &apos;&apos;,file = f) else: print(&apos;0x%02x},&apos; % i, end = &apos;&apos;,file = f) k = k + 1 print(file = f) print(&apos;\\\\n&apos;,file = f) n = int(input(‘要输入多少中文字符:’))f = open(“./output.txt”, ‘a+’)for i in range(1,n+1): print(‘第%d个字:\\n’ % i,file = f) change() print(‘已输出第%d个字’ % i) 之后将转换后的字模添加到font.h中(图中的例子不是“异”，而是我的名字，举一反三)： const unsigned char CH_1616[100][16]={{0x10,0x10,0xff,0x10,0x0,0x10,0x92,0x54,0x14,0x10,0xd8,0x94,0x12,0x11,0x10,0x10},/“蒋1”,00/{0x4,0x4,0x7f,0x4,0x1,0x1f,0x8,0x5,0xa,0x9,0x7f,0x8,0x9,0x9,0x8,0xc},/“蒋2”,01/{0x40,0x80,0x80,0xff,0x20,0x20,0x20,0xe0,0x20,0x20,0x20,0x10,0x10,0x8,0x4,0x2},/“方1”,02/{0x0,0x0,0x0,0x7f,0x0,0x0,0x0,0xf,0x8,0x8,0x8,0x8,0x8,0x8,0x5,0x2},/“方2”,03/{0x0,0xfe,0x80,0x80,0x80,0x80,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0xff,0x0},/“正1”,04/{0x0,0x3f,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x0},/“正2”,05/}; 在text.c中加入： void LCD_ShowChar_CH(u16 x,u16 y,u16 num,u16 Color){ u16 temp; u8 mode=0; u8 size=16; u8 j,t; u8 count; u16 x0=x; if(x&gt;MAX\\_CHAR\\_POSX||y&gt;MAX\\_CHAR\\_POSY)return; //设置窗口 if(mode==0) //正常显示 { for(j=0;j&lt;size;j++) { temp=CH_1616\\[num\\]\\[j\\]; count=8; for(t=0;t&lt;count;t++) { if(temp&amp;0x01) { LCD_DrawPoint(x,y,Color); } else { LCD\\_DrawPoint(x,y,BACK\\_COLOR); } temp&gt;&gt;=1; x++; } x=x0; y++; } } } void LCD_ShowString_CH(u16 x,u16 y,u16 chnum,u16 Color){ if(chnum==1)//选择菜单(录入、清空) { LCD_ShowChar_CH(0+x,0+y,6,Color);LCD_ShowChar_CH(8+x,0+y,7,Color); LCD_ShowChar_CH(16+x,0+y,8,Color); LCD_ShowChar_CH(24+x,0+y,9,Color); LCD_ShowChar_CH(32+x,0+y,10,Color);LCD_ShowChar_CH(40+x,0+y,11,Color); LCD_ShowChar_CH(48+x,0+y,12,Color);LCD_ShowChar_CH(56+x,0+y,13,Color); LCD_ShowString(64+x,0+y,”(“,Color); LCD_ShowChar_CH(72+x,0+y,14,Color);LCD_ShowChar_CH(80+x,0+y,15,Color); LCD_ShowChar_CH(88+x,0+y,16,Color);LCD_ShowChar_CH(96+x,0+y,17,Color); LCD_ShowChar_CH(104+x,0+y,18,Color);LCD_ShowChar_CH(112+x,0+y,19,Color); LCD_ShowChar_CH(120+x,0+y,20,Color);LCD_ShowChar_CH(128+x,0+y,21,Color); LCD_ShowChar_CH(136+x,0+y,22,Color);LCD_ShowChar_CH(144+x,0+y,23,Color); LCD_ShowString(152+x,0+y,”)”,Color); } if(chnum==2)//指纹识别模式 { LCD_ShowChar_CH(0+x,0+y,24,Color);LCD_ShowChar_CH(8+x,0+y,25,Color); LCD_ShowChar_CH(16+x,0+y,26,Color); LCD_ShowChar_CH(24+x,0+y,27,Color); LCD_ShowChar_CH(32+x,0+y,28,Color);LCD_ShowChar_CH(40+x,0+y,29,Color); LCD_ShowChar_CH(48+x,0+y,30,Color);LCD_ShowChar_CH(56+x,0+y,31,Color); LCD_ShowChar_CH(64+x,0+y,32,Color);LCD_ShowChar_CH(72+x,0+y,33,Color); LCD_ShowChar_CH(80+x,0+y,34,Color);LCD_ShowChar_CH(88+x,0+y,35,Color); }} 以后就可以在主函数中随处调用了： LCD_ShowString_CH(40,10,2,BLUE);//x、y轴指定显示位置，字库中对应显示文字，颜色 附上一张我做的指纹识别系统泄漏图：","tags":[]},{"title":"STM32学习笔记：基础例子","date":"2016-04-09T03:33:33.000Z","path":"2016/stm32-study-example.html","text":"本例子代码参考了STM32库开发实战指南中的代码，由于使用的板子是尚学STM32F103ZET6，为了配合板上已有资源，也参考了其配套代码。为了便于书写文本，我尽量将代码都写到了一个文件中，这种方式是不推荐的，在做具体工程时最好代码分类管理，使工程逻辑清晰。 现在对板上一些资源说明：板上有两个LED灯，引脚为PE5、PE6，均为ResetBits时点亮。有三个按钮，依次为黄色复位，红色PE4(按下接GND)、红色PA0(按下接3.3V，WAKE UP按钮)。ISP口为靠近电源开关的USB，也是USART1口。USART2口为PA3(Rx)、PA2(Tx)。IPD为高电平中断(按键一边接高电平)，IPU为低电平中断。 接下来例举基本操作： 用GPIO点亮灯(GPIO输出)#include “stm32f10x.h”void Delay(__IO u32 nCount) //简单的延时函数{ for(; nCount != 0; nCount–);} void GPIO_Config(void) //配置LED用到的I/O口{ GPIO_InitTypeDef GPIO_InitStructure; //定义一个GPIO_InitTypeDef类型的结构体 RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOE, ENABLE); //开启GPIOE的外设时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6; //选择要控制的GPIOE引脚，这里选了PE5、PE6 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //设置引脚模式为：通用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //设置引脚速率为：50MHz GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //调用库函数，初始化GPIOE GPIO_SetBits(GPIOE, GPIO_Pin_5 | GPIO_Pin_6); //关闭所有LED灯} int main(void){ GPIO_Config(); while(1) { GPIO_SetBits(GPIOE , GPIO_Pin_5); //PE5输出高电平 GPIO_ResetBits(GPIOE,GPIO_Pin_6); //PE6输出低电平 Delay(1000000);//1,000,000 六个零以上才有明显闪烁 GPIO_SetBits(GPIOE , GPIO_Pin_6); //PE6输出高电平 GPIO_ResetBits(GPIOE,GPIO_Pin_5); //PE5输出低电平 Delay(1000000); }} 实现效果：PE6、PE5两盏灯闪烁。 按键输入(GPIO输入)#include “stm32f10x.h” #define KEY1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4) //读PE4(GND) #define KEY2 GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0) //读PA0(VCC) void Delay(__IO u32 nCount) //简单的延时函数{ for(; nCount != 0; nCount–);} void GPIO_Config(void) //配置LED用到的PE5、PE6{ GPIO_InitTypeDef GPIO_InitStructure; //定义一个GPIO_InitTypeDef类型的结构体 RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOE, ENABLE); //开启GPIOE的外设时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6; //选择要控制的GPIOE引脚，这里选了PE5、PE6 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //设置引脚模式为：通用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //设置引脚速率为：50MHz GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //调用库函数，初始化GPIOE GPIO_SetBits(GPIOE, GPIO_Pin_5 | GPIO_Pin_6); //关闭所有LED灯} void Key_GPIO_Config(void)//按键配置，这里用PE4、PE5输入{ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);//开启GPIOE的时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4; //设置引脚PE4 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //上拉输入模式(按键按下接GND用这个) GPIO_Init(GPIOE, &amp;GPIO_InitStructure); RCC\\_APB2PeriphClockCmd(RCC\\_APB2Periph_GPIOA,ENABLE); GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_0; GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_IPD; //下拉输入模式(按键按下接VCC用这个) GPIO\\_Init(GPIOA, &amp;GPIO\\_InitStructure); } unsigned char KEY1_Scan(void){ static char key_up0=0;//按键按松开标志 if(KEY1==0) { Delay(10000);//延时去抖动 if(KEY1==0) { key_up0=1; } } if(KEY1==1&amp;&amp;key_up0==1) { key_up0=0; return 1; } return 0; } unsigned char KEY2_Scan(void){ static char key_up2=0;//按键按松开标志 if(KEY2==1) { Delay(10000);//延时去抖动 if(KEY2==1) { key_up2=1; } } if(KEY2==0&amp;&amp;key_up2==1) { key_up2=0; return 1; } return 0;} unsigned char KEY_Scan(void){ unsigned char key_code; if(KEY1_Scan()==1) key_code=1; else if(KEY2_Scan()==1) key_code=2; else key_code=0; return key_code;} int main(void){ int value=0; GPIO_Config(); Key_GPIO_Config();//配置按键 while(1) { value=KEY_Scan();//获取按键值 if(value==1) GPIO_WriteBit(GPIOE, GPIO_Pin_5, (BitAction)(1-(GPIO_ReadOutputDataBit(GPIOE, GPIO_Pin_5))));//LED灯PE5反转 else if(value==2) GPIO_WriteBit(GPIOE, GPIO_Pin_6, (BitAction)(1-(GPIO_ReadOutputDataBit(GPIOE, GPIO_Pin_6))));//LED灯PE6反转 }} 实现效果：PE4按下控制PE5灯反转，PA0按下控制PE6灯反转(亮、灭)。 按键中断(EXTI外部中断操作)#include “stm32f10x.h”void Delay(__IO u32 nCount) //简单的延时函数{ for(; nCount != 0; nCount–);} void GPIO_Config(void) //配置LED用到的PE5、PE6{ GPIO_InitTypeDef GPIO_InitStructure; //定义一个GPIO_InitTypeDef类型的结构体 RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOE, ENABLE); //开启GPIOE的外设时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6; //选择要控制的GPIOE引脚，这里选了PE5、PE6 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //设置引脚模式为：通用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //设置引脚速率为：50MHz GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //调用库函数，初始化GPIOE GPIO_SetBits(GPIOE, GPIO_Pin_5 | GPIO_Pin_6); //关闭所有LED灯} static void NVIC_Configuration(void)//NVIC(中断控制器)初始化配置，这里配PE4、PA0{ NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);//把NVIC中断优先级分组设为第1组 NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;//PE4对应EXTI线为EXTI4，填EXTI4_IRQn。(EXTI5~EXTI9使用同一中断向量，则填EXTI9_5_IRQn) NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;//抢占优先级2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//响应优先级1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure);//向寄存器写入参数 NVIC\\_InitStructure.NVIC\\_IRQChannel = EXTI0\\_IRQn;//PA0对应EXTI线为EXTI0，填EXTI0\\_IRQn NVIC\\_InitStructure.NVIC\\_IRQChannelPreemptionPriority = 2;//抢占优先级2 NVIC\\_InitStructure.NVIC\\_IRQChannelSubPriority = 2;//响应优先级2 NVIC\\_InitStructure.NVIC\\_IRQChannelCmd = ENABLE;//IRQ(中断请求)通道使能 NVIC\\_Init(&amp;NVIC\\_InitStructure);//向寄存器写入参数 } void EXTI_Config(void)//配置PE4、PA0为线中断口，并设置中断优先级{ GPIO_InitTypeDef GPIO_InitStructure; EXTI_InitTypeDef EXTI_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO,ENABLE);//配置中断线(PA0)时钟和第二功能AFIO时钟，AFIO指GPIO口的复用功能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO,ENABLE);//配置中断线(PE4)时钟和第二功能AFIO时钟 NVIC_Configuration();//配置NVIC中断控制器 //以下配PE4 GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_4; //选定要配置为EXTI线的gpio口和设置其工作模式 GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_IPU;//上拉输入 GPIO\\_Init(GPIOE, &amp;GPIO\\_InitStructure); //以下配PA0 GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_0;//选PA0 GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_IPD;//下拉输入 GPIO\\_Init(GPIOA, &amp;GPIO\\_InitStructure); //以下配PE4中断线、初始化配置 GPIO\\_EXTILineConfig(GPIO\\_PortSourceGPIOE, GPIO_PinSource4); //EXTI中断线(PE5)工作模式配置 EXTI\\_InitStructure.EXTI\\_Line = EXTI_Line4; EXTI\\_InitStructure.EXTI\\_Mode = EXTI\\_Mode\\_Interrupt; EXTI\\_InitStructure.EXTI\\_Trigger = EXTI\\_Trigger\\_Falling; //下降沿中断 EXTI\\_InitStructure.EXTI\\_LineCmd = ENABLE; EXTI\\_Init(&amp;EXTI\\_InitStructure); //以下配PA0中断线、初始化配置 GPIO\\_EXTILineConfig(GPIO\\_PortSourceGPIOA, GPIO_PinSource0); //EXTI中断线(PA0)工作模式配置 EXTI\\_InitStructure.EXTI\\_Line = EXTI_Line0; EXTI\\_InitStructure.EXTI\\_Mode = EXTI\\_Mode\\_Interrupt; EXTI\\_InitStructure.EXTI\\_Trigger = EXTI\\_Trigger\\_Rising; //上升沿中断 EXTI\\_InitStructure.EXTI\\_LineCmd = ENABLE; EXTI\\_Init(&amp;EXTI\\_InitStructure); } int main(void){ GPIO_Config();//LED(PE5、PE6)配置 EXTI_Config(); //外部中断EXTI配置，这里是选PE4、PA0 while(1)//等待中断 { }} 在stm32f10x_it.c中加入名为EXTI0_IRQHandler(void)和EXTI4_IRQHandler(void)函数： void EXTI0_IRQHandler(void){ Delay(10000);//延时消抖 if(EXTI_GetITStatus(EXTI_Line0) != RESET)//检查指定的EXTI0线路触发请求发生与否 { GPIO_WriteBit(GPIOE, GPIO_Pin_6, (BitAction)(1-(GPIO_ReadOutputDataBit(GPIOE, GPIO_Pin_6))));//控制LED的PE6翻转 } EXTI_ClearITPendingBit(EXTI_Line0);//清除EXTI0线路挂起位} void EXTI4_IRQHandler(void){ Delay(10000);//延时消抖 if(EXTI_GetITStatus(EXTI_Line4) != RESET)//确保是否产生了EXTI4 Line中断 { GPIO_WriteBit(GPIOE, GPIO_Pin_5, (BitAction)(1-(GPIO_ReadOutputDataBit(GPIOE, GPIO_Pin_5))));//控制LED的PE5翻转 } EXTI_ClearITPendingBit(EXTI_Line4);//清除中断标志位} 实现效果：PE4按下触发中断，控制PE5灯反转；PA0按下触发中断，控制PE6灯反转(亮、灭)。 串口打印(用USART1)#include “stm32f10x.h” #include “stdio.h”void Delay(__IO u32 nCount) //简单的延时函数{ for(; nCount != 0; nCount–);} int fputc(int ch, FILE *f)//重定向c库函数printf到USART1{ USART_SendData(USART1, (unsigned char) ch);//将Printf内容发往串口 while( USART_GetFlagStatus(USART1,USART_FLAG_TC)!= SET); return (ch);} void USART1_Config(unsigned int bound){ GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);//配置串口1时钟 //以下串口GPIO端口配置 //以下配置串口1的Tx(PA9)参数 GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_9;//PA9为Tx GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_AF_PP;//复用推挽输出 GPIO\\_InitStructure.GPIO\\_Speed = GPIO\\_Speed\\_50MHz; GPIO\\_Init(GPIOA, &amp;GPIO\\_InitStructure); //以下配置串口1的Rx(PA10)参数 GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_10; GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_IN_FLOATING;//浮空输入模式，Rx不需配Speed GPIO\\_Init(GPIOA, &amp;GPIO\\_InitStructure); //以下配置串口1的模式mode USART\\_InitStructure.USART\\_BaudRate = bound;//USART1的波特率 USART\\_InitStructure.USART\\_WordLength = USART\\_WordLength\\_8b;//串口传输的字长 USART\\_InitStructure.USART\\_StopBits = USART\\_StopBits\\_1;//停止位1位 USART\\_InitStructure.USART\\_Parity = USART\\_Parity\\_No;//不设置奇偶校验位 USART\\_InitStructure.USART\\_HardwareFlowControl = USART\\_HardwareFlowControl\\_None;//不用硬件流控制 USART\\_InitStructure.USART\\_Mode = USART\\_Mode\\_Rx | USART\\_Mode\\_Tx;//双线全双工。Rx、Tx都开启 USART\\_Init(USART1, &amp;USART\\_InitStructure);//向寄存器写入配置 USART_Cmd(USART1, ENABLE); //使能串口1 } int main(void){ int a=0; USART1_Config(115200); while(1) { printf(“\\r\\n Sandeepin poi %d \\r\\n”,a); a++; Delay(2000000); Delay(2000000); }} 实现效果：可在串口调试助手中看到Sandeepin poi 0、Sandeepin poi 1……等信息。 串口中断(用USART1)#include “stm32f10x.h” #include “stdio.h”void Delay(__IO u32 nCount) //简单的延时函数{ for(; nCount != 0; nCount–);} int fputc(int ch, FILE *f)//重定向c库函数printf到USART1{ USART_SendData(USART1, (unsigned char) ch);//将Printf内容发往串口 while( USART_GetFlagStatus(USART1,USART_FLAG_TC)!= SET); return (ch);} void USART1_Config(unsigned int bound){ GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);//配置串口1时钟 //以下串口GPIO端口配置 //以下配置串口1的Tx(PA9)参数 GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_9;//PA9为Tx GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_AF_PP;//复用推挽输出 GPIO\\_InitStructure.GPIO\\_Speed = GPIO\\_Speed\\_50MHz; GPIO\\_Init(GPIOA, &amp;GPIO\\_InitStructure); //以下配置串口1的Rx(PA10)参数 GPIO\\_InitStructure.GPIO\\_Pin = GPIO\\_Pin\\_10; GPIO\\_InitStructure.GPIO\\_Mode = GPIO\\_Mode\\_IN_FLOATING;//浮空输入模式，Rx不需配Speed GPIO\\_Init(GPIOA, &amp;GPIO\\_InitStructure); //以下配置串口1的模式mode USART\\_InitStructure.USART\\_BaudRate = bound;//USART1的波特率 USART\\_InitStructure.USART\\_WordLength = USART\\_WordLength\\_8b;//串口传输的字长 USART\\_InitStructure.USART\\_StopBits = USART\\_StopBits\\_1;//停止位1位 USART\\_InitStructure.USART\\_Parity = USART\\_Parity\\_No;//不设置奇偶校验位 USART\\_InitStructure.USART\\_HardwareFlowControl = USART\\_HardwareFlowControl\\_None;//不用硬件流控制 USART\\_InitStructure.USART\\_Mode = USART\\_Mode\\_Rx | USART\\_Mode\\_Tx;//双线全双工。Rx、Tx都开启 USART\\_Init(USART1, &amp;USART\\_InitStructure);//向寄存器写入配置 USART_Cmd(USART1, ENABLE); //使能串口1 USART\\_ITConfig(USART1, USART\\_IT_RXNE, ENABLE);//开启中断 } void NVIC_Configuration(void)//NVIC(中断控制器)初始化配置，这里配USART1{ NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);//把NVIC中断优先级分组设为第0组 //以下使能串口1中断 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//抢占优先级1 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//响应优先级0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ(中断请求)通道使能 NVIC_Init(&amp;NVIC_InitStructure);//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器USART1} int main(void){ USART1_Config(115200); NVIC_Configuration(); while(1) { Delay(2000000); }} 在stm32f10x_it.c中加入名为USART1_IRQHandler(void)函数： USART1_IRQHandler(void){ unsigned char code; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) { code=USART_ReceiveData(USART1); printf(“%c”,code);//将接受到的数据直接返回打印 }} 实现效果：在串口调试助手中输入一系列字符，STM32接收到后直接将收到字符原样打印出来。 定时器(用TIM3)#include “stm32f10x.h”void Delay(__IO u32 nCount) //简单的延时函数{ for(; nCount != 0; nCount–);} void LED_GPIO_Config(void){ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_5;//PE5、PE6 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//通用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOE,GPIO_Pin_5);//PE5初始输出高 GPIO_ResetBits(GPIOE,GPIO_Pin_6);//PE6初始输出低} void TIME_NVIC_Configuration(void)//TIM3中断优先级配置{ NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置NVIC中断分组2 NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; //TIM3中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占优先级0 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;//响应优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能 NVIC_Init(&amp;NVIC_InitStructure);//初始化外设} void TIME_Configuration(void){ TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //定时器TIM3时钟使能 TIM_TimeBaseStructure.TIM_Period = 5000; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值，计数到5000为500ms TIM_TimeBaseStructure.TIM_Prescaler =(7200-1);//设置用来作为TIMx时钟频率除数的预分频值 TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式 TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位 TIM_ITConfig(TIM3,TIM_IT_Update|TIM_IT_Trigger,ENABLE);//使能、失能指定的TIM中断 TIM_Cmd(TIM3, ENABLE);//使能TIMx外设} int main(void){ LED_GPIO_Config();//开LED的GPIO TIME_NVIC_Configuration();//TIM3定时器中断配置 TIME_Configuration();//TIM3定时器配置 while(1) { }} 在stm32f10x_it.c中加入名为TIM3_IRQHandler(void)函数： void TIM3_IRQHandler(void){ if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否 { TIM_ClearITPendingBit(TIM3, TIM_IT_Update ); //清除TIMx的中断待处理位 GPIO_WriteBit(GPIOE, GPIO_Pin_5, (BitAction)(1-(GPIO_ReadOutputDataBit(GPIOE, GPIO_Pin_5))));//控制LED灯PE5翻转 GPIO_WriteBit(GPIOE, GPIO_Pin_6, (BitAction)(1-(GPIO_ReadOutputDataBit(GPIOE, GPIO_Pin_6))));//控制LED灯PE6翻转 }} 实现效果：每隔500ms后LED灯PE5、PE6翻转 SysTick(系统滴答定时器)#include “stm32f10x.h”u32 TimingDelay; void LED_GPIO_Config(void){ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_5;//PE5、PE6 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//通用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOE,GPIO_Pin_5);//PE5初始输出高 GPIO_ResetBits(GPIOE,GPIO_Pin_6);//PE6初始输出低} void NVIC_Configuration(void){ NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断组为2 NVIC_InitStructure.NVIC_IRQChannel = SysTick_IRQn;//中断线 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //抢占优先级为2 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//响应优先级为0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //允许SysTick_IRQn中断 NVIC_Init(&amp;NVIC_InitStructure);} void SysTick_Init(void){ /* SystemFrequency / 1000 1ms中断一次 * SystemFrequency / 100000 10us中断一次，分析：ticks=SystemFrequency / 100000=720，T=ticks/f，f=72000000，T=720/72=10us * SystemFrequency / 1000000 1us中断一次/ while(SysTick_Config( SystemCoreClock / 1000));//Systick 配置延时nms。输入的参数为两个中断之间的脉冲数。} void Delay(u32 nTime)//用Systick延时{ TimingDelay = nTime; while(TimingDelay != 0);} int main(void){ SysTick_Init(); LED_GPIO_Config(); NVIC_Configuration();//中断配置 while(1) { GPIO_SetBits(GPIOE,GPIO_Pin_6); GPIO_ResetBits(GPIOE,GPIO_Pin_5); Delay(200);//Systick 配置延时200ms GPIO_SetBits(GPIOE,GPIO_Pin_5); GPIO_ResetBits(GPIOE,GPIO_Pin_6); Delay(200);//Systick 配置延时200ms }} 在stm32f10x_it.c中找SysTick_Handler(void)函数，填入如下内容： extern u32 TimingDelay;void SysTick_Handler(void){ if (TimingDelay != 0x00) { TimingDelay–; }} 实现效果：每隔200ms后LED灯PE5、PE6翻转。 TFTLCD显示(2.4寸液晶ILI9325)此部分代码复杂，参见我的另一篇文章《STM32操纵2.4寸液晶(ILI9325)》。 调用DS18B20温度传感器#include “stm32f10x.h” #include “stdio.h” //DS18B20-DATA引脚为PC2 #define DS18B20_DQ_OUT_Low GPIO_ResetBits(GPIOC,GPIO_Pin_2) //数据端口PC2 #define DS18B20_DQ_OUT_High GPIO_SetBits(GPIOC,GPIO_Pin_2) //数据端口PC2 #define DS18B20_DQ_IN GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_2) //数据端口PC2 void USART1_Config(void){ GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = 9600; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, &amp;USART_InitStructure); USART_Cmd(USART1, ENABLE);} int fputc(int ch, FILE *f){ USART_SendData(USART1, (unsigned char) ch); while( USART_GetFlagStatus(USART1,USART_FLAG_TC)!= SET); return (ch);} void Delay_us(u32 ntimes){ u32 flag; SysTick-&gt;LOAD=9*ntimes; //时间加载 SysTick-&gt;VAL=0; //清空计数器 SysTick-&gt;CTRL=0x00000001; //bit2清空,选择外部时钟HCLK/8, bit0位清空,开启倒计时 do { flag=SysTick-&gt;CTRL; } while(flag&amp;0x01&amp;&amp;!(flag&amp;(1&lt;&lt;16)));//等待时间到达 SysTick-&gt;CTRL=0;//关闭计数器} void DS18B20_GPIO_Config(void)//DS18B20的GPIO配置{ GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC, ENABLE );//使能PORTA口时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //SPI CS GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOC,GPIO_Pin_2);} void DS18B20_Mode_IPU(void)//使DS18B20-DATA引脚变为输入模式{ GPIO_InitTypeDef GPIO_InitStructure; //GPIO GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //SPI CS GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //复用推挽输出 GPIO_Init(GPIOC, &amp;GPIO_InitStructure); } void DS18B20_Mode_Out(void)//使DS18B20-DATA引脚变为输出模式{ GPIO_InitTypeDef GPIO_InitStructure; //GPIO GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //SPI CS GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //复用推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); } void DS18B20_Rst(void)//主机给从机发送复位脉冲{ DS18B20_Mode_Out(); //IO设置为推挽输出 DS18B20_DQ_OUT_Low; //产生至少480us的低电平复位信号 Delay_us(480); DS18B20_DQ_OUT_High; //在产生复位信号后，需将总线拉高 Delay_us(15);} u8 DS18B20_Answer_Check(void) //检测从机给主机返回的应答脉冲，从机接收到主机的复位信号后，会在15~60us后给主机发一个应答脉冲。0：成功1：失败{ u8 delay=0; DS18B20_Mode_IPU(); // 主机设置为上拉输入 //等待应答脉冲（一个60~240us的低电平信号 ）的到来 //如果100us内，没有应答脉冲，退出函数，注意：从机接收到主机的复位信号后，会在15~60us后给主机发一个存在脉冲 while (DS18B20_DQ_IN&amp;&amp;delay&lt;100) { delay++; Delay_us(1); } if(delay&gt;=100)//经过100us后，如果没有应答脉冲，退出函数 return 1; else delay=0; while (!DS18B20_DQ_IN&amp;&amp;delay&lt;240)//有应答脉冲，且存在时间不超过240us { delay++; Delay_us(1); } if(delay&gt;=240) return 1; return 0;} u8 DS18B20_Read_Bit(void) //从DS18B20读取一个位 返回值：1/0{ u8 data; DS18B20_Mode_Out(); DS18B20_DQ_OUT_Low; //读时间的起始：必须由主机产生 &gt;1us &lt;15us 的低电平信号 Delay_us(2); DS18B20_DQ_OUT_High; Delay_us(12); DS18B20_Mode_IPU();//设置成输入，释放总线，由外部上拉电阻将总线拉高 if(DS18B20_DQ_IN) data=1; else data=0; Delay_us(50); return data;} u8 DS18B20_Read_Byte(void)//从DS18B20读取一个字节 返回值：读到的数据{ u8 i,j,dat; dat=0; for(i=0; i&lt;8; i++) { j = DS18B20_Read_Bit(); dat = (dat) | (j&lt;&lt;i); } return dat;} void DS18B20_Write_Byte(u8 dat)//写一个字节到DS18B20{ u8 j; u8 testb; DS18B20_Mode_Out();//SET PA0 OUTPUT; for (j=1;j&lt;=8;j++) { testb=dat&0x01; dat=dat&gt;&gt;1; if (testb) { DS18B20_DQ_OUT_Low;// Write 1 Delay_us(10); DS18B20_DQ_OUT_High; Delay_us(50); } else { DS18B20_DQ_OUT_Low;// Write 0 Delay_us(60); DS18B20_DQ_OUT_High; ///释放总线 Delay_us(2); } }} u8 DS18B20_Init(void)//初始化DS18B20的IO口 DQ 同时检测DS的存在 返回1:不存在 返回0:存在{ DS18B20_GPIO_Config(); DS18B20_Rst(); return DS18B20_Answer_Check();} short DS18B20_Get_Temp(void)//从ds18b20得到温度值 精度：0.1C 返回值：温度值 （-550~1250）{ u8 flag; u8 TL,TH; short Temperature; float Temperature1; DS18B20_Rst(); DS18B20\\_Answer\\_Check(); DS18B20\\_Write\\_Byte(0xcc);// skip rom DS18B20\\_Write\\_Byte(0x44);// ds1820 start convert DS18B20_Rst(); DS18B20\\_Answer\\_Check(); DS18B20\\_Write\\_Byte(0xcc);// skip rom DS18B20\\_Write\\_Byte(0xbe);// convert TL=DS18B20\\_Read\\_Byte(); // LSB TH=DS18B20\\_Read\\_Byte(); // MSB if( TH&amp;0xfc) { flag=1; Temperature=(TH&lt;&lt;8)|TL; Temperature1=(~ Temperature)+1; Temperature1*=0.0625; } else { flag=0; Temperature1=((TH&lt;&lt;8)|TL)*0.0625; } return Temperature1; } int main(void){ USART1_Config(); while(DS18B20_Init())//初始化兼检测DS18B20 { printf(“DS18B20 Link ERROR \\r\\n!”); Delay_us(500000); } printf(“DS18B20 Link OK \\r\\n!”); while(1) { printf(“Temperature: %.2f \\r\\n”,DS18B20_Get_Temp()); Delay_us(500000); }} 实现效果：在PC2接温度传感器，通过串口1打印出温度值。","tags":[]},{"title":"STM32学习笔记：简介及MDK入门","date":"2016-04-08T03:30:15.000Z","path":"2016/stm32-study-mdk.html","text":"本文是Sandeepin学习《STM32库开发实战指南》所做的笔记，主要方便自己以后上手STM32方便，因此很多东西点到为止，如果想正式学STM32，还是推荐直接买书看，看本笔记难免有知识漏洞。本文适合临时上手用STM32的新手，或者对STM32想做大致了解的朋友。部分资料参考了《STM32自学笔记》及网上诸多文章，这里不一一列举了。顺便说说，我用的板子是STM32F103ZET6，因此文中提到的文件配置及以后笔记中的例程均在此平台下跑通。 STM32基础编程语言：C、C++、Java 嵌入式平台：ARM、MIPS、DSP 协议：USB、TCP/IP、SPI、I2C 操作系统：实时μC/OS、非实时Linux STM32：Cortex-M3内核，有外设ADC、串口UART、定时器TIM等。 CMSIS标准(Cortex Microcontroller Software Interface Standard)，实际是新建了一个软件抽象层。 STM32库编程：Libraries文件夹下是驱动库的源代码及启动文件。 主要文件简介 core_cm3.c文件：作用是为采用Cortex-M3核设计SoC的芯片商设计的芯片外设提供一个进入CM3内核的接口。 system_stm32f10x.c文件：该文件的功能是设置系统时钟和总线时钟。我们还要通过CM3核的核内寄存器来对8M的时钟进行倍频、分频，或者使用芯片内部的时钟。所有的外设都与时钟的频率有关。 stm32f10x.h文件：它包含了STM32中寄存器地址和结构体类型定义，在使用到STM32固件库的地方都要包含这个头文件。 启动文件：Libraries\\CMSIS\\Core\\CM3\\startup\\arm文件夹下是由汇编语言编写的系统启动文件，不同的文件对应不同的芯片型号。文件名的英文缩写的意义如下： xl：超高密度（容量）产品，stm32f101/103系列。 hd：高密度产品，Flash大于128KB。 启动文件的作用：启动文件是任何处理器在上电复位之后最先运行的一段汇编程序。初始化堆栈指针SP。初始化程序计数器指针PC。设置堆、栈的大小。设置异常向量表的入口地址。配置外部SRAM作为数据存储器（这个由用户配置，一般的开发板没有外部SRAM）。设置C库的分支入口__main。 STM32F10x_StdPeriph_Driver文件夹：Libraries\\STM32F10x_StdPeriph_Driver文件夹下有inc（include的缩写）和src（source的缩写）这两个文件夹，这都属于CMSIS的设备外设函数部分。如针对模数转换（ADC）外设，在src文件夹下有一个stm32f10x_adc.c源文件，在inc文件夹下有一个stm32f10x_adc.h头文件，若我们开发的工程中用到了STM32内部的ADC，则至少要把这两个文件包含到工程里。这两个文件夹中还有一个很特别的misc.c文件，这个文件提供了外设对内核中的NVIC（中断向量控制器）的访问函数，在配置中断时，我们必须把这个文件添加到工程中。 stm32f10x_it.c和stm32f10x_conf.h文件：在库目录的Project\\STM32F10x_StdPeriph_Template目录下，存放了官方的一个库工程模板，我们在用库建立一个完整的工程时，还需要添加这个目录下的stm32f10x_it.c、stm32f10x_it.h和stm32f10x_conf.h这三个文件。stm32f10x_it. c是专门用来编写中断服务函数的。stm32f10x_conf. h文件被包含进stm32f10x.h文件，是用来配置使用了什么外设的头文件，用这个头文件我们可以很方便地增加或删除上面Driver目录下的外设驱动函数库。 MDK入门：新建工程教程：MDK这里用的版本是V4.12，在新建工程文件夹中，新建5个文件夹，分别为USER、FWlib、CMSIS、Output、Listing。 USER用来存放工程文件和用户层代码，包括主函数main.c。 FWlib用来存放STM32库里面的inc和src这两个文件夹，这两个文件包含了芯片上的所有驱动，这两个文件夹下的文件我们不需要修改。 CMSIS用来存放库为我们自带的启动文件和一些位于CMSIS层的文件。 Output文件夹用来保存软件编译后输出的文件。 Listing用来保存编译后生成的链接文件。 把库\\Libraries\\STM32F10x_StdPeriph_Driver文件夹下的inc跟src这两个文件夹复制到FWlib文件夹中。 把库文件夹Project\\STM32F10x_StdPeriph_Template下的main.c、stm32f10x_conf.h、stm32f10x_it.h和stm32f10x_it.c复制到USER目录下。 将库文件\\Libraries\\CMSIS\\CM3文件夹下的全部文件复制到CMSIS文件夹中。Startup\\arm里面把startup_stm32f10x_hd.s启动文件添加到我们的工程中。system.stm32f10x.h、system.stm32f10x.c、stm32f10x.h这几个位于CMSIS层的文件也是放到CMSIS文件夹中。 回到我们的工程中，选中Target右键选中Add Group选项新建4个组，分别命名为STARTCODE、USER、FWlib、CMSIS。 在STARTCODE组里面添加startup_stm32f10x_hd.s启动文件。 在USER组里面添加main.c和stm32f10x_it.c这两个文件。 【待补充】 在Define文本框里面添加两个宏定义：USE_STDPERIPH_DRIVER, STM32F10X_HD, 在建立工程时需要注意的是： 1）因为我们用的是ST官方的新版本库，与编译器自带的库会存在不兼容性，所以我们需要修改库的搜索路径。 2）这个工程我们是设置成软件仿真，如果是用开发板加J-LINK调试的话，还需要在开发环境中做修改。 编译按钮说明：Translate按钮：就是编译当下修改过的文件，即检查一下有没有语法错误，既不链接库文件，也不会生成可执行文件。 Build按钮：就是编译当下修改过的工程，它包含了语法检查、链接动态库文件、生成可执行文件。 Rebuild按钮：即重新编译整个工程，与Build这个按钮实现的功能是一样的，但有所不同的是它是重新编译整个工程的所有文件，耗时巨大。 下载方式：1.J-LINK下载：MDK工具栏中的Load按钮就可将编译好的程序下载到开发板的Flash。 2.串口下载：1）给开发板供电（DC5V），拔掉J-LINK，插上串口线（注意是两头都是母的交叉线），接的是串口1，串口2是下载不了程序的，再将BOOT0接到VCC。 串口下载软件是mcuisp。 设置波特率为115200。可执行文件（hex文件）都在工程目录下Output这个文件下。 流水灯例程分析：想要控制LED灯，当然是通过控制STM32芯片的I/O引脚电平的高低来实现。 在STM32芯片上，I/O引脚可以被软件设置成各种不同的功能，如输入或输出，所以又被称为GPIO（General-Purpose I/O）。 而GPIO引脚又被分为GPIOA、GPIOB、……、GPIOG不同的组，每组端口分为0～15共16个不同的引脚，对于不同型号的芯片，端口的组和引脚的数量不同。 控制LED的步骤就自然整理出来了： 1）GPIO端口引脚多——就要选定需要控制的特定引脚。 2）GPIO功能如此丰富——配置需要的特定功能。 3）控制LED的亮和灭——设置GPIO输出电压的高低。 要控制GPIO端口，就要涉及控制相关的寄存器。 寄存器可以分为以下4类，其功能简要概括如下： 1）配置寄存器：选定GPIO的特定功能，最基本的如选择作为输入还是输出端口。 2）数据寄存器：保存了GPIO的输入电平或将要输出的电平。 3）位控制寄存器：设置某引脚的数据为1或0，控制输出的电平。 4）锁定寄存器：设置某锁定引脚后，就不能修改其配置。 关于寄存器名称如GPIOx_CRL、GPIOx_CRH上的标号x，其取值可以为图中括号内的值（A……E），表示这些寄存器也跟GPIO一样，是分组的。 端口配置高寄存器（GPIOx_CRH）:其中x=A~E CNFy[1:0]位，其中 y=8~15：在输入模式时MODE=00： 00 模拟输入 01 浮空输入模式（复位后的状态） 10 上拉、下拉输入模式 11 保留 MODE&gt;00时： 00 通用推挽输出模式 01 通用开漏输出模式 10 服用功能推挽输出模式 11 服用开漏输出模式 MODEy[1:0]位，其中y=8~15： 00 输入模式（复位后的状态） 01 输出模式，最大10MHz 10 输出模式，最大2MHz 11 输出模式，最大50MHz 举例说明对CRH寄存器的配置：当将GPIOx_CRH寄存器的第28至29位设置为参数“11”，并将第30至31位设置为参数“00”时，则把x端口第15个引脚的模式配置成了“输出的最大速度为50MHz的通用推挽输出模式”， 端口位设置、清除寄存器（GPIOx_BSRR）,其中x=A~E: 位数31~16：清除端口x的位，0表示对应位不产生影响。1表示清除对应位为0。 位数15~0：设置端口x的位，0表示对应位不产生影响。1表示设置对应位为1。 同时设置了清除、设置，设置优先。 例如：对x端口的寄存器GPIOx_BSRR的第0位（BS0）进行写1，则x端口的第0引脚被设置为1，输出高电平，若要令第0引脚再输出低电平，则需要向GPIOx_BSRR的第16位（BR0）写1。 地址映射： Cortex-M3有32根地址线，所以它的寻址空间大小为2^32 bit=4 GB。ARM公司设计时，预先把这4 GB的寻址空间大致地分配好了。它把从0x40000000至0x5FFFFFFF（512 MB）的地址分配给片上外设。 以后我们写代码的时候，如果要修改GPIO的寄存器，就可以用如下的方式来实现。 GPIO_TypeDef*GPIOx；//定义一个GPIO_TypeDef型结构体指针GPIOx GPIOx=GPIOA；//把指针地址设置为宏GPIOA地址 GPIOx-＞CRL=0xffffffff；//通过指针访问并修改GPIOA_CRL寄存器 但这只是库开发的皮毛，而且实际上我们并不是这样使用库的，库为我们提供了更简单的开发方式。 STM32的时钟系统STM32芯片为了实现低功耗，设计了一个功能完善但却非常复杂的时钟系统。普通的MCU一般只要配置好GPIO的寄存器就可以使用了，但STM32还有一个步骤，就是开启外设时钟。 从时钟频率来说，又分为高速时钟和低速时钟，高速时钟是提供给芯片主体的主时钟，而低速时钟只是提供给芯片中的RTC（实时时钟）及独立看门狗使用。从芯片角度来说，时钟源分为内部时钟与外部时钟源，内部时钟是由芯片内部RC振荡器产生的，起振较快，所以时钟在芯片刚上电的时候，默认使用内部高速时钟。而外部时钟信号是由外部的晶振输入的，在精度和稳定性上都有很大优势，所以上电之后我们再通过软件配置，转而采用外部时钟信号。 STM32有以下4个时钟源： 1）高速外部时钟（HSE）：以外部晶振作为时钟源，晶振频率可取范围为4～16 MHz，我们一般采用8 MHz的晶振。 2）高速内部时钟（HSI）：由内部RC振荡器产生，频率为8 MHz，但不稳定。 3）低速外部时钟（LSE）：以外部晶振作为时钟源，主要提供给实时时钟模块，所以一般采用32.768 kHz。配套STM32实验板上用的是32.768 kHz、6p负载规格的晶振。 4）低速内部时钟（LSI）：由内部RC振荡器产生，也主要提供给实时时钟模块，频率大约为40 kHz。 GPIO外设是挂载在APB2总线上的，APB2的时钟是APB2预分频器的输出，我们就可以得到GPIO外设的时钟也等于HCLK，即72 MHz。 与我们开发密切相关的时钟： 1）SYSCLK：系统时钟，是STM32大部分器件的时钟来源。 2）HCLK：","tags":[]},{"title":"iDevise主题修改备忘","date":"2016-04-02T03:27:26.000Z","path":"2016/idevise-note.html","text":"为了使iDevise主题更适合异想博客的需要，我将对主题部分功能进行增添修改。大多数修改都可通用于其它主题，但部分修改只是为了满足个人偏好，也许会感觉比较无聊。对于一些简单的修改就几句话说明了，涉及代码的将会分点列出。 一些简单修改：去掉了更新(感觉iDevise_16.03.13版本的特效比较合意)、删掉了搜索Button(回车以搜索)、改了底部信息。 1、文章段落首行缩进、改段内间距一般主题可用Chrome审查元素找到段落对应的CSS，加入： text-indent:2em;line-height: 26px; 即可，例如iDevise主题设置： .single p{margin:0 0 10px;text-indent:2em;line-height: 26px;} 2、图片清晰指向变模糊在index.php的头部找个地方加入以下代码： // &lt;![CDATA[ $(function () { $(&apos;img&apos;).hover( function() {$(this).fadeTo(&quot;fast&quot;, 0.5);}, function() {$(this).fadeTo(&quot;fast&quot;, 1); }); }); // ]]&gt; 3、删除评论提示语句其实这是对Wordpress修改，没涉及主题。我的博客打算只开放留言页面评论，其它的文章都关闭评论功能，但是底部会显示“评论已关闭”，所以去掉文字提示。 用Poedit软件打开wp-content\\languages\\zh_CN.po文件，找到“Comments are closed.”条目，翻译内容删掉，加入一个全角的空格(这样显示出来什么也没有)，保存编译为mo文件，上传到服务器。 4、禁用Google Open Sans字体在functions.php文件中加入以下代码： add_filter( ‘gettext_with_context’, ‘wpdx_disable_open_sans’, 888, 4 );function wpdx_disable_open_sans( $translations, $text, $context, $domain ) { if ( ‘Open Sans font: on or off’ == $context &amp;&amp; ‘on’ == $text ) { $translations = ‘off’; } return $translations;} 5、更改新的文章结束样式移植官方2016年4月15日设定的样式，占用位置更小更美观。 在style.css中粘贴新主题的代码替换旧主题中对应的位置： /* 文章结束 /.ending{display:block;width:100%;height:60px;margin:30px 0;border-top:1px dashed #ddd;border-bottom:1px dashed #ddd;position:relative;}/\\ 赏赐 /.reward{width:30px;height:30px;line-height:30px;font-size:18px;color:#fff;border-radius:100px;text-align:center;position:relative;border:1px solid #f1b60e;background:#fccd60;cursor:pointer;position:absolute;left:66px;top:14px;}.reward ul{z-index:1;display:none;position:absolute;top:-60px;right:-280px;padding:6px;font-size:13px;width:260px;height:150px;background:#fff;border:1px solid #e6e6e6;box-shadow:0 1px 1px 1px #efefef}.reward ul:after,.reward ul:before {position:absolute;content:’’;border:10px solid transparent;top:50%;left:-20px;margin-top:-10px;}.reward ul:before{left:-21px;border-right-color:#e6e6e6;}.reward ul:after{border-right-color:#fff;}.reward:hover ul{display:block}.reward ul li{display:inline-block;width:48%;padding:10px;color:#333;line-height:20px;}/\\ 简介 /.about{position:relative;position:absolute;left:20px;top:14px;}.about img{width:30px;height:30px;border-radius:100%;border:1px solid #ccc;cursor:pointer;}.about p{z-index:1;display:none;position:absolute;top:-8px;right:-280px;padding:10px;font-size:13px;line-height:26px;width:260px;background:#fff;border:1px solid #e6e6e6;box-shadow:0 1px 1px 1px #efefef}.about p:after,.about p:before {position:absolute;content:’’;border:10px solid transparent;top:12px;left:-20px;}.about p:before{left:-21px;border-right-color:#e6e6e6;}.about p:after{border-right-color:#fff;}.about:hover p{display:block}/\\ 社交 */.sns{margin:0 10px;float:right}.sns li{float:left;margin:0 10px;}.sns li i{line-height:56px;}.sns li.weibo i{color:#d55}.sns li.tencent i{color:#3cf}.sns li.douban i{color:#5a7}.sns li.zhihu i{color:#2ae}.sns li.github i{color:#000;line-height:58px;} 然后还要删掉index.php中的两句： 若你觉得我的文章对你有帮助,欢迎点击上方按钮对我打赏 &lt;?php the_author_meta(‘display_name’);?&gt; 原效果如上，改动后如下。 6、博客头部加下拉进度条此处参考了奇拉笔记的代码，在style.css中添加如下代码，不要放到文件太后面了，最好放在“初始化”之后，“页头”之前： /* 横向下拉进度条 */.scroll-bar {position: fixed;top: 0;left: 0;z-index: 4500;display: none;width: 0;height: 2px;background: #000;} 在functions.js里的$(window).scroll(function(){});里加入如下代码，具体插入位置见图： $(“.scroll-bar”).attr(“style”,”width:”+($(this).scrollTop()/($(document).height()-$(this).height())*100)+”%;display: block;”); 在index.php里加入如下代码，最好放在header到/header之间： 最终效果如图： 7、WordPress后台雅黑字体将下面代码添加到当前主题functions.php中即可： function admin_lettering(){ echo’ body{ font-family: Microsoft YaHei;} ‘; }add_action(‘admin_head’, ‘admin_lettering’); 8、字体","tags":[]},{"title":"poilife开张第一篇","date":"2016-04-01T03:24:27.000Z","path":"2016/kaizhangdiyipian.html","text":"去年就看到ifamec折腾阿里云服务器和域名备案，可惜自己当时要考研，因此想在国内买服务器及办个备案的域名的愿景直至今年才实现。考研的结果出来了，初试复试的流程也走完了，尽管接来下的日子仍是或者说甚至是比本科时代还要繁忙，但些许的休憩还是有的，于是借着空闲的时光，构成了本博客的由来。 本来ifamec推荐自己买阿里云服务器ECS的学生优惠型号，想到自己现在已经是大四下的学生，优惠也持续不了不久，虽然读研，但讨厌各种琐碎的麻烦的步骤，再说也并不想把服务器与自己的学生身份绑定，故最终选择了阿里云的弹性Web托管，200左右一年，贵了些，但我建立博客的初衷就是想安静写博，记录学习与生活，因此这样的选择不如说恰到好处，毫发不爽。 关于我，可以在博客的“关于”页面获得详尽的信息，我的新浪微博、QQ、豆瓣及GitHub账号在每篇文章的末尾都有标注。域名选择的是poilife.com，因为我很喜欢《舰队Collection》中夕立的口头禅poi，但我最喜欢的舰娘角色却是金刚，喜欢她充满灵性的个性，所以我设她作为头像。我的网名叫做异想家，英文名常用Sandeepin，故本博客起名异想博客，主要分享些编程学习笔记，记录些问题解决过程，评论些小说电影，推荐些好用软件，发布些原创作品，等等等等。这是我有意义的积极的生活博客，我是一位不愿传染给他人忧伤悲苦的人，在这里不会有肮脏的内容，在这里也不会有恶毒的言辞，因此我不打算开放所有文章的评论功能，但也不愿闭目塞听，言论依然自由——我提供了“留言”页面。估计个人小博客也不会有大量的人访问吧，只在一个页面留言，用于交流足矣。 博客的主题选择的是Tokin制作的iDevise，后期自己也做了不少修改，选择这款主题的原因是喜欢其简练的响应式设计和PJAX加载方式，估计自己将长久使用这款主题了。当然随着时间的流逝，人会变，人变了什么就变了，因此也不敢对博客的未来做什么深远的计划。不过变化的事物也就是发展的事物，慢慢打磨的异想博客定会更加精致吧。","tags":[]},{"title":"异想家计算器2","date":"2014-09-03T11:58:36.000Z","path":"2014/yixiangjiajisuanqi2.html","text":"之前我写了异想家计算器最初版本(1.0)，实现了简单的加减乘除混合运算和复数运算。暑假在家没事，断断续续地花了一个月写了异想家计算器2.0版本，扩展了很多新功能，重新设计了面板输入方式，更正了软件的一些错误。 异想家计算器2.0在常规计算中增加了更多常用函数、变量赋值、函数计算等功能，方便使用，可进行更复杂的计算。复数运算模块与1.0版本相比，支持更多的运算功能，并修复了原先的某些计算错误。此外软件增加了矩阵运算、大数运算、方程求解模块，使软件更适合科学工作者、学生、教师使用，达到事半功倍的效果。 使用本程序需要安装.Net Framework 4以上的版本(Win8自带)，请到微软官方网站进行升级或选择软件管家之类进行升级。 本软件是我的编程学习之作，不足之处欢迎大家批评指正！我的邮箱：sandeepin@qq.com，也可在本页留言。 软件详细功能介绍见下文使用帮助部分。 软件主界面 使用帮助常规运算1、在此面板下输入help()（不区分大小写，也可Help()，下文同）可查看帮助，并例举出支持的函数。输入about()可查看关于信息。输入clear()可清空面板。 2、程序支持加、减、乘、除、正弦、余弦等函数的混合运算。其中Pi=3.14159265358979，E=2.71828182845905。 例：5_(4/27-3)+18_sin(Pi/6) 结果：-5.25925925925926 例：3^3 结果：27 例：2^(0.5) 结果：1.4142135623731 3、变量赋值、函数功能： 例：依次输入x:=5，回车，输入f(x):=sin(x)/cos(x)，回车，输入f(x)，回车。 显示结果：-3.38051500624659 4、字符串功能： 例：”异想家” &amp; “计算器” 结果：异想家计算器 例：Len(“sandeepin”) 结果：9(字符串长度) 5、布尔运算： 例：true != false 结果：True 例：If(5 &gt; 6;”大于”;”不大于”) 结果：不大于 例：5 &gt; 6 ? “大于” : “不大于” 结果：不大于 6、递归运算： 输入：fac(n) := (n = 0) ? 1 : fac(n-1)*n，回车，输入fac(5)，回车。 结果：120 (即计算5_4_3_2_1=120) 7、函数功能详解(函数、功能、举例)： 数学运算： Sqr平方 Sqr(3)Sqrt 开方 Sqrt(2)Sin 正弦 Sin(3) Cos余弦 Cos(3)Asin 反正弦Asin(0.5) Acos反余弦Acos(0.5) Atan 反正切 Atan(3) Sinh 双曲正弦 Sinh(2)Cosh双曲余弦 Cosh(3) Exp 自然指数Exp(3)Ln 自然对数 Ln(2) Log 对数 Log(2;8) Pow 次幂 Pow(2;3) 数学函数： Abs 绝对值 Abs(-3) 3 Ceiling 向上舍入Ceiling(1.8) 2 Avg 平均值 Max 最大数 Min最小数 ###Mid中间数 Floor 返回小于指定数最大整数 Floor(2.2) 2 Round 四舍五入 Round(1.52) 2 Sign 符号函数 Atan2 返回给定的 X 及 Y 坐标值的反正切值 进制转换： Hex 十进制转十六进制 字符串： Lower 大写字母转换为小写字母Lower(“JFREKERF”)jfrekerf Upper 小写字母转换为大写字母 Left 左边数输出Left(64564324234235;4) 6456 Right 右边数输出Right(64564324234235;4) 4235 Len 字符串长度 布尔运算： And 与 and(1;1) True Or 或or(0;1) True Not 非 Not(0) True If 如果 If(5 &gt; 6;”大于”;”不大于”) 不大于 复数运算 输入复数Z1、Z2，点击相应功能即可。 矩阵运算 矩阵运算的结果用的是分数表示，但含有复杂分数的矩阵求逆矩阵时可能出错，设置数据时最好不要太大。 大数运算 点击相应功能即可运算，注意计算A^B(A的B次幂)时，B不要太大，否则可能程序出错或系统死机。 方程求解 输入系数即可解方程。一元多次方程支持复数根。多元一次方程只支持实数，元数不要超过8，否则见面会显示不全。 软件更新2014-9-3：v2.0 点击下载","tags":[{"name":"原创软件","slug":"原创软件","permalink":"http://blog.jfz.me/tags/原创软件/"}]},{"title":"我常用的Chrome扩展插件","date":"2014-08-03T14:52:01.000Z","path":"2014/chrome-extensions.html","text":"最近国产的各大第三方Chrome核浏览器都放出了更新了内核的版本，爱折腾的Sandeepin于是下载了各种浏览器捣腾。很多浏览器要用着顺手必须加上各类扩展插件才行，但是Google访问极不稳定，下个扩展总要越沟实在麻烦，各大浏览器厂商的自配商店应用又不全，所以写下这篇文章，一是向网友推荐自己喜爱的浏览器扩展，二是方便自己下载所需。 Adblock Plus Adkill and Media Download Chrome YouTube Downloader doubanIMDb Proxy SwitchySharp Speeddial2 中文版 SSLspeedy2 User Agent View Image Info Windows Media Player Extension for HTML5 下电影 下载一键通 右键搜 图片搜索(&amp;A) 微博洗刷刷 新同文堂 有道智能翻译 百度音乐助手 豆瓣电影搜索 异想圣域专版 购物党 非常助手(VeryHelper)","tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://blog.jfz.me/tags/Chrome/"}]},{"title":"折腾铁威马F2-NAS2增强版","date":"2014-07-29T13:56:17.000Z","path":"2014/terra-master-f2-nas2.html","text":"今天买的铁威马F2-NAS2增强版到手，配上自己前段时期买的西数4T红盘，Sandeepin开始了自己的NAS时代。 NAS说得通俗点就是网络存储器，能将自己的照片和电影存到服务器，用不同的设备访问。我下了很多动漫、电影，有时在手机上看，有时在电脑上看，这样一个文件常要拷几遍。特别是放在电脑里的文件，文件夹建了一层又一层，久了之后，重复的文件懒得整理，几T的硬盘就这样塞满了。 我入手NAS的初衷就是这个，想建一个自己的影音文件合集，所有的影音文件存在服务器上，自己想看就从上里面取，源文件不动，自己手机、电脑里看完就删，这样既能珍藏文件，又能节约空间，文件毫不凌乱。至于备份文件之类，NAS倒不是我的首选，我更习惯于放在移动硬盘里，不想让自己的私有文件总挂在服务器上，虽然在自己家里，隐私问题不用太担心，但寿命就不好说了。 铁威马F2-NAS2增强版的配置(增强版内存为1G)： 安装一直下一步，设置好后就能进入系统，进入系统立马刷最新的2.4版本，各种功能捣鼓。 客户端如图，感觉没什么用，就是几个链接的快捷方式： 放几张系统的截图： 怎么说呢，买之前对比过群晖(Synology)、威联通(QNAP)等其它品牌的NAS，铁威马(TerraMaster)的强项在于做工，系统功能真心比不上其它两家。 功能不多，但也够折腾了。这次本来就是初入NAS，主要是学习，功能也够用，F2-NAS2增强版不能说很低端，但在大环境下比，算是入门型机子。 接来下介绍几个我想折腾的功能： 一、FTP功能设置如图： 在FlashFXP设置、连接如图： 传输速度不算快，我没有千兆路由，所以只有5MB/s左右，但单独的千兆LAN口路由较贵，下次还是买个交换机算了。 二、网站服务器 演示一个探针，搭建Wordpress的方法还在研究中。 三、迅雷远程下载先激活： 测试远程下载： 速度还行。此外还有PT下载，这是私有服务器的BT下载，我不玩这个，不知怎么弄，就不测试了。 四、在线云服务铁威马提供云服务可随时访问，在外网也可以操作NAS，传输文件。 五、在线播放电影电脑端、手机端都可以在线看视频。输入文件的地址，复制到播放器里就可在线看了，测试播放不卡，拖动有些迟缓。以下为Potplayer播放的效果，手机端就不演示了。 此外还有各种协议的传输、播放功能，我都不懂，还得慢慢折腾。 总之呢，还算满意，我说过2014年给我带来最具幸福感的产品就是铁威马F2-NAS2增强版了，真正使用后，总觉得还是有些不爽，也不能说产品很差，反正就这样了。幸福感可能来源于第一次接触NAS这种东西吧，产品本身带来的幸福可能没有想象得大。传输文件我比较习惯传统的FTP，有这项功能，用着倒也满足了。图个新鲜，玩玩，就当多学些网络知识了。","tags":[{"name":"硬件","slug":"硬件","permalink":"http://blog.jfz.me/tags/硬件/"}]},{"title":"Ubuntu和Win7双系统安装图解","date":"2014-07-11T12:34:14.000Z","path":"2014/ubuntu-win7-install.html","text":"本文转自PCBeta远景论坛，原贴地址点这里，为与本博客的排版更契合，稍有改动。 Ubuntu是一个操作系统，和安卓一样同是linux内核下的子民，所以来这贡献一下，也求JW放出安卓4.0原生正式版，我只想要这个。前几天发布了Ubuntu 12.04 LTS 版本，兴奋中…… 看到网上挺Ubuntu的很多，搞了个安装方法给那些害怕乱弄把硬盘全格的盆友们。也是我用了那么久Ubuntu，对它的小小贡献吧。图片是M9拍的，有艺术细胞吧？ 的确可以用wubi安装，wubi安装就像一个程序一样装在windows文件系统之上。用WUBI安装Ubuntu的缺点： 1、一休眠或挂起就会死机，不能从休眠或挂起状态恢复，只能强行关机然后重启。因为休眠和待机需要使用FUSE和基于文件的交换。建议用Ubuntu Tweak禁用休眠和挂起功能。 2、如果安装分区以外的分区也有名为“Ubuntu”的文件夹的话，卸载时可能会把其它分区的Ubuntu文件夹误删除，所以建议不要在安装分区以外的分区自行建立名为“Ubuntu”的文件夹。 3、删除Windows分区里的文件时不能使用回收站，会被直接删除。 4、用Live CD启动不能访问虚拟分区里的文件。一旦系统崩溃，文件可能无法取回！建议把所有个人文件都存放到Windows分区中。 5、进入在Windows里安装的Ubuntu时，如果突然断电的话，系统很容易崩溃，因为这样安装的Ubuntu系统会被当作是Windows系统下的一个文件，断电时这个文件会受损，启动或运行就会不正常了。 所以如果你和我一样最求极致纯正，那么就按照我的方法吧。其实不麻烦，让我装半个钟可以搞定。只是说了挺多基础的东西。 言归正传。 你需要的东西有： 1，Ubuntu系统镜像，官方下载地址(推荐到官网下载最新版本) Ubuntu Desktop 12.04 32位 点击下载 Ubuntu Desktop 12.04 64位 点击下载 选64位吧，兼容性好些。 2，空闲的大于10G硬盘空间，多多益善，我用了50G。 3，刻录镜像用的至少有1G大小的空白U盘或光碟。如果电脑支持usb设备启动就选择U盘吧，否则只能用光碟。 4，EasyBCD, 因为Ubuntu引导和win7不同，别用Ubuntu的引导来启动win7,你会后悔的。下载后在windows里直接装好。 开始安装旅程： 1.给硬盘划分空白空间安装Ubuntu,如果你不是用Windows home版本的话，不需要工具，开始菜单——右键点击我的电脑——管理——存储——磁盘管理（本地），这个大小个人使用情况决定的，我用70GB来装Ubuntu 那么单击E盘，右键选择“压缩卷” 然后在弹出的窗口里的“输入压缩空间量”输入70000，然后一直下一步直到结束。 2.刻录Ubuntu镜像到你的U盘或者光碟，可以用ultraISO（软碟通）刻录进U盘，怎么刻录自己去百度。光碟刻录win7自带的就行。 3.重启电脑，和安装windows一样，调整成光驱启动或者USB设备启动，插入你的U盘或者光碟正常情况出现以下的图图： 这时候请在键盘上随便按个键，空格啥的。 然后选择语言“简体中文”。 选择安装Ubuntu。 在这里面要注意一点，有的独立显卡在选择安装Ubuntu后，会出现花屏或者黑屏无法进入安装界面。 在选择安装Ubuntu后先不要按回车，先按F6在按下ESC，然后光标移到splash后面，删除那个– 在splash后面留一空格，然后输入nomodeset在按回车。 注意下面这二张图片的区别： 又是选择中文，继续。 然后这一步如下图：请勾选最后个选项（安装这个第三方软件），不要勾选安装中下载更新，那速度很慢的。 这一步很重要了，某些朋友抹盘就是选了第一个吧？请选择第三个。 在打开的磁盘管理里我们看到之前压缩的空间，前边有“空闲”二字，我们要做的就是：在这个空闲的空间里给Ubuntu划分分区，我习惯上是这么划分的：引导分区“/boot”200M足够了,系统分区“/”装系统和软件30GB够用了，交换分区“swap”类似windows的虚拟内存，一般不大于物理内存就行。个人文件分区“/home”你想多大就多大，类似windows的“我的文档”。 点选“空闲“的分区，选择下边的“添加” 弹出窗口，上边填写分区空间大小，下边填写要挂载的分区，然后确定。”/“分区，”/home“分区都是这样子创建，而swap分区要在“用于”那里选择“交换分区”。 把分区设置好了，下边这步很关键！！！ 首先在上边看你创建的”/boot“分区的编号是什么，比如我的是sda7 （你的可能不是sda7,可能是sda5，sda6等等，取决于你的/boot分区编号），那么在下边的”安装启动引导区的设备“下拉选项框选择”sda7“,如果这步忽略了，你就用了Ubuntu系统来引导Windows了。 注意看下面这二张图的区别： 做完这些，你可以安心下一步了，以下无非是用户名密码这些。linux一定要设置密码的。 装完移除U盘重启，你会发现直接进入你的Windows系统，因为我们把它的引导搞到/boot分区了。我们要用EasyBCD 来给它创建启动时候的选择系统是Windows还是Ubuntu这个很简单。 打开easyBCD，选择add new entry, 选择linux/BSD, name这一行随便填写，只是系统名词，写Ubuntu吧，Device这一行选择刚刚我们创建的200MB的那个”/boot“分区,前边有linux标记的。如下图，EasyBCD很强大，不懂的别乱搞，搞坏MBR别怪我。 这里注意一点，有的人反应会不能引导，经本人测试是GRUB的问题，症状是选择UBUNTU引导就黑屏，只能看到左上角有个光标在闪，在下面这张图片里的第二到第三步的中间那个类型里选择GRUB 2可以解决： 做完这些重启系统，选择Ubuntu,正常的应该都能进入Ubuntu系统了。That’s all. 当你不要Ubuntu的时候，直接在window里磁盘管理删了它所在的分区，然后在Easybcd里删了它的引导就行，不影响你的Windows系统，这就是为啥我不用Ubuntu来引导Windows的原因。 网友cxbii建议：不建议单独分／boot啊。如果分了可能对重装不好啊我就分／、／home、swap，准备把swap也不分了。不是笔记本，休眠没什么用。 网友jinjin6736建议：不单独分／boot的话，就会用UBUNTU来引导WINDOWS7了，那样你会后悔的，以后要删除UBUNTU很麻烦。","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"C#中调用Matlab编写的函数","date":"2014-05-13T10:28:13.000Z","path":"2014/csharp-matlab-hunhebiancheng.html","text":"关于C#与Matlab的混合编程，我在网上看了很多教程，按他们的步骤进行，总会遇到各种各样的问题不能解决，最终以失败而告终。经过自己两天的努力，看了诸多文献，终于成功了，故把自己确信能成功的方法分享给大家。当然在编写不同功能的函数会遇到其它千奇百怪的问题，因此我不能保证按我的方法在任何环境下都能成功。本文只是一个简单的例子，遇到的问题相对较少，更复杂的问题或更诡异的出错只能请教其他大神了。 本文所用的编程平台为Visual Studio 2010，Matlab版本为MATLAB R2012a，这是最后一版经典界面的Matlab。 一、编写Matlab函数文件此部分不多说，学过Matlab的都懂。 例子为一个已知半径R计算圆周长的函数zhouchang()。 二、编译函数文件为DLL在Matlab命令行下运行deploytool，在图形界面里选.net组件，然后进入一个工程目录的界面，新建工程，工程的名字就是.net组件的名字，在其下面的目录表示.net类名，在类名上点右键”Add File…”，把Matlab的.m函数文件选进去。 最后进行编译（Build the project），生成的目录下有以工程名命名并加Native的dll文件。 过程可能较久，耐心。如果出错，看提示是什么出错，网上搜索相关资料修改。 三、在C#中调用建立一个C#工程并引用MWArray.dll和刚生成的zhouchangNative.dll。 我的MWArray.dll在：..MATLABR2012atoolboxdotnetbuilderbinwin64v2.0MWArray.dll 添加声明： using MathWorks.MATLAB.NET.Arrays; //数据交换必需 using MathWorks.MATLAB.NET.Utility; //如果要用到画图功能才添加 using zhouchangNative; // 引用的DLL文件名 编写代码： 编译运行后可能会有如下出错： 需要进行如下设置： 编译运行： 大功告成！","tags":[{"name":"C#","slug":"C","permalink":"http://blog.jfz.me/tags/C/"}]},{"title":"无限精度除法运算","date":"2014-05-10T04:07:00.000Z","path":"2014/wuxianjingduchufayunsuan.html","text":"心血来潮写了个可进行无限精度除法运算的算法。算法类似手动计算除法，相除得到商和余数，将商输出，余数扩大十倍，再用余数除以除数得到商，循环往复即可无限精度计算除法了。但由于我用的是int类型，事实上不能真正的“无限”精度，C语言最高精度没验证，C#中测试最多只能算到32767位小数。更改类型当然可算得更精确，本文只是抛砖引玉，就不继续深入探讨了，C语言代码如下： #include “stdio.h”void Chu(int a,int b,int n) // 无限精度除法，a除以b，n为小数位数{ int x,i; x=a/b; printf(“%d.”,x); a=(a%b)10; for(i=1;i&lt;=n;i++) { x=a/b; printf(“%d”,x); a=(a%b)10; } printf(“n”);} void main(){ int a,b,n; while(1) { scanf(“%d”,&amp;a); scanf(“%d”,&amp;b); scanf(“%d”,&amp;n); Chu(a,b,n); }} 效果如图： 我用C#做了GUI界面，并统计了运算时间，代码、程序存在下图中，下载图片，改后缀为rar即可解压。 可见运算效率并不高，像数学软件Mathematica、Matlab等都是用矩阵进行运算的，计算速度很快，本程序的算法只能说实现了功能，根本不实用，就当做一次C语言练习吧。","tags":[{"name":"C#","slug":"C","permalink":"http://blog.jfz.me/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"http://blog.jfz.me/tags/C语言/"},{"name":"原创软件","slug":"原创软件","permalink":"http://blog.jfz.me/tags/原创软件/"}]},{"title":"C#中调用C语言写的dll","date":"2014-05-02T14:34:08.000Z","path":"2014/csharp-diaoyong-c-dll.html","text":"Sandeepin喜欢用C#做GUI，因为方便，随手画就能做好，但是写代码还是喜欢用C语言。可是学C语言时书上根本没教如何编写dll，经过自己查阅各种资料教程，终于成功啦，现分享自己的心得。IDE用的是Visual Studio 2010。 一、创建dll1、建立一个 Win32控制台应用程序 。 2、选择类型为DLL。 3、编写如下代码。一个例子，函数sum计算a+b的和： extern “C”{ __declspec(dllexport) int sum(int a, int b) { return a + b; }} 4、编译就能得到dll啦。 二、C#中调用dll1、为了方便演示，就简单建个控制台程序吧： 建好后记得把建立的dll放到现在这个工程的Debug目录下。 2、先引入命名空间using System.Runtime.InteropServices;。再在class Program中输入如下代码： [DllImport(“sandeepin.dll”, EntryPoint = “sum”, CallingConvention = CallingConvention.Cdecl)]private static extern int Sum(int a, int b);static void Main(string[] args){ Console.WriteLine(“2加3的和″); int result = Sum(2, 3); Console.WriteLine(“计算结果为: {0}”, result); Console.ReadKey();} 3、编译后即可看到结果：","tags":[{"name":"C#","slug":"C","permalink":"http://blog.jfz.me/tags/C/"},{"name":"C语言","slug":"C语言","permalink":"http://blog.jfz.me/tags/C语言/"}]},{"title":"异想家计算器","date":"2014-03-14T11:37:46.000Z","path":"2014/yixiangjiajisuanqi.html","text":"本计算器是我在C#学习中做的一个小程序，可进行加减乘除、开方乘方、三角函数的混合运算。 我把它取名为异想家计算器，意思就是我的计算器。我之前还做了一个复数计算器，现在异想家计算器也把它集成到了里面，点击“扩展”—“复数计算”即可打开。 软件谈不上强大、实用，但它是自己学习过程中的产物，是自己的劳动成果，所以还是发到博客，算是留作纪念吧。 作为学习之作，肯定有很多不足，欢迎大家批评指正！软件版本为1.0，以后还会不断完善，让自己这个小作品变得更加强大！ 软件源代码就不公开了，很简单的一个程序，没啥技术含量。 [Downlink href=”https://app.box.com/s/ml467x5ww56gczsescp8&quot;\\]Box网盘\\[/Downlink\\]","tags":[{"name":"原创软件","slug":"原创软件","permalink":"http://blog.jfz.me/tags/原创软件/"}]},{"title":"新年迎来新主题","date":"2014-01-30T14:08:25.000Z","path":"2014/xinnianyinglaixinzhuti.html","text":"今天就是除夕，张颐武老师引用戴叔伦的诗“旅馆谁相问，寒灯独可亲。一年将尽夜，万里未归人。寥落悲前事，支离笑此身。愁颜与衰鬓，明日又逢春。”感慨诗人在这时刻有飘零的感伤，但我们还是应该快乐。这番话实在在理，人自然有忧伤，但快乐也不会少。这不，Sandeepin几天前就为了马年的新面貌折腾着博客主题——新年，该有新面貌了。 23日已经把主题上线，用的是Ben的主题DNSHH，经过几天的修改、完善，现在已经很契合异想博客的风格。由于原主题已经很完美，修改的地方不多，加上主题自带很多功能，插件也省了。新主题的设计偏向于“扁平化”，但是又不完全扁平，更多的是一种质朴。这与异想博客未来的变化趋势也是相符的，早年写博客主要是因为我对互联网的兴趣，写的、说的大多跟网络、软件有关，而现在的自己，可以说得上是网络“老油条”了，不说丧失了兴趣，激情肯定减半——博客变成了真正的自己的世界，文章主要偏向于生活。 所以现在需要的不是吸引眼球，而是宁静祥和，还一片清净的内心世界，这样更适合写作。为了契合主题，异想圣域的图标也修改成扁平版。其实扁平给人第一感觉就是质朴，返璞归真的味道，其它“减少认知障碍”之类的高大上功能不是说没道理，但咱就不谈了。 &lt;br /&gt; 新主题就不单独贴出图片，本博客用电脑端访问就能看到新主题的样子。老主题我用得最久，感情最深厚，就附上老主题图片一张，以此来纪念。但时代在变，心境在变，审美也在变，古代的《易经》翻译成白话就是《变化宝典》，只有变，只有革新，才能永生。这就是中国的传统文化，固然新年也就意味着进步，否则怎对得起“新”字呢？ 马年新春就要到了，最后Sandeepin祝愿大家要好好休息，不要马不停蹄；青春长在，不要马齿徒增；做事情认认真真，不要马马虎虎；做家务整整齐齐，不要马翻人仰。马年，必将马到成功！","tags":[{"name":"纪念","slug":"纪念","permalink":"http://blog.jfz.me/tags/纪念/"},{"name":"主题","slug":"主题","permalink":"http://blog.jfz.me/tags/主题/"}]},{"title":"戴尔灵越Inspiron 14TR光驱位换硬盘和加装SSD教程","date":"2014-01-26T15:14:14.000Z","path":"2014/inspiron14tr-guangqu-ssd.html","text":"Sandeepin最近把自己的戴尔灵越14寸电脑换上了SSD硬盘，因嫌电脑硬盘空间小，随便也把光驱位换成了新买的7200转日立硬盘。当然自己乱改装肯定不敢，以下就是自己参考的改装文章。毕竟此型号电脑现已停产，给网友参考的价值不大，主要是方便自己下次折腾方便而转，读者还是自己。所以也就不讲究什么版权了，原文有所修改，配图也去掉链接，附上原文地址(&lt;a href=&quot;http://dell.benyouhui.it168.com/thread-2331438-1-1.html&quot; target=&quot;_blank&quot;&gt;点这里看原文&lt;/a&gt;)，也算“侵权”有度吧。 &lt;span style=&quot;color:#999999;&quot;&gt;因为实在看不下去原来的开机速度了，卡机之后要等两分钟才能正常操作，所以决定加装SSD来增强Rt的威力。&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;我订购的是三星830系列的128G SSD，SATA3接口，因为14Rt就是两个SATA3，正合适。&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;光驱位硬盘托架用的是&lt;/span&gt;&lt;span style=&quot;color:#E53333;&quot;&gt;佳翼H117&lt;/span&gt;&lt;span style=&quot;color:#999999;&quot;&gt;，天猫商城里最热销的一款。&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;下面都是开始拆机了，14Rt的背面固定板的只有一颗螺丝，只要扭开之后远着边边划开就可以了，把原来的WD HDD拆开，固定架拆装到SSD上。&lt;/span&gt; &lt;br /&gt; &lt;span style=&quot;color:#999999;&quot;&gt;下一步就是把光驱取出来，只需要把固定光驱位的一颗螺丝拆开，然后用螺丝刀推一下螺丝位就可以了。&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;还有就是HDD装到光驱位硬盘托架上，具体步骤在购买托架那里有详细说明，这里我就省略掉了。&lt;/span&gt; &lt;span style=&quot;color:#E53333;&quot;&gt;(以下为Sandeepin从淘宝转来的硬盘支架及硬盘安装教程)&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;光驱面板很容易拆卸下来，只要把螺丝刀在旁边的卡位捅一下就可以了，怕弄坏的朋友就认真找找卡位，撬开一点再捅。&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;准备开机装系统，到BIOS里找到 Advance →SATA Operation 里面的中括号&amp;lt;ATA&amp;gt;改成&amp;lt;AHCI&amp;gt;，也可能有的rt原来就是这个设置的，如果不是就改过来。&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;……&lt;/span&gt; &lt;span style=&quot;color:#999999;&quot;&gt;之前一直郁闷在启动速度上，14Rt的速度没理由让它一直压抑在一个硬盘上，加装SSD之后才重新对14Rt有了一个认识，这才是它，为速度而生。之前WD HDD时在桌面刷新时鼠标都会有稍微停顿，现在根本不会发生这样的事情了。&lt;/span&gt; &lt;span style=&quot;line-height:1.5;color:#999999;&quot;&gt;本人是菜鸟，有什么环节不对的地方请各位老鸟指点批评，谢谢。&lt;/span&gt;","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"SSD固态硬盘优化","date":"2014-01-25T09:17:25.000Z","path":"2014/ssd-youhua.html","text":"自从买了浦科特M5S后，Sandeepin便开始关注固态硬盘的相关优化。其实本人觉得，优不优化都无所谓，我刚装完系统，没做任何优化，开机10秒。软件测速，写入500MB/s，读取370MB/s，跟包装上所谓“理想值”520MB/s、390MB/s也没相差多远，实际使用更看不出差别。 但从长远考虑，优化还是有好处的，比如增加硬盘寿命，比如防止老化过快。从寿命的角度来说，我反正都是要用到感觉硬盘明显坏道(不是测试软件警告)，拷个文件进去拷不出了的时候才换硬盘。不管我以后还是屌丝或变土豪，这个原则肯定不变。一般来说，只要不是买那些太渣的SSD硬盘，用个三到五年都问题不大，三年之后，SSD形势会怎样？我不知道，估计看到更快的SSD又想买新的了。只要能忍受变慢了的速度，寿命根本不是问题，所以关键还是怕硬盘老化才做优化。三五年，再怎么优化肯定有所老化，要不要买，还是看个人忍耐程度。 不过一些基本的优化还是要做，我觉得，这本质上是追求一个不亏，因为买来的硬盘总是要用的，最好能发挥最大性能的用，这样买才觉值。 我看了很多经典的关于SSD优化文章，这里推荐大家看两篇： 1、SSD小白用户收货！SSD的误区如何解决 2、十二招优化固态硬盘设置 尽享极速体验 其实很多优化，就我个人来说，是多余的，不适合的，不适应的。我归纳他们的文章，优化就以下几点，现在我对这几项逐条分析，分享我的体会： 让SSD运行在AHCI模式下新买的电脑99.99%默认AHCI模式，一般不用管这条，为保险起见可按照我上面提到的两篇文章里的方法检查、设置。老电脑╮(╯▽╰)╭，我看还是换新机吧，肯定硬盘不是首先制约性能之处。 4K对齐这点很重要！最好Win7、8装系统时分区，这时默认4K对齐，若想专业分区，参考DiskGenius使用教程。想无损转4K对齐，推荐软件Paragon Alignment Tool Professional。 检查SATA接口是否原生及分区时少分区、小分区。笔记本的话，接口选个妹！台式机看主板说明书或看主板标注。新机基本SATA3.0，未来更不用为SATA2和3纠结了。少分区、小分区依个人。 打开Trim指令。Win7以上默认开，无需考虑。 关闭系统恢复功能。就是常说的自带系统还原，这个关不关有争议，有人认为这是鸡肋，有人认为这是很方便的功能，关了反而错过了windows的一大好服务。还是那句哈，依个人。 关闭磁盘索引。这个我不懂，我尝试着关闭，但应用到所有文件时——好慢啊。算了，我是不关了。 关闭磁盘整理计划。机械硬盘会产生磁盘碎片，SSD则没有碎片一说，必须关。 关闭磁盘分页、系统休眠。这两项在机械硬盘时代我都是关了的，一是我电脑8G内存，二是我很少玩游戏，电脑也不挂机，用完关机。所以这两项功能对我来说没用。 关闭Prefetch(预取)、Superfetch(超级预取)、windows搜索和Superfetch超级预读。这个也不懂，默认设置，没敢乱动。 关闭快速启动系统个人审美关系，系统进入画面缺了总觉不爽，没关。 总之，SSD优化就这样了，SSD也没啥神奇，反正它只是个商品，我最讨厌把商品过度保护，自己成了奴隶，也反对毫不爱惜，自己成了傻瓜。网上的优化文章肯定是写得详尽好让你优化到最佳水平，满足你的虚荣和他的虚荣。我也不说其他的，优化看自己，满足自己需要就行。","tags":[{"name":"硬件","slug":"硬件","permalink":"http://blog.jfz.me/tags/硬件/"}]},{"title":"复数计算器","date":"2013-11-16T09:18:38.000Z","path":"2013/fushujisuanqi.html","text":"我们在电路分析课上学了正弦稳态电路，分析这类电路问题最好的方法是相量法，因为电路满足相量形式的基尔霍夫定律，其它电路公式也有相应的相量形式。因此，用相量法就能像分析直流电路一样分析交流电路，使问题变得容易。我们知道，相量就是向量，向量的一种表示方法是复数。但复数的计算就比实数复杂多了，加减还好说，乘除则麻烦。对于电路题，常要计算电抗的并联，用复数计算就是相乘除以相加，单个计算并不难，但过多的重复计算则叫人累。 恰好这学期学了复变函数，自己也自学了C#，于是用C#写了这个复数计算器，它也是我的第一个C#程序。功能很简单，就是复数的常用计算，主要为了方便自己，没什么技术含量。目前功能也不强，容错也没做，不过我会继续完善这个小程序的，欢迎大家试用，提出宝贵意见！ 更新列表： Version 1.0 2013-11-16 最初版本，容错未完善。 [Downlink href=&quot;https://app.box.com/s/audrdteyodo9ldaxa3m4&quot;]Box网盘[/Downlink]","tags":[{"name":"原创软件","slug":"原创软件","permalink":"http://blog.jfz.me/tags/原创软件/"}]},{"title":"华为G520联通版手机刷机教程","date":"2013-08-05T13:00:59.000Z","path":"2013/g520-bootloader-recovery-miui.html","text":"电信ADSL的4M宽带到期了，而它的光纤又没接入我的小区，故我选择了有光纤接入的联通，但联通又没有纯宽带提供，非得绑定这样那样的套餐。没办法，我绑定我以前的手机号，选了10M宽带，预存900买了这款华为G520手机。G520原配的Emotion UI没有我用惯的MIUI顺手，所以寻思着怎样刷MIUI到G520上。 华为的手机是锁了Bootloader的，不过华为好在提供了在线解锁，方便我们折腾。 一、官网解锁 先到官网解锁Bootloader：解锁申请 注意机型选择U8950D，看清楚8950D有两种机型，一种是C开头的，一种是U开头的，选择U开头的。 最新消息：现在华为解锁有G520-0000的型号了，直接选G520-0000就行啦。——2013-8-6 填好信息后等邮件吧： 得到解锁密码后可根据官方解锁步骤解锁：官方解锁教程 不过我推荐使用华为解锁助手，方便好用，一步到位。 手机驱动什么的肯定要先安好了，这里不赘述。 二、刷Recovery 1、下载安智网提供的第三方CWM Recovery： [Downlink href=”thunder://QUFodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8yMjQ0NzMvYmxvZy/LonJlY292ZXJ5uaS+3y5yYXJaWg==”]第三方CWM Recovery[/Downlink] 2、下载adb工具，解压里面的3个文件放在电脑的C:WINDOWSSYSTEM32里： [Downlink href=”thunder://QUFodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8yMjQ0NzMvYmxvZy9hZGK5pL7fLnJhclpa”]adb工具[/Downlink] 3、然后手机关机，扣电池20秒再放上，按“音量下”键和“电源键”20秒，卡在第一屏时用数据线连接电脑。 4、解压附件，一定要解压附件，然后运行“点击刷入recovery”。选择1，按提示继续，随后手机会重启。 5、手机关机，扣电池20秒再放上，按“音量上”键和“电源键”20秒，进入Recovery，是中文的说明成功了，不是再刷！ 三、刷MIUI系统 我使用的是ROM是邱大的华为G520联通版 MIUI V5 3.8.4 正式版 下载地址 虽然邱大说暂无Bug，经我测试，还是有各种问题的，推荐大家常关注论坛动态，邱大会跟进版本不断更新。 当你看我的这篇文章时可能以上ROM已过时，但刷机原理是不变的，就当我用这个ROM来举例了。 1、下载刷机包，复制到SD卡根目录。 2、手机进入Recovery 状态：关机扣电池20秒后再放上，按“+”和“电源键”进入。 3、选择“清除数据”和“清除缓存”。 4、选择“从SD卡选择刷机包”，然后选择“从SD卡选择ZIP文件”，再点选你刚刚复制到SD卡的刷机包。 5、安装完成后，重启手机。 6、第一次刷机加载比较慢，请耐心等待。 四、刷机后的设置 1、刷上之后在“开发者选项”里面的3个“动画缩放”设置为0.5，反应就快了。 2、默认壁纸不对，设置一下壁纸。 3、MIUI自带ROOT，开机后请在桌面“系统与安全”中的“授权管理”中开启ROOT权限。 这是我刷好后的样子，还凑合，MIUI基本功能都有，就是关机菜单没了，需借助软件实现。 参考文献：这里、这里、这里。","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"我喜欢的搜狗主题、千千静听皮肤收藏","date":"2013-06-22T00:11:02.000Z","path":"2013/sougou-qianqian-skin.html","text":"注：最近试了QQ输入法，自定义跨行短语有效！2013-9-17 在所有的拼音输入法中，搜狗拼音最符合我的使用习惯。有时为了方便输入，我会自定义一些拼音来作输出短语。比如我的网名异想家、Sandeepin、我的邮箱、QQ、身份证号等，这样只需输入几个字母就可打出它们，大大节省了我的时间。 这个功能几乎所有输入法都有，但我若要存储的短语是跨行的，很多输入法就做不到了，如： 将它整个定义为一个短语，跨行，打出时不破坏排版。现在其它的输入法对此功能的支持我不清楚，反正几年前我热衷测试各种输入法时，好像只有搜狗能做到。 除了搜狗的这个特性，我喜欢用它的另一个原因是有着丰富的皮肤。我最爱iDark这款皮肤，黑色、磨砂、透明，这是我最喜欢的搭配。可能随着时间的推移，其它输入法会不断超越搜狗，但只要只有搜狗有这款皮肤，我就会坚定地使用它。呵呵，看来Sandeepin也变成了美观控了。 现在说说音乐播放器，千千静听算是有一定年代的播放器。我第一次知道千千静听，是在小学电脑课上，老师远程控制授课时，我看到他桌面有这款软件，出于对软件的好奇，我记下了这款软件并下载使用。当时自己还小，对功能、音效什么的一无所知，只觉能播出声音就行了。后来在姨爹的影响下，我用了Realplayer、QQ音乐、KMPlayer等音乐/视频播放器，不知是不是出于第一印象还是习惯问题，总感觉还是千千静听最好用。现在非要说个特色，那就是千千静听支持下载歌词，但满足这个条件的播放器又多了，不过加上我的两个癖好，能达到我需求的音乐播放器则只有它。 1、下载的歌词能设置成放在与音乐文件于同一目录下。 2、下载的歌词文件名能与音乐文件同名，而且是我想设什么名字就是什么名字，比如我将《城府》命名为123456.mp3，那么下载的歌词文件名字就要是123456.lrc。 这两个要求则将很多音乐播放器拒之门外了。有的能下歌词，但不能放在与歌曲于同一目录；有的能放在同一目录，但是是它规定的名字，就算歌曲我改名为123456.mp3，但它下的歌词名还是许嵩-城府.lrc。 至于皮肤，千千静听虽然皮肤也多，但还没有出现一款能让我爱得非要用千千静听的皮肤。不过我现在最满意的是一款名叫“梦.破晓”的皮肤。 以上提到的两款皮肤都能在对应软件皮肤官网上下到。说实在的自己写这种文章没啥意思，纯粹晒晒自己的喜好罢了。","tags":[{"name":"评论","slug":"评论","permalink":"http://blog.jfz.me/tags/评论/"}]},{"title":"Multisim、Protel、Keil C51、Proteus的区别","date":"2013-06-21T11:02:17.000Z","path":"2013/multisimprotelkeilc51proteusdequbie.html","text":"最近Sandeepin开始捣鼓自己的专业软件，但对Multisim、Protel、Keil C51、Proteus四款软件的功能侧重点分得不太清，故转此篇文章，留作存档，以便不时之需。 Multisim(NI Circuit Design Suite Power Pro)有超强板级的模拟/数字电路板的设计工作。它包含了电路原理图的图形输入、电路硬件描述语言输入方式，具有丰富的仿真分析能力。高版本可以进行单片机等MCU的仿真。Multisim有实际元器件和虚拟元器件，它们之间根本差别在于：一种是与实际元器件的型号、参数值以及封装都相对应的元器件，在设计中选用此类器件，不仅可以使设计仿真与实际情况有良好的对应性，还可以直接将设计导出到Ultiboard中进行PCB的设计；虚拟元器件只能用于电路的仿真。 Protel的高版本Altium Designer，是业界第一款也是唯一一种完整的板级设计解决方案。是业界首例将设计流程、集成化PCB 设计、可编程器件（如FPGA）设计和基于处理器设计的嵌入式软件开发功能整合在一起的产品，一种同时进行PCB和FPGA设计以及嵌入式设计的解决方案，具有将设计方案从概念转变为最终成品所需的全部功能。 主要用途：原理图输入设计PCB板。 Keil C51是美国Keil Software公司出品的51系列兼容单片机既可以汇编开发也可以C语言软件开发的系统。 Proteus具有模拟电路仿真、数字电路仿真、单片机及其外围电路组成的系统的仿真、RS一232动态仿真。 ①C调试器、SPI调试器、键盘和LCD系统仿真的功能；有各种虚拟仪器，如示波器、逻辑分析仪、信号发生器等。 ② 目前支持的单片机类型有：68000系列、8051系列、AVR系列、PIC12系列、PIC16系列、PIC18系列、Z80系列、HC11系列以及各种外围芯片。 ③ 支持大量的存储器和外围芯片。 简单概括为： Multisim可以进行复杂模拟/数字电路的仿真、简单的PCB板设计、简单的单片机仿真。 Protel可以进行简单的模拟/数字电路的仿真、强大的PCB板设计 Keil C主要用于51单片机的软件编写，包括8051系列、89S51系列、STC单片机的汇编和C语言编写。 Proteus可以进行直观的模拟/数字电路、单片机、ARM的仿真。也可以进行简单PCB板的设计。 使用导航： 要进行模拟/数字电路的精确、细微仿真使用Multisim； 要进行电路板PCB设计使用Protel； 编写程序使用Keil C51; 要进行单片机仿真使用Proteus，仿真51系列单片机可以使用Keil C与Proteus联调（就是在Keil中运行程序时Proteus即可运行硬件仿真） 附：百度知道上的一则关于protel和proteus两种仿真软件有什么区别的网友回答： Protel主要用于画原理图和PCB；Proteus主要用于仿真，当然也可以画PCB。一般是两者软件结合起来使用。以前用的多的是Protel 99se，现在主要是其最新升级版本Altium Designer 9 或10了，建议你下载Altium Designer Summer 9，附上下载地址：点击这里官方下载。 Proteus可用的最新版本是Proteus 7.8 SP2，如要下载自已百度一下，很容易就找到了。 Protel主要是用来画电路图用的专业的电路板画图工具，但是厂商考虑到一些常用的电路有仿真的需要，所以附加了仿真功能，但是它的主要功能是用来设计电路板的工具。仿真只是它的附加功能。它在电路板设计领域是无可替代的。虽然Proteus也可以用来设计电路板的设计图，可是当你真正的要用来做一块好板时你会发现它相对于Protel的明显不便缺陷。Proteus是主要用来仿真的。与Protel相反它的画图才是附加功能。而仿真工具中它也不是像Protel那样无可替代。 来自：1、百度文库 2、百度知道","tags":[{"name":"通信工程","slug":"通信工程","permalink":"http://blog.jfz.me/tags/通信工程/"}]},{"title":"小米2 v5刷回v4方法","date":"2013-04-11T07:22:17.000Z","path":"2013/xiaomi2v5shuahuiv4fangfa.html","text":"我喜欢魅族的图标设计，但我用的手机是小米2。小米2自从更新到V5后，我的魅族图标主题就不兼容了，对于美观要求高的我来说，虽然V5有很多优点，但还是忍不住要刷回v4。然而这一刷就悲剧了，每次刷机重启总停留在百色小米图标那里，自己试图刷其它系统也无法。不过幸运的是第二天在miui论坛上看到高人的解决方法，其实就一句话： 要想V5刷回V4必须要刷miui_MiTwo_JLB10.0 miui_MiTwo_JLB10.0也就是米2的v4稳定版。刷了这个稳定版后再刷v4开发版还是有问题的，我尝试过线刷开发版还是失败了。换句话说，若想用V4，那只能用稳定版。 我在小米论坛找到了一则介绍怎样降级帖子，但也是只能刷稳定版，原文如下： 本人今天早上看到社区评论V5系统是顶礼膜拜，赞美声震天！不由心痒就线刷了一个V5的稳定版（JLB14.0）。可惜没有玩多久就发现问题严重，手机信号飘忽不定，哪怕在摩肩擦踵的闹市区！对做销售的我一天要接打几十个电话当时我是下了一身冷汗。 回公司打开电脑，找到V4的JLB12.0版本立马刷机。OK！手机自动重启屏幕出来一个熟悉的LOGO。等等–MI的标志就在那里10几分钟都没有变，20分钟还是没有变！关机–关不了，按电源键+音量下进recovery进不了。只能按电源键+音量下键进入Fastboot模式。我再来一次刷回V5然后三清，再刷V4的JLB12.0还是卡在老地方就不动了。联系售后答曰：寄到厂家来。 晚上回家吃饭都在想，我可不可以曲线来解决问题说不定就能解决！试下，果然OK，在这里分享给大家： 1，先下载原生态（线刷包） 小米手机2原生Android 4.1 QDT07，解压。 2，然后最新版刷机工具：MiPhone2.11.6 3，刷机工具打开，浏览找到存放Android 4.1 QDT07的位置，点击高级设置选择flash_all_except_storage.bat点击刷机！ 4，成功！然后三清。 5，刷机工具打开，浏览找到存放miui_MiTwo_JLB12.0_fastboot_4.1的位置点击高级设置选择flash_all_except_storage.bat点击刷机！大功告成，是不是回到了你熟悉的V4了！ 唉，降级真是麻烦啊，小米起码还有个稳定版能降级，像iPhone的降级那就更难了。不管怎样，我还是提倡大家用最新系统，毕竟有人维护，软件兼容性也会跟上。除非像我一样有特殊癖好，降级没有耐心可折腾不下去啊。最后附上我先前用V4的魅族图标界面。稳定版没有Root不好玩，我暂时还是用V5系统，真心希望有高人能指导我如何刷回V4开发版，感激不尽！","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.jfz.me/tags/Android/"},{"name":"手机","slug":"手机","permalink":"http://blog.jfz.me/tags/手机/"}]},{"title":"我的M9终于Root成功","date":"2012-07-29T06:24:09.000Z","path":"2012/m9-root.html","text":"本来我是不想越狱的，但一件事让不得不越狱。昨天晚上11点我将M9充满电，让它待机，今天早上我起床一看，Fuck!电量直接掉到65%,气死我了，果断越狱！ 观遍网上M9的root教程，艰难摸索终于成功越狱，现在Sandeepin就将自己越狱的过程写写，详细记录，方便像我这种小白看懂。 一、一些需要的文件 1、工具包cz_to_cn.zip （用于Root）、 全自动汉化升级包：meizu_update 打包下载：[Downlink href=”thunder://QUFodHRwOi8vZGwueXhzeS5vcmcvc29mdC9jel90b19jbihSb290KW1laXp1X3VwZGF0ZS5yYXJaWg==”]迅雷下载[/Downlink] 2、捷克固件 地址：[Downlink href=”http://pan.baidu.com/share/link?shareid=608213&amp;uk=3540488741&quot;\\]捷克固件(百度网盘)\\[/Downlink\\] 3、各种汉化包固件： ①魅族官方固件：11241固件汉化包(update.zip) 地址：[Downlink href=”http://pan.baidu.com/share/link?shareid=608391&amp;uk=3540488741&quot;\\]11241固件汉化包(百度网盘)\\[/Downlink\\] ②第三方汉化包： 1、魔音的两个包：① 无魅族桌面但集成了GO桌面的 ② 有HP魔音音效的 原出处下载 （在魔音的两个ROM前请尽量多的释放出SYSTEM的容量（root后用REN管理器可以看到）如你目前的手机SYSTEM容量不足的话容易出现在汉化中显示存储器容量不足的问题，造成不稳定，因此必须SYSTEM的容量控制在20M以上） 2、【东摇西嗨】最干净！最省电！精简84M美化ROM包！ 原出处下载[Downlink href=”http://pan.baidu.com/share/link?shareid=608222&amp;uk=3540488741”]百度网盘[/Downlink] 网上有人说魔音第一个汉化包（无魅族桌面）最省电，发热量最小，最稳定，但我用的是【东摇西嗨】最干净！最省电！精简84M美化ROM包！,因为我想用魅族原配桌面。 注意事项： ①工具包必须放在纯英文的文件夹内； ②update.zip不必解压，直接放到SD卡根目录，根目录！ ③刷机时最好清空数据，那样root最完美。 二、教程正式开始 1、将update.zip和捷克固件一起存入SD卡根目录（两个文件只有后缀不同，注意区分） 2、刷捷克固件，关机状态按电源键和音量+，按照刷普通固件那样刷入固件(刷机时选择清空数据) 3、刷机之后，从设置中点选保持唤醒状态唤醒、USB调试、允许模拟地点三个内容，设置路径如下图(依次点选) 提示：若看不惯捷克文的可以在设置——倒数第四个——第一个 选择英文。 第一步 第二步 第三步（设置成如图状态） 4、接着连接豌豆荚，用豌豆荚来自动安装驱动，之后退出豌豆荚，并保证豌豆荚不再开启。若在此之前你用过M9或M9能被电脑正常识别并读盘，这一步可以省略。 5、解压cz_to_cn.zip，运行cz_to_cn文件夹中的root.bat文件 会生成如下窗口 老老实实等它弄完，窗口关闭后，再运行一次root.bat，手机便会自动重启，开机之后看到新装3个软件，表明已经root成功(有的教程需要卸载SD，这里不必这么麻烦) 6、(请先确认3、4步骤是否完成，确认之后)接下来就是汉化，以前一般都是用11241官方固件进行汉化，现在网上出了各种精简汉化包更加省电，发热量更低(前文我提供了三个供大家选)。选择你要使用的汉化包(update.zip)不用解压，直接放入手机SD卡根目录。 7、 解压你下载的 全自动汉化升级包：meizu_update.rar 到一个纯英文的文件夹内(推荐直接解压到D盘)，将你要安装的汉化包放入其文件夹内，再运行里面的UPDATE.BAT 第一个选择Y，第二个选择N(因为第一步时你已经放到SD卡中)回车，等待汉化完，手机自动重启。 8、 如果重启后手机为中文，则教程结束，若不行，重来吧！ 以上资源非原创，都是从网上搜来的，刷机过程也不完全自己写的，也是网上教程大杂烩，给大家分享，祝大家刷机愉快！ 最后声明一点，由于我也是新手，只是我照着这个方法成功了，万一你照我的步骤操作出了意外，我可回答不上来，真正要问问题，还是到网上找各路大仙吧！","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"博客主题大更新！","date":"2012-07-23T10:34:47.000Z","path":"2012/theme7-23update.html","text":"历经几天的折腾，Sandeepin对现在的这款主题进行了大更新，今天总算完成了，庆祝ing 这次主题大修改主要是加上了很多当今Wordpress主题流行的功能特效。在这修改的过程中，参考了很多文章，也遇到了很多挫折，不过收获是很大的，学习了很多特效代码，也积累了很多经验。能自己修改成功的就直接写代码，没到那水平，咋整都不变的，就用插件实现。至于优化代码，精简代码之类，等到哪天技术再上一台阶时再说吧。总的来说，基本自己想要实现的功能特效都基本实现了，从当年一点不懂到今天基本能整出自己想要的风格，也算自己常年泡网的时间没虚度，哈哈，夸奖一下自己吧~~ 在修改过程中，有时同时参考了几篇文章，这个方法不能成功的，就又换成其他方法。有时或许很简单的问题，稍微修改一下就能成功的，却因自己看不出玄机，只好又换成其它方法。不过自己也不后悔，反正都是学习，俗话说文章白改不厌，代码也是要不断更新发展的，等到自己水平提高了，自然会采用更精简的方法实现功能。学习的过程才是最快乐的。以后有空，我会慢慢写些修改特效的教程，虽然网上此类文章一大堆，但往往对于初学者来说，很多教程还是交代太少了，一个很不经意的环节没讲清楚，功能就无法实现。我打算就是借着自己的经验，用最详细的过程写些Wordpress修改教程，以方便那些和我一样的初学者学习代码修改。 好了，现在就一一列举我对主题的修改吧！ 一、添加返回顶部、移到底部和评论功能 主页面只显示返回顶部、移到底部，文章页面则显示返回顶部、移到底部和评论三功能。 二、博客访问、文章数目统计前台显示 三、博客回复支持添加表情并增加滑动解锁功能 四、图片延迟加载、图片放大预览Highslide特效 图片延迟加载就是访问博客可看到图片渐显出现，这个不好描述，大家看博客就知道了。 图片放大预览Highslide特效就是点击博客图片小图可看到大图。点这张图片就可看到效果了。 五、评论AJAX回复特效、Ctrl+Enter快捷回复功能 六、为触屏优化的异想博客移动版发布！ 图为魅族M9和iPod下效果，木有平板，有的朋友帮测试下吧。 七、 HTML5 的语音搜索 可惜语音搜索只支持Chrome内核浏览器 八、集成google搜索 支持用Google自定义搜索本站，当然博客原配搜索功能没有废除，上面那个即原配搜索，Google搜索在边栏。 就这么多更新了，对于牛人来说这些修改可能微不足道，但对我来说却是大成就，呵呵，继续努力！","tags":[]},{"title":"我的iPod Touch 4差点变砖","date":"2012-07-21T07:17:54.000Z","path":"2012/touch4-fix.html","text":"之前买了个Touch 4,那时刷的系统是4.3,后来苹果更新系统很快，不久就推出了5.0、5.1,不过当时我正读高三，没时间更新系统，于是4.3的系统就用到了现在。最近我有个同学新买了Touch,系统就是5.1的，于是今天心血来潮，自己也更新5.1系统，不久6.0都要出了，现在不用5.1将来自己也不会再用了，错过5时代岂不可惜？虽然自己不是什么狂热的苹果迷，但从自己使用的角度来说，觉得苹果的产品的做工、软件的设计都是很好的，不体会总有些亏的感觉。 于是我按最正确的操作连接iTunes按它的提示更新，可是升级过程中出现备份错误等杂七杂八的问题，我也不管它，什么乱七八糟的，只要最后给我更到了5.1.1,管你什么问题都无所谓了。但更新是个漫长的过程，自己就跑去洗了个澡，兴许回来看看应该更新好了吧。可是洗完澡回来一看电脑，大失所望，居然没更新成功，出什么莫名其妙的问题现在自己也记不清了，看看iPod,停留在数据线与iTunes连接的界面。尼玛！气死我了，千万别变砖啊。 我拔了又插，插了又拔，弄了几回，开了又关，关了又开，怎么iTunes也识别不了我的iPod,这时可真的慌了。上网查了相关资料，什么按home按电源照它的规则折腾来折腾去，什么iTunes按Shift,DFU模式及恢复模式样样尝试过，可恶的iTunes就是识别不了机子，啊啊啊啊啊啊，怎么办啊，虽说touch不易变砖，但自己这么一搞，可能真成首例了。 下了小雨伞、91、同步助手、iTools、iFunbox等等三方软件，希望出现奇迹自己的iPod能识别，也期望它的恢复功能能给我成功，可惜再次让我失望了，怎么折腾就是没有用。caocaocaocaocaocao……绝望~~~ 这时真的不想干了，既耽误了我午休又没解决问题，于是拔走Touch,准备睡觉。但此时心中总抱有侥幸心，忍不住将iPod插在主机前方USB口（原来我都插在后边的，既然数据线那么长，一般主机后的USB插口又多又用不完，干脆将苹果USB线常年插在后边了），哎？还真出现奇迹了！iTunes提示有个设备要恢复，啊啊啊，我等的就是这个提示啊，兴奋ing…… 于是果断更新ing,幸好自己之前有个备份，果断恢复。原以为恢复的系统就是4.3的，又要重更新一遍，没想到恢复成功后已经更新到5.1.1了,虽说这次更新使我心情极坏，但最后这个意外收获也还让我满意。我的iTouch又变成活蹦乱跳的了……险啊，差点要进厂了的。 总结这次收获就是两点： 1、一定要装iTunes，最后出什么问题还是要回到它来解决的。平时图方便可安些符合自己习惯的同步软件，但iTunes才是正统，这点千万不要忘记。 2、出问题后别急着下杂七杂八的软件解决，也别急着按网上的教程改来改去，在我印象中，往往这些教程只教你怎么改，怎么改回来基本省略了的。到时候系统改得乱七八糟，本来有些方法是灵的，到时候真不灵了才叫你哭。最好先尝试最简单的、没有什么修改方法，比如换个插口再插，系统重启，软件卸载重装等，往往这些简单的方法有奇效！","tags":[]},{"title":"正式告别“影子圣域”","date":"2012-07-20T03:37:48.000Z","path":"2012/yzsy.html","text":"&lt; p style=”text-indent: 2em;”&gt;当年由于各种原因由影子圣域转到异想圣域，自然原来的影子博客也变成了现在的异想博客，这之间的种种辛酸苦楚也就不提了。现在我主要持有三个域名：异想圣域yxsy.org、我名字简称的域名jfz.me、我网名的域名sandeepin.com。这些域名在Go Daddy注册的，算我真正持有的吧，而最早我注册的域名yzsy.org则是在国内注册的，国内行情不用说，真的不是我的。而我为了耗着这个使用权，每年还要交租金，而且租得也窝囊，别人想废了你就废了你，仿佛自己有种祈求别人的感觉，也像是给人家当孙子。 &lt; p style=”text-indent: 2em;”&gt;于是早有打算，策划建立异想圣域。新的异想博客也将原来在影子博客的部分好文转了回来，我在博客的信息窗有说明，我说是好文，其实是自己喜欢的，也是自己的美好回忆。从异想博客建立那时起，影子博客也就不更新了，放在那儿不管它，不过耗到了今天，影子圣域域名yzsy.org到期，你不管它它也要消失，而我也不想多花钱再租这域名，过期就随它过期吧，于是有了今天这篇文章——向“影子圣域”正式告别。 &lt; p style=”text-indent: 2em;”&gt;特此截图两张做纪念(一张影子圣域首页，一张影子博客首页)： &lt; p style=”text-indent: 2em;”&gt;域名yzsy.org是废了，不过它也是自己网络的足迹、博客发展历程的一部分。想想也是，部分幼稚的文章，没有保存回异想博客的文章，若随域名一同消失，还真有些划不来。就算再无用的文章，也是自己的思想发展的记录，自己辛酸的见证。所以还是不忍，原来影子圣域的主页永久做个存档，保存在yzsy.yxsy.org这里，原来影子博客是影子圣域的二级域名blog.yzsy.org，而我不想把域名扩得太长，影子博客就存档到shadowblog.yxsy.org吧。不过排版可做不到和原来影子博客一样了，原来影子博客用的是梦想博客的系统，现在既然是存档，就笼统的做个html页存着文章就行了。至于影子圣域其它的杂七杂八网站，当时雄心满满，想建个颇大的体系，现在看来都是夭折的工程，这些零碎网站就不管了。 &lt; p style=”text-indent: 2em;”&gt;总的来说，影子圣域和影子博客是我接触网络、了解Web技术的第一站，若没有当时那些傻傻的尝试，域名服务器之类的经验积累，也就不会有今天异想圣域、异想博客这些已经步入“成熟”的网站，也就不会有我今天的计算机水平，虽然我学的专业不是计算机，但我相信这将来一定会对我受用的。 &lt; p style=”text-indent: 2em;”&gt;感谢影子圣域、影子博客，是你陪我遨游了互联网，陪我走过了青春，陪我分享了孤独。现在，对你说声再见了……","tags":[{"name":"纪念","slug":"纪念","permalink":"http://blog.jfz.me/tags/纪念/"}]},{"title":"QQ影音对比PotPlayer的两点不足","date":"2012-07-19T14:06:14.000Z","path":"2012/qqplayer-vs-potplayer.html","text":"&lt; p style=”text-indent: 2em;”&gt;本篇不是专业的测评，只是写写我在使用QQ影音所遇到的两个问题。两者都是我喜欢的播放器，没有谁优谁劣的对比。PotPlayer特点是专业、性能好，QQ影音的特点是方便、功能符合国人习惯。我先前喜欢用PotPlayer，可自定义很多设置，不过用了一段时间发现自己真的用不了这么多功能，而且一些实用的功能不是没有就是不方便，比如自动匹配字幕、截取视频段或图片、视频合并转码。我可不想为了实现这些功能下专门的软件，当然专业的软件肯定功能强大，不过这些功能自己本就为了临时用用，能在一款软件里实现对于普通用户来说则再方便不过，于是选择了QQ影音。QQ影音可谓真是了解国人需求，对于像我这样的傻瓜级用户QQ影音则恰到好处，用着顺风顺水，所以几乎一年我都把QQ影音作为我的主播放器。 &lt; p style=”text-indent: 2em;”&gt;不过最近用QQ影音则出现让我用着不适的地方。当然也不完全怪QQ影音，文件本身做得也不标准。我最近看的一部动画《化物语》，它采用了副音轨的形式增添了一些解说，然而QQ影音却读不出副音轨，PotPlayer则能正常读出。我也搞不清楚副音轨到底是什么，如果说就是类似多国语言的mkv那样多条音轨，切换就能换成不同国的语言，那读不出就是QQ影音的Bug了，如果不是这样，副音轨用的是另一种标准，读不出也只能说明QQ影音不强大。毕竟文件不标准不是理由，文件又不专门为哪个播放器做，其它播放器能识别也算它的本事，兼容性做得好。 &lt; p style=”text-indent: 2em;”&gt;第二个不足我个人认为怪格式问题，但从这方面也看出QQ影音在格式兼容方面还有缺陷。玩视频的老手都知道avi是种超级坑爹的格式，别看一种后缀，什么编码都能封装，好像没标准似的，它不像mp4、rmvb等格式，编码就几种。若一款mp4或平板说能播avi，你可以笑了，avi格式本身就大，拷到机子里真正能播的概率可能就50%，到时候播不出你才知坑爹。有时文件能打开但不支持拖放，有毛用；有时打开的画面起色块失真的，看个鸟。若是我，还是老老实实转成mp4、rmvb、3gp什么的保险些吧。不过有些老电影网上资源就是avi的，你不下也得下，没有选了。比如我下的安德烈·塔科夫斯基的《乡愁》，用QQ影音打开是能，但不能显示影片长度，也不能拖放。PotPlayer则正常。 &lt; p style=”text-indent: 2em;”&gt;当然我并没贬低QQ影音的意思，就算有这两个不足我还是会把它作为主播放器。我写这篇文章也就希望QQ影音能做得更好，成为更出色的播放器。","tags":[]},{"title":"Chrome插件：360旧版收藏夹菜单扩展","date":"2012-07-02T07:45:52.000Z","path":"2012/360bookmark.html","text":"与这里的朋友同感，我也喜欢这样竖着展开的收藏夹。旧版还有个特色就是下次打开还是原来展开的样子，而新版的展开则是最上级页面。这对于收藏链接少的用户到没什么，但对于大量收藏并且目录建了几层的用户来说，则远远没有旧版方便，下图的对比就知道了。 可惜这么好的插件官方竟然下架！如果是作者有什么原因倒还理解，若是官方主动下架则显出这家企业太不懂用户需求了。 于是试着用用官方推荐的另一款类似插件“简易收藏夹”（在Google商店可搜），图标做得还不错，界面也类似，不过少了搜索和管理收藏夹选项，毕竟不是配套的，也不对它要求太高。 不过有个实用的功能这款“简易收藏夹”却没有，就是连点几个页面打开。有时为了方便查阅，会同时打开几个页面，若每点一个又要重新重复一轮操作，那么“简易”收藏夹也就失去用它的目的了。于是这时你才会觉得旧版360收藏夹的牛逼。 呵呵，写了这么多自己都觉得太挑剔了，算了吧，到此为止。Sandeepin悄悄提供下载，嘘，还是内涵图的形式(在第一张图中，另存为改后缀rar，下次不说了哦)，不知朋友们习惯不。不过这也是我觉得分享小软件最好的形式了，唉，国内的网盘形势啊。","tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://blog.jfz.me/tags/Chrome/"}]},{"title":"Chrome插件：豆瓣电影搜索","date":"2012-07-01T13:08:45.000Z","path":"2012/chrome-douban-search.html","text":"&lt; p style=”text-indent: 2em;”&gt;Sandeepin最近狂看电影，自然少不了上豆瓣看看电影介绍短评顺便自己也吐吐槽，为了方便自己自己搜电影，在google商店找了几款右键豆瓣电影搜索的软件都不理想，比如这款“豆瓣一点”，的确可搜索，但进入的是综合搜索，但Sandeepin只对豆瓣电影的内容感兴趣啊，而且又没有设置选项只搜豆瓣电影，到头来还要在豆瓣网站上又重新点搜索电影，岂不麻烦？我试了几款同类软件，效果都不理想，没办法，还是老话说的好，自己动手丰衣足食，于是捣鼓了这款豆瓣电影搜索Chrome插件。 &lt; p style=”text-indent: 2em;”&gt;我之前写了一篇教程自己动手：修改crx文件制作自己的Chrome Apps。当时是用百度做例子，这回换成豆瓣电影搜索完全是套式。爱折腾的孩子也可以自己做一个。 &lt; p style=”text-indent: 2em;”&gt;看看我改的豆瓣电影搜索插件吧！ 文件存在最后一张图中(内涵图)，图片另存为，将png改为rar就可打开了。","tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://blog.jfz.me/tags/Chrome/"}]},{"title":"视频转码cpu才是关键","date":"2012-06-20T05:17:45.000Z","path":"2012/video-transcoding-cpu-key.html","text":"&lt; p style=”text-indent: 2em;”&gt;上次提到支持ATI显卡加速的视频转换软件，也提到CPU比GPU重要，今天真正转个大型的电影才知道，CPU不仅重要一点，简直是超级主导主导主导主导主导作用，什么CUDA、AMD APP简直是鸡肋，都他妈浮云浮云浮云浮云啊！！！ &lt; p style=”text-indent: 2em;”&gt;我还是用魔影工厂，原来一代i3-530 2.93GHz双核四线程的CPU开CUDA的电脑转个视频用时30多分钟，现用新电脑三代i5-3550 3.3GHz四核四线程没有CUDA也不开AMD APP，转同样视频用时5分多，尼玛，GPU加速这不是坑爹吗！ &lt; p style=”text-indent: 2em;”&gt;以后在也不信GPU加速了，什么都是商家的忽悠手段，真的要相信GPU才是王道！就算我上篇文章白写了，做了回商家帮凶一起骗大家了，再次申明，GPU加速就是个玩笑，泡泡网这里早有人写文章揭露过这个事实了，所以我奉劝大家，也当是自身经验教训，以后什么新功能一定要上网多看看，了解了解，别给商家说得好听骗你了。其实上网多看，不但可防止被忽悠，还能学到很多新知识，何乐而不为呢？据说英特尔的Lucid Universal MVP也他妈是个玩笑，当然这个功能我还没试过，在这里就不多评了。 &lt; p style=”text-indent: 2em;”&gt;虽说如此，Sandeepin其实对GPU加速还是有好感的，总希望技术进步嘛。GPU加速还是会继续关注，也祝愿GPU商家在新的一年有所突破！","tags":[{"name":"硬件","slug":"硬件","permalink":"http://blog.jfz.me/tags/硬件/"}]},{"title":"支持ATI显卡加速的视频转换软件","date":"2012-06-18T13:26:12.000Z","path":"2012/xilisoft-video-converter-ultimate.html","text":"Sandeepin虽然看的电影不算太多，但也勉强算个电影迷。不过我有个怪癖，在电脑上非得看1080P才过瘾，然而哪有这么多1080片源呢，就算有，也舍不得时间下，再说，有时忍不住要看刚出的电影、动漫，然而这些资源刚出却很难找高清、全高清的，特别有些动漫压根就不打算出高清。 不过我在手机、MP4上看那些480p的资源却也觉高清，其实说白了我就是希望看得精细，刚好对准像素最有精细感，因为手机屏幕也就是800x480,你下720的片源与480的片源没区别，不像电脑非得1080才对准显示器像素。 此外我长时间在学校住校，不可能经常碰电脑，于是手机、MP4自然成看电影的唯一方法，因此在手机上看电影也很过瘾，甚至觉得比电脑看更爽，大概是习惯的作用吧。 然而我用的手机是高通的处理器，大家也知道高通整体性能好，但视频解码能力比起国产处理器就差远了，但用国产处理器的MP4屏幕基本好不到哪里去。在屏幕与硬解的纠结中最终选择了屏幕，还是老老实实转码吧，高通处理器也支持mkv的硬解，但苹果产品却不支持mkv硬解，为了更好跨平台，mp4格式成了我最终的选择。 但又有一个问题，网上大多数mp4资源集合站给的分辨率多为640x360,甚至更低，这都是老手机的分辨率了，现在的智能手机标配至少800x480,下了看也没精细感，偶尔人人影视上有1024分辨率的mp4资源，但毕竟是少数，有些我想看的资源却没有，电驴上碰运气可找到一些资源，但终究不是长远之计。 于是自然的要自己转码了，转成800x480,手机上既看得精细，又不像720p那些高清占空间，反正屏幕那么大，最终显出的效果一样。一段时间下了很多转码器，那时图的是转的格式支持多，自定义丰富的软件，最终选择的是格式工厂，不过用一段时间就被它的慢速雷到了，仔细想想自己转来转去不就是rmvb、avi、wmv、flv、mkv、mp4几个格式打交道，至于自定义丰富，自己懂的视频原理又有多少呢，能定义转的分辨率、码率、调调字幕就足够了，于是用上了魔影工厂，以前老电脑用的是NVINIA显卡，可用NVIDIA CUDA技术为视频转换加速，魔影工厂恰好支持NVIDIA CUDA,使用也傻瓜，于是我很多视频都是用它转来的。但是最近Sandeepin硬件更新买的是ATI（AMD）的显卡，很多支持GPU加速的转码软件只支持NVIDIA CUDA技术，支持ATI显卡加速的软件且满足我的要求的就少之又少了。 所以今天我推荐的软件就是可支持ATI加速的视频转码器–Xilisoft Video Converter Ultimate,它在国内推出了免费中文版，叫做曦力音视频转换专家，不过我还是推荐英文版，它照样有中文语言，不过要注册码，但在某朝这不是问题。推荐英文原版是因为免费中文版似乎长时间没更新，英文版肯定有人管，对GPU加速的优化肯定跟得上硬件发展。 &lt; p style=”text-indent: 2em;”&gt;Xilisoft Video Converter Ultimate在国外的售价59.95美元，可见信心之大，产品肯定有不错的用户群。 现抄一段网上的功能介绍： 曦力音视频转换专家， 强大至近乎完美的音视频转换专家，支持转换几乎所有格式的音视频转换AVI、MPEG、WMV、diyX、MP4、H.264/AVC、RM、3GP、 FLV、MP3、WMA、WAV、RA、AAC.针对多种数码设备，提供数十种转换方案，满足所有的转换需求。支持的设备有：iPod、iPad、 iphone、PSP、Apple TV、3GP手机及各种Google手机等常用的数码设备。 主要功能 1、视频转换 2、支持高清到高清视频的转换，高清视频到普通视频的转换，普通到普通视频的转换。 3、提取、转换音频 4、从视频中提取音频，也可在音频格式之间进行转换。 5、视频到图片 6、可以在视频播放中抓取任意喜欢的画面，也可以设置截图时间间隔，从视频中批量提取图片。 主要特性 支持ATI GPU和NVINIA GPU处理器加速。 将转换完成的文件直接传输到多种移动设备中，比如PSP、iPod、iPad、iPhone4等。 将多个视频或图片合并为一个新的文件，并在视频或图片之间添加转场效果。 为视频添加多个字幕文件，调整其位置和样式，制作多语言字幕视频。 （这一点是西风最喜欢的！） 添加多个音轨，设置循环播放选项，制作多语言音轨视频。 随意剪下想要的一段或多段视频片断，并精确设置片断的起始和结束时间。 预置了适合各种CD和DVD容量的分割方式，同时允许自定义分割时间长度或文件大小。 支持裁剪画面，您可设置裁剪区域、比例和裁剪区域位置裁去不需要的边距。 添加特殊艺术效果，您可以对视频添加黑白、油画、素描、老电影或更多的艺术效果。 调整视频色彩，改变亮度、对比度和饱和度以调整视频画面色彩。 可以给视频添加多个文字、图片水印，也可同时添加文字和图片水印。 软件为各种多媒体设备准备了优化的预置方案，无需进行设置即可享用。当然，您也可以对预置方案进行参数调整，创建自定义预置方案。 在预置方案设置面板上，您可以调整开始时间，时间长度，视频分辨率，音频/视频质量，分割，等等。还有更为高级的参数设置窗口供高级用户使用。 为一个源文件设定多个目标预置方案，一次性输出多个不同格式相同内容的目标文件。 提供码率计算器，自定义文件大小，自动计算出相应的视频码率。 内置视频播放器可预览源视频，剪辑后的视频，编辑过的视频，并将编辑过的视频与源视频进行对比预览。 支持多核CPU转换，也可以选择进行转换的内核数；支持多线程批量转换；后台运行。 多核CPU支持使转换速度更快；更多视频编辑功能；界面更加人性化，操作更简单。 &lt; p style=”text-indent: 2em;”&gt;我觉得大体描述真实，试用效果也不错，但就我自己测试，视频转换加速也没那么夸张，转了一集柯南用时3分04秒，我用没有GPU加速的魔影工厂也就3分08秒，顶多快十多秒几十秒了不得了。说句老实话，转码还是要看CPU,一个i7的CPU比什么都要重要，什么GPU加速在强大CPU面前就是个玩笑。","tags":[]},{"title":"书法精品--唐寅落花诗册PDF高清版","date":"2011-11-05T11:26:52.000Z","path":"2011/tangyinluohuashi.html","text":"记得小学学书法学行书时用的书就是《唐寅落花诗册》，我们都知道天下第一行书是王羲之的兰亭序，不过当时我书法老师认为兰亭序版本繁多，当时能买到好字帖少，而且兰亭集序原文改得很乱，不适合初学者用，因为我们不仅要临摹原字，行书更重要的是整体布局，如果改得太乱初学者就很难临了。 所以老师最终挑选的就是这本《唐寅落花诗册》，此帖不但书法严谨俊逸挺秀，用笔圆转妍美灵活，提按顿挫，转折分明，而且结构有正有奇，正奇相间，错落有致，笔断意连，尽显唐伯虎的风流倜傥，是唐寅的代表作品之一。极便初学者临摹学习。 最近整理旧书，翻出了很多原来学习书法的字帖，不过唯独这本落花诗在搬家过程中丢失了。不过庆幸的是当今网络这么发达，很容易在网上找到电子版，下载来珍藏也算是能保住心中的美好回忆。版本虽多，不过要找好的全的清晰的却很难，经我挑选“唐寅《落花诗册》苏州市博物馆藏本”最清晰最全，不过百度上分了几个档，而且每档都要20金币下载，我想其他朋友需要就不太方便了。于是Sandeepin就根据这一版本，并且补上封面，封装成一个PDF,分享给各位网友以及书法爱好者。这是本人做的第一个PDF,初次使用Acrobat肯定有些地方没做好，也希望朋友们多提意见，呵呵。 [Downlink href=”http://pan.baidu.com/share/link?shareid=567596&amp;uk=3540488741&quot;\\]百度网盘\\[/Downlink\\]","tags":[]},{"title":"吻","date":"2011-07-16T15:45:47.000Z","path":"2011/wen.html","text":"读者（2011.7）上看到一篇文章，人物心理刻画得太妙了，膜拜ing,激动ing 作者：[瑞典]雅·瑟德尔贝里 有一天，两个非常年轻的人–一个姑娘和一个小伙子–坐在一块伸进水里的湖畔的石板上，湖水汩汩地拍打着他们的双脚。他们静静地坐在那儿，一动也不懂，两人都瞧着西沉的落日，陷入沉思。 小伙子想：“我真想吻她。”他抬头看看她的嘴唇，立刻感到那嘴唇的样儿就像是意味着要他去吻。当然，他在和别的姑娘恋爱，而且，她也并不是他见过的最漂亮的姑娘。但是像眼前这样一位姑娘，他确实从来没有吻过，因为她是一个理想的化身，一颗天上的明星。对一位可望而不可即的女性，又能怎么办呢？ 姑娘想：“我真想要他吻。这样一来，我也许就有机会给他一点颜色看看，让他知道我对他根本不屑一顾。我会站起来，把身上的裙子裹得紧紧的，非常冷淡地、轻蔑地白他一眼，然后挺起腰杆，静静地走开，而且并不显示任何不必要的慌张。不过眼下为了不让他猜出自己的想法活动，我应轻声慢语地问他一声：‘你认为，这以后生活就与从前不一样了吗？’” 他想：“如果我的回答符合她的心意，她也许就更愿意让我吻她了。”但是他不能确定，过去在另一种情况下，对于同一个问题，踏实怎么回答的，他生怕自相矛盾。因此，他注视着她的眼睛，回答说：“我有时候这么想。” 她对这样的回答很高兴。 她想：“最低限度，我喜欢他的头发，也喜欢他的前额。颇有点美中不足的是，他的鼻子长得太丑了；另外，他没有社会地位，他只是个学生，只是一个为通过毕业考试而读书的学生。总体来说，他并不是使我们的女友们赶到厌烦的那一类人物。” 他想：“这会儿我肯定可以吻她了。”尽管如此，他还是怕得要命，因为他从来没有吻过官宦之家的千金小姐。他也不知道这一吻是否带有危险性，因为她的父亲是这个小城市的市长，而且他就在离这儿不远的吊床上睡觉。 她想：“要是他吻我，我想我最好给他一记响亮的耳光。” 接着她又想：“可是他干吗不吻我呢？难道说我是个丑八怪，根本不讨男人喜欢？” 她朝水面上探着身子，想看看自个儿映在水中的形象，但是她一无所获，荡漾的微波把她在水中的影子打得粉碎。 她又想：“要是他吻我，我真不知道是什么滋味。” 事实上，她只被男人吻过一次，那是在城市大饭店的舞会后，被一位酒气熏天、烟臭扑鼻的中尉吻的。在接吻时，她几乎没有什么快感，尽管他是一位中尉。要是他不是中尉的话，她真不情愿让他吻。除此以外，她恨他。因为从那以后，他就没有向她献过殷勤，也根本没有表示对她感兴趣。 他们两人就这样坐着，各自揣摩着自己的心事。 最后一缕光线也消失在山那边，天色渐暗。 他想：“尽管夕阳西下，夜色降临，但她仍然愿意和我坐在一起，这表明她也许不会太反对我吻她。” 于是，他用一只胳膊轻轻低搂着她的脖子。 对这样的轻举妄动，她压根儿就没有想到。她原先以为他仅仅是吻她，不会动手动脚，那样一来，她就给他一记响亮的耳光，然后像公主似的抽身而去。但是面对他的这个举动，她却不知道如何是好了。当然，她也想对他生气，但是她又不想失去这次被吻的机会。因此，她就这样一动不动地坐着。 紧接着，他吻了她。 这一吻比她原先想象中的还要微妙。她觉得自己渐渐脸色发白，周身无力。这当儿，她根本没想到要给他一记耳光，她根本也不记得他只是一个为了毕业考试而读书的学生。她的脑海里一片空白。 而他却想起一位笃信宗教的医生所写的一本书《女性的性生活》中的一段文字：“必须预防夫妻之间的拥抱受色欲的支配。”但是，他想，这个预防很难实施，因为仅仅是一次亲吻，就使人感到灵魂的颤动。 皓月东升，两个年轻人仍旧坐在那儿，相互吻着。 她在她的耳边悄悄地说：“我一看见你，就爱上你了。” 他回答说：“在这个世界上，你是我唯一的爱人。”","tags":[{"name":"文学","slug":"文学","permalink":"http://blog.jfz.me/tags/文学/"}]},{"title":"自己动手：修改crx文件制作自己的Chrome Apps","date":"2011-07-11T05:27:15.000Z","path":"2011/make-crx-chrome-apps.html","text":"此想法源于使用Chrome时，选中文本后右键菜单会增加一条“使用Google搜索”菜单，此功能非常方便，不过chrome默认支持添加一个搜索引擎，要么google,要么百度，或者其它，相比搜索效果，肯定google最好了，不信大家搜索图片“科学”,就知道孰优孰劣。所以Sandeepin默认使用的是google,不过大家也知道，“胡萝卜温度计是不能随便学习的”,再说有时找一些中国特色软件，还是百度给力，所以能同时使用两个搜索引擎就最好了。我在网上搜索很多相关插件，均不让我满意。不过在这里看到一有道搜索插件倒还不错，若能改为百度搜索就更棒了。 于是自己动手，丰衣足食。在介绍制作方法前，先卖弄下自己制作的插件吧。插件功能与这里介绍的有道插件一样，只不过换个搜索引擎罢了。那就不要脸的把原插件的作用抄过来： 1、在不改变默认搜索引擎的情况下，在右键中增加一个搜索引擎选项； 2、只有在选中文字的情况下才增加这个选项； 来关键的了，也不多说，自己看图就明白： 将下载的crx改后缀zip或rar，然后解压。 之后修改文件，照我的图自己举一反三吧。 按照原图片规格替换成自己的图片。 接下来开始打包，看图： 打包成功后的crx文件： 最后安装吧： 怎么样，成功了吧，大家也不妨试试，由于这只是个搜索引擎，很容易替换，至于复杂的程序，那就要看你的本事了，不过做个简单修改汉化还是挺方便的。 最后献出我做的百度插件吧。 Box.net","tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://blog.jfz.me/tags/Chrome/"},{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"买了一个月的迅雷会员","date":"2011-06-05T13:17:25.000Z","path":"2011/mailiaoyigeyuedexunleihuiyuan.html","text":"迅雷的离线下载和高速通道太吸引人了，我原本想用我一直用的账号来升级会员的，不过由于这老账号是我小学申请的，当时什么都不懂，随便注册了一账号，现在连设的问题都忘记了。可惜了啊，已经是中将的账号啊。 想到用这账号升级会员不利于可持续发展^_^,没办法，于是重新申请了一账号，打算购买会员，从零开始升级。虽然挺亏的，不过也算是个教训，若没有从小学到现在在网上混的经历，怎么会有现在的计算机水平，安全意识？ 试用了一下，感觉效果极棒！我下载一电驴资源，这资源很稀缺，普通下载才5~6KB,用了离线下载，几乎达到的我的宽带极限（我家2M），不过也有些不足，高速通道的流量明显不够用，不过有离线空间弥补。 从2004年到现在，我算是迅雷的忠实用户了，虽然老账号没找回算是一大悲剧，不过迅雷就是有魅力，让你爱不释手。随着网络宽带的深入进步，下载速度终究不是问题，而迅雷能把下载这东西做得到如此水平，这难道不是一种真正的创新吗？快车、QQ旋风，其它小下载器就不提了，他们之所以无法超过迅雷，就是缺乏对市场的把握和创新。快车没把握好市场，把重点放在游戏上，QQ则想做大做全，盲目抄袭，还是创新少了，其次它没把下载当做重点来对待，它哪算到，小小下载软件竟有如此学问。因为专注，所以专业，这就是迅雷的成功所在吧。领袖和跟风者的区别就在于创新。其实对于宽带速度，迅雷也预料到在这方面发展可能前途渺茫，于是早就把自己定位是视频在线播放公司，近几年逐步转向迅雷看看，现在迅雷的门户就是迅雷看看，并逐步向正版发展。 有人说，三流企业满足需求，二流企业跟踪需求，而一流企业则创造需求。迅雷的创新就在于创造需求，之前的公司都只做到满足需求的层面上，下载速度不快，就多线程，就P2P.这些都没含量，谁都可做，现在很多（几乎所有）下载软件都有这功能，而迅雷做到了一般公司做不了的，离线下载、高速通道、网盘……样样既实用，又有技术含量。比如离线下载就不是谁都敢搞的。 当然，迅雷下一步该怎走，谁也算不了，但关键一点是，公司要有信誉，一个大公司就应有大公司的作风，像几年前的新浪，开个网盘说关就关了，这以后谁还敢用你的？还有就是公司承诺的政策不能时常改动，虽然公司也有苦衷，有时不得不调整规则，但这样用户体验也差了，导致市场减少，最终亏的还是公司。所以公司就因有长久的规划，要能预见一件事做了后的一切情况，不能说改就改，好像这产品一直都在Beta阶段似的。几年前的新浪爱问，可上传30M文件，各项服务都不错，可一会儿说文件永久保存，一会儿又变为一月没下载就删，现在又说永久保存了，但你知道用户的心情是什么吗，对你整个公司都失望了。这就有点像一政权，政策经常变，谁还敢在这国家存钱，谁还敢长久住在这儿？所以这也是共产党做的好的地方，基本国策百年不变，承诺的政策不常变动，尽管中国还有这样那样的问题，但做得好的，还要肯定表扬的，大丈夫是非分明！ 既然交了钱，就和这公司困在一起了，自然也不想让它倒闭，于是扯了一堆废话，但我也真心希望自己说的有用，迅雷若能做到这两条，相信它能发展得更好。","tags":[{"name":"敬佩","slug":"敬佩","permalink":"http://blog.jfz.me/tags/敬佩/"},{"name":"评论","slug":"评论","permalink":"http://blog.jfz.me/tags/评论/"}]},{"title":"红警制作工具集合——怀念我最爱的游戏红警","date":"2011-06-05T00:59:07.000Z","path":"2011/hongjingzhizuogongju.html","text":"今天整理硬盘数据，翻出了很多以前玩红警的资料，不禁想到初中时家里电脑配置差，当时唯一能玩的几款大型游戏只有红警、尤里复仇、极品飞车6、侠盗飞车。这几款游戏算是最经典的了，相信很多朋友深有同感吧，特别是玩红警，这类游戏一次一盘，玩得干净利索，不像其它剧情游戏，要在游戏上花很多时间。可惜就算这些不太耗时的游戏，现在也再没更多时间折腾了，现翻出上几G的红警游戏资料素材，真不忍心删除，于是写下这篇日志，分享下从前我修改制作红警的工具，当然我也只是抱着晒晒软件的心思罢了，不指望还有人愿意玩这么古老的游戏，更不指望有人还会下载这些修改软件、教程回去研究，呵呵。 本篇日记算是对红警一次深深的怀念吧，红警永远不会和我远离的，就算现在没时间玩，以后或许也没时间玩，但它在我心里深处的回忆是永恒的，不管技术多么进步，红警永远是最好的。 不过当然不可能几G资料全部分享，这些资料中有很多Mod，这些Mod现在在网上可能都可下载，其它零碎资料设计素材就不发了，我就发几个Mod制作工具，几个特别的做些文字或图片介绍： 1、红警2图标模板 如果做Mod想和原来图标一样，图标模板必不可少，当然若想另起炉灶，全部图标重新设计也行。 2、红警Ⅱ语言编辑器 2.68 简体版 编辑语言文件的，一般新加物种在游戏中名字显示的是代码，通过语言编辑器可改成你需要的名字。 3、XCC Mixer 1.24中文版 Mix是红警的一种格式，很多文件素材储存在里面，相当于打包文件，用它可创建、修改Mix文件。 4、FinalAlert2 YR中文版 一个用于创建/编辑地图文件的软件。 5、尤里的复仇增强版超级编辑器 一个傻瓜编辑器，很容易改爆，还是自己修改好。 6、RAD Tools1.5汉化版 一个用于转换图片及视频文件为BIK动画文件或其它格式文件的软件。 7、OS HVA Builder 2.1 汉化版 编辑游戏中的HVA图(一种素材格式)。 8、OS SHP Builder 3.35 汉化版 用来编辑游戏中的SHP图(通常是游戏的画面图块) 9、PNGtoSHP 1.3 将PNG转换为SHP图文件。 其它工具就不介绍了，所有文件打在一个包中，反正也不大，好奇心强烈的朋友们自己下载看看吧！ [Downlink href=”thunder://QUFodHRwOi8vZGwueXhzeS5vcmcvZmlsZS+67L6v1sbX97mkvt+w/C5yYXJaWg==”]迅雷下载[/Downlink]","tags":[]},{"title":"彻底服了——批量改名神器Chgname","date":"2011-05-21T14:15:19.000Z","path":"2011/pilianggaiming-chgname.html","text":"ChgName是我见过最灵活的批量文件改名软件了，说它最灵活，那是因为它可以把N个文件的名字，一起copy到外部文本编辑器中，编辑后再粘贴进来。这一点，对于善用Excel, gVIM或UE的人来说，简直就是一条通天捷径啊。 其它一切不解释，看图： 虽然看似操作繁琐了一些，好像不太智能，但从另一角度来说，却是操作最自由最灵活的，另一方面想，还可练练Excel操作，岂不美哉！ 原主页（http://www.uio.no/~kln/）已挂，据说是作者k.l.nygard@hfstud.uio.no在1998年以Delphi 4.0开发的。 Sandeepin提供ChgName 7.0 汉化版绿色版下载。 [Downlink href=”thunder://QUFodHRwOi8vZGwueXhzeS5vcmcvc29mdC9DaGdOYW1ldjcuMLq6u6/CzMmrsOYucmFyWlo=”]迅雷下载[/Downlink]","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"单墫《概率与期望》中有趣的概率题","date":"2011-05-21T11:06:57.000Z","path":"2011/gailvyuqiwang-gailvti.html","text":"之前我提到单墫的《概率与期望》，今天有空，就向大家分享此书中的一好题： 且说郭靖、周伯通、裘千仞三人曾在黑暗的屋子里互相搏斗，未分胜负。天亮后，三人约定采用手枪决斗，方式是按郭、周、裘的顺序轮流各射一枪（射击目标可以自行选择），周而复始，直到仅剩一人未被击中（被击中者当然立即倒下，不能再射击了）。 如果郭击中目标的概率是0.3,周击中目标的概率是1（百发百中，从不失手），裘击中目标的概率是0.5.问郭靖应该采用什么策略，能使他自己获得最大的生存率？ 解：（全选看答案） 如果郭第一枪打裘，那么击中的概率为0.3.但在裘被击中时，周一枪即将郭撂倒。所以郭击中裘还不如不击中。在郭未击中裘时，周应当先开枪打危险性更大的裘（裘命中率&gt;郭命中率），在裘被周击中后，郭有0.3的机会获胜（即最后剩下的人是郭）。因而在郭第一枪打裘时，过获胜的概率为 （1-0.3）×0.3=0.7×0.3=0.21&lt;0.3 如果郭第一枪打周，那么击中的概率为0.3.在周被击中时，裘、郭轮流互射，郭胜的机会为 0.5×0.3+0.5^2×0.7×0.3+0.5^3×0.7^2×0.3+… =0.5×0.3[1+0.5×0.7+（0.5×0.7）^2+（0.5×0.7）^3+…] =0.5×0.3×1/（1-0.50.7）=3/13 在周未被击中时，周先击中裘，然后郭、周互射，郭胜的机会为0.3. 因此，郭第一枪打周，获胜的概率为 0.3×3/13+（1-0.3）×0.3 （1） 由于3/13&lt;0.3,所以（1）&lt;0.3 两种选择（打裘或打周），郭胜的概率都小于0.3. 其实，郭还有第三种选择，即他第一枪不打裘也不打周，而是朝天放一空枪，然后周打中裘，郭再打周，郭获胜的概率为0.3 因此，郭靖的最佳策略是第一枪应放空枪。 结果让人大吃一惊，但又合乎逻辑，这正是数学的美妙之处，生活中的经验往往在数学推理下变得那么不靠谱。而数学的完全正确的逻辑却又让人感觉世界构造得如此奇怪。此外生日悖论、先验概率更让人感到不可思议。呵呵，这就是所谓的上帝笔法吧。","tags":[]},{"title":"发现的生物基因比例巧妙算法","date":"2011-05-07T11:45:48.000Z","path":"2011/shengwujiyinbilisuanfa.html","text":"生物老师向我们讲了一个基因比例巧妙的算法： 若以群体中A基因占m%,a基因占n%,它们自由交配，则子一代中AA、Aa、aa的比例有什么关系？ 若用传统的方法解题则算死，老师告诉我们有如下关系： （A+a）2=AA+2Aa+aa AA基因：Aa基因：aa基因=AA:2Aa:aa 例如： 果蝇的体色由常染色体上一对等位基因控制，基因型BB、Bb为灰身，bb为黑身。若人为地组成一个群体，其中80%为BB的个体，20%为bb的个体，群体随机交配，其子代中Bb的比例是多少？ 解答：因为BB:bb=80%:20% 可得：B占80%,b占20%. 于是（B+b）2=BB+2Bb+bb ,Bb比例=2Bb=2*80%*20%=32% 没想到生物也如此奇妙，更奇妙的是数学在生活中无不渗透，段考结束，我120名，比上次有进步！继续加油吧！","tags":[]},{"title":"掷骰子比大小，选择骰子的问题","date":"2011-05-07T11:25:55.000Z","path":"2011/saizibidaxiaowenti.html","text":"好久没写博文了，今天在陆老师那里看到一很有趣的概率题，和大家分享吧：**题 甲乙两个人掷骰子比大小。有三个骰子可供选择：第一个骰子：6个面上都是”3”;第二个骰子：4个面上是”4”,2个面上是”1”;第三个骰子：2个面上是”5”,4个面上是”2”.每次乙总是让甲先选择。（1）如果甲选择”333333”,乙就选择”444411”;（2）如果甲选择”444411”,乙就选择”552222”;（3）如果甲选择”552222”,乙就选择”333333”.请大家对这三种情况，分别计算一下，谁获胜的概率大一些？计算得到得到的结果，是不是很有趣？解（全选即可看到答案）（1）如果甲选择”333333”,乙就选择”444411”;这时，如果乙掷出”4”,就是乙获胜，如果乙掷出”1”,就是甲获胜。因为乙掷出”4”的概率是 2/3 ,所以乙获胜的概率是 2/3 ,大于甲获胜的概率。（2）如果甲选择”444411”,乙就选择”552222”;这时，如果甲掷出”1”,或者甲掷出”4”同时乙掷出”5”就是乙获胜。因为甲掷出”1”的概率是 1/3 ,甲掷出”4”同时乙掷出”5”的概率是 2/3×1/3=2/9.所以乙获胜的概率是 1/3+2/9=5/9 ,大于甲获胜的概率。（3）如果甲选择”552222”,乙就选择”333333”.这时，如果甲掷出”2”,就是乙获胜，如果甲掷出”5”,就是甲获胜。因为甲掷出”2”的概率是 2/3 ,所以乙获胜的概率是 2/3 ,仍然大于甲获胜的概率。总而言之，不管甲选择哪一种骰子，乙总是可以使自己获胜的概率大于甲获胜的概率。**最后推荐一本书：《概率与期望》，单墫老师著的，这本书不是一般的应付考试型的概率练习书，也不是艰深的概率参考书式的专业书籍，这里面单老师以幽默的笔调，通过一个个有趣的概率故事，带领大家走入一个奇妙的概率世界。与其说它是一本奥赛书，不如说它是本数学科普书，哪天有空我也向大家分享里面的几则概率题，当然最好是买一本，也不贵，绝对不吃亏的，一定会让你大开眼界。说到应付考试，下星期就要段考了，我还没复习，呜呜，Sandeepin加油吧！","tags":[]},{"title":"DoubleKiller——重复文件清理神器","date":"2011-02-17T06:43:50.000Z","path":"2011/doublekiller.html","text":"Sandeepin在网上好不容易搞了套“Pretty Beauty美女系列宽屏壁纸”，感觉很不错，不过网上找的是分包，有些图片重复了，于是找到了这款重复文件清理软件——DoubleKiller。 这款软件绿色免费，无插件无捆绑，感觉很不错，使用方法及其简单，Sandeepin就不多说了，附一张图： 附上网上找的介绍，我就懒得写了： 你的硬盘上有重复的文件么？我指的不是备份出来的文件，而是同一个文件的没有用的复本，可能是你不知不觉中下载或多次创建的。DoubleKiller能帮你把他们找出来。尽管这个程序使用起来有些别扭（例如在你使用第一个标签功能之前必须先设置第二个标签），但是这个程序可以搜索不同驱动器的指定类型文件，查找文件名、大小、创建时间或CRC32校验相同的文件。完成搜索后，DoubleKiller可以让你批量选择是移动还是删除它发现的相同的文件。 附上汉化作者地址：点击进入 推荐大家到他哪儿下，可得到最新版！ 大家若想要Pretty Beauty美女系列宽屏壁纸，下次发上来吧，这资源挺稀有的，这篇的主角不是壁纸，就不多说了。 [Downlink href=”thunder://QUFodHRwOi8vZGwueXhzeS5vcmcvc29mdC9Eb3VibGVLaWxsZXIucmFyWlo=”]迅雷下载[/Downlink]","tags":[]},{"title":"Mystique 2.4.2异想博客修改版","date":"2011-02-01T12:49:08.000Z","path":"2011/mystiquetheme.html","text":"这款主题我还是很喜欢的，以前异想博客都是用这主题，不过我嫌他太大，复杂，拖速度，就不用了。 这是我使用的Mystique主题，2.4.2版，不是最新，其实也没什么修改，就是把字体改成了雅黑，主题后台设置很强大，不过主题默认有个无用的twitter，可删除，看这里。 当然还做了些优化，自己摸索看看吧。 附张图： 最后附一个Mystique专用的插件：Mystique Extra Nav Icons，用来增加右上方的快捷 icon 的。 点这里下载Mystique Extra Nav Icons 插件，这里有使用说明 若想下载原版Mystique，去官方这里吧！ SkyDrive","tags":[{"name":"主题","slug":"主题","permalink":"http://blog.jfz.me/tags/主题/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://blog.jfz.me/tags/Wordpress/"}]},{"title":"博客换上新主题Piol","date":"2011-01-02T11:48:09.000Z","path":"2011/bokehuanshangxinzhutipiol.html","text":"千辛万苦，终于找到了适合我的主题Piol,在这里特别感谢Piol原作者小影的无私奉献和热情帮助。 历尽艰辛，终于改完了Piol主题相关信息，美化了设置了属于我的风格使得Piol主题在异想更强大。 Piol是个带有具有激情的主题，加入WP3.0特性，兼容IE6~IE9、Firefox、Opera、Chrome（Webkit内核）等主流浏览器，其中加入各种jQuery特效，虽然这样说，但实际上在Chrome下各种特效才能完美体现。 点这里，你可以看看Piol主题，如果喜欢，推荐下载。 当然，异想博客的新主题并没至此就完，此后要改的地方多了，可惜学习繁忙，没时间弄，寒假不知补不补课，唉，学生啊~~ 对了，我还想开个数学栏目，介绍分享我在学校或书籍遇到的新题巧题和名题，当然了，以我的水平还不敢说教别人，只当做分享交流了，还请各位网友大师不啬赐教，也当是博客娱乐中的一丝学习了。 不管怎样，更新还是要更的，时间若挤，总是有的，慢慢来吧……","tags":[{"name":"主题","slug":"主题","permalink":"http://blog.jfz.me/tags/主题/"}]},{"title":"Win7 64位下使用工行捷德U盾教程","date":"2010-12-10T12:16:32.000Z","path":"2010/win7-64-udun.html","text":"Sandeepin历经艰辛，翻遍无数帖子，遭遇无数失败，终于找到Win7 64位下使用工行捷德U盾的方法，现将方法分享给大家。首先，方法不是我原创，故此感谢参考过文章的作者，由于参考网站数量过多，就不列举了。 废话不说，直入正题： 1、U盾的选择，毕竟这方法对U盾的要求过严格，只有U盾捷德全蓝10开头的才可用（网上是这么说的，我的U盾也是10开头的，对于其它到底是不是真正用不了我就无法考证了），如果我描述的不清就看下图吧： 2、按顺序安装驱动 !!!!一定要按照顺序安装！！！！： 1）、安装工行控件：icbc_netbank_client_controls.exe 工行个人网银控件下载地址（官方）： http://www.icbc.com.cn/icbc/html/download/dkq/icbc\\_netbank\\_client_controls.exe 2）、解压手动指定目录安装U盾驱动：StarKey200_X64.rar 由于没有安装包，故只有手动安装，插入U盾，到设备管理器的U盾设备上更新驱动指向此文件夹（看图） 3）、安装证书：SafeSign_ICBC_Per.exe 自己选择，到官方这里下：http://www.icbc.com.cn/ICBC/%E7%BD%91%E9%93%B6%E7%B3%BB%E7%BB%9F/anzhuang.htm 注：icbc_netbank_client_controls.exe和SafeSign_ICBC_Per.exe都可以到工行官方下载最新的，我就不提供了，只提供第二步安装的驱动文件。 3、重启（非常重要，开始我都以为失败的，但是重启后才发现原来成功了） 4、成功：看看识别的U盾吧： 成功付款： 点击下载","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"Emlog转Wordpress教程","date":"2010-11-27T04:50:17.000Z","path":"2010/emlogtowordpress.html","text":"近几个月折腾Emlog很久，觉得还是Wordpress好，这里，我就教大家怎样从Emlog转到Wordpress. 首先，在http://miian.com/zh-hans/blogsync/1.1有一款在线工具BlogSync,我们就是靠他来搬家的。 要想使用这款工具，你的两个博客都要支持离线写作，因为本工具是靠xmlrpc来实现同步的。 开启xmlrpc:Emlog在设置中将开启离线写作选作是。 Wordpress则开启XMLRPC xmlrpc接口：Emlog:http://blog.yxsy.org/xmlrpc.php Wordpress:http://yxsy.org/blog/xmlrpc.php（记得将地址改成你的博客！） 使用BlogSync:工具在http://miian.com/zh-hans/blogsync/1.1,操作没好说的，看图吧： OK!转好！我有一篇文章转失败，不过没关系，手动转即可，但若多数文章转失败，那就杯具了！ 转换效果还可以，日志发表时间无错，可保持博客历史感。悲剧的是标签评论无法同步，而且页面也当文章同步过去了，到时注意删掉。","tags":[{"name":"Emlog","slug":"Emlog","permalink":"http://blog.jfz.me/tags/Emlog/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://blog.jfz.me/tags/Wordpress/"},{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"转了180度，还是回到wordpress","date":"2010-11-27T04:07:04.000Z","path":"2010/huidaowordpress.html","text":"过去几个月一直折腾Emlog,最终，终于认识到蓝冰的一句话：EMLOG.很多东西。简直。你懂的。跟WP比就是幼儿园的小朋友，JJ都没长起来。的确，Emlog相比起来是弱了，特别是备份，居然要求同版本的Emlog程序才能恢复，这也倒还罢了，关键是插件少，支持函数少，开发难。像Sandeepin这样折腾的家伙，该折腾的折不起来，却被不该折腾的东西折腾^_^. 好了，Emlog毕竟还不成熟，我也没资格要求它能与Wordpress相比，毕竟是中国人开发的，虽然有这样那样的缺点，还是值得鼓励，值得期待的。对于普通朋友，用它写写文章，胡说八道还是比较灵巧简洁方便的，wordpress相对笨重了点，但够你折腾。至于更多我也不想说，我不想Emlog流失客户，也不是很支持它，抱个观望态度吧。 聊聊我的私事，我班主任实在太专制，感到很不自由，朋友LXL用文言写了一篇文章，虽说不是很好，但观点还是表达较明确的，贴出来大家看看： 哥笑而不语，只能低头。对着这是人非人的世界，我还有什么还说道呢。以幼之法待准冠之人，可乎？思其用心，吾亦不欲论之。中国之教育，以分论人，已习之。能力，考分也；操行，计分之高低也。以分之高低，断人之品行，吾亦未其准也。虽分确可以为参考，但非一也。因人之性格不一，故当因材施教。静者，少言，动者，言多。对静者可教之少，对动者，应育之多，而不应以扣分后而训之，其效，试者应，所有悟。动者应心之躁动而为能静，故以暴制暴，只能适得其反。 学着亦有错焉！未能自制己之缺点，若师能导之，则吾班或人欲差也难矣。吾书此文，表吾之观，也望见此教者能自醒。吾之缺，余以改之，教之漏，望其思之。 附：待高分者，师轻罚之，若低分而微闹者，则十有八九惩之以严，严固当有，却不应常有。除此外，仍有多种情形，师待分之高低者，若天地之别，如不改之，则育人者以此败矣。 孔子云：“因材施教。”吾笑断言中国之师十有八九不能为之。 此记当记于心，而不宜诵于口也。 近几个星期有领导来查，导致我校暂停补课，于是我才有时间搞搞博客，很多朋友肯定想问我是怎样从Emlog转到Wordpress的，这个下次写篇文章专门讲解。回到补课问题上来，桂中就被抓了，还上了焦点访谈，杯具了啊，桂中的声誉我想肯定受到严重影响，我在的十八中，可谓消息灵通，躲过一劫也，其实领导的孩子难道不读书？中国的教育体制下，还有没补课的学校？哼哼，作秀的罢，我表示无鸭梨…… 我也怕的有理。","tags":[{"name":"Emlog","slug":"Emlog","permalink":"http://blog.jfz.me/tags/Emlog/"},{"name":"Wordpress","slug":"Wordpress","permalink":"http://blog.jfz.me/tags/Wordpress/"}]},{"title":"Win7下如何删除hiberfil.sys和pagefile.sys","date":"2010-07-24T21:03:57.000Z","path":"2010/hiberfil-sys-and-pagefile-sys.html","text":"一、Win7下如何删除hiberfil.sys? &lt; p style=”text-indent: 2em;”&gt;直接禁用掉休眠功能就行了。但实现的方法与XP不一样，具体方法如下： &lt; p style=”text-indent: 2em;”&gt;1. 进入控制面板-电源管理-禁用掉“休眠”“睡眠”. &lt; p style=”text-indent: 2em;”&gt;2.进入C:WindowsSystem32 找到cmd.exe 点右键–以管理员身份运行 &lt; p style=”text-indent: 2em;”&gt;3.在cmd模式下输入命令“powercfg -h off”-回车。 二、文件pagefile.sys的删除方法： &lt; p style=”text-indent: 2em;”&gt;我的电脑-》属性-》高级-》选 性能项的 设置-》高级-》虚拟内存-》选择 无分页文件。但不推荐直接设为0,建议将此文件设到其它盘上。 &lt; p style=”text-indent: 2em;”&gt;这样优化之后，C盘可以省出近4G空间来。","tags":[]},{"title":"落座新家，回答问题","date":"2010-05-09T13:36:56.000Z","path":"2010/newhome-faq.html","text":"哈哈，再也不用使用其它博客服务了！！！终于学会自己建独立博客了！！^_^高兴ing…… 刚刚使用Emlog，自然要谈谈选择Emlog的原因和独立建博的快乐了，想来想去，就以问答的形式展现吧。 Q: 说说独立博客的好处，为什么选择Emlog？ A:我本是个怕麻烦的人，有其它博客服务商托管当然省事，但中国互联网世界变幻莫测，人算不如天算，我从最早使用百度空间，到35互联提供的Wordpress系统博客，再到梦想博客，无一不是限制不多的，本来打算用Blogger的，它是Google旗下的一款产品，由于众所周知的原因，Google的IP全被封了，Blogger自然也无法使用。没办法，只好发扬折腾的功夫，玩起了自己建站，选来选去，定为Emlog，因为我使用Oblog时间长，Emlog使用方法与梦想博客提供的Oblog使用方法类似，易于上手，便选择了它。有了独立博客，什么都可以DIY，不再受些诡异的限制，ZF的某些做法实在是太过于极端，唉……不想多说。 Q: 你用的是哪里域名，哪里空间？ A:是Godaddy注册的域名，Godaddy是全球第一且是经ICANN认证的顶级域名注册商，域名注册数量是第二名的三倍多，其规范的管理服务，强大的控制面板，迅速的解析速度确实值得信赖。从国内很多互联网前辈的亲身经历告诉我们，注册域名Godaddy才是上上选！更激动人心的是买它域名还送10G免费空间，本博客就是用它免费空间建的，稳定，实在不行不想用就跑，不像用了收费空间，觉得不好又抛不掉。 Q:Sandeepin是什么？ A:我的网名，也是本博客的名字，本博客全称是：那个关于Sandeepin的传说。有时也简称:那个小S的传说，那个S传说。为什么是传说，这个嘛……敬请期待^_^ Q:本博客什么时候成立的？ A:我原先建立了一个博客名为影子博客，由于多方面的原因，最终还是觉得建立Sandeepin网站好，把影子博客并为Sandeepin的旗下网站，算是扩大规模吧。如果你仍是想要知道我为什么这么做，那我就说说几点关键原因：1、影子博客太通俗了，重名的太多，没个性，Sandeepin是我独一无二的网名，怎样也有利于搜索引擎收录。2、域名问题(不深谈)3、影子博客的年代留下太多不愿的记忆，于是选择重新开始…… 说了半天还没到正题，要单说Sandeepin网站成立，是2010年5月1日，算上影子博客的时间，会更长，由于不想回顾历史，影子博客的时间就不说了…… 就说到这里了，还有其它问题，通过留言的方式回答吧。","tags":[{"name":"Emlog","slug":"Emlog","permalink":"http://blog.jfz.me/tags/Emlog/"}]},{"title":"开张第一篇，不是第一篇！","date":"2010-05-09T08:00:01.000Z","path":"2010/bushidiyipian.html","text":"从影子世界、影子圣域，再到Sandeepin，我的博客生活记不清有几年了。 从百度空间、梦想博客，再到Blogger，Sandeepin异想家这网名也不知用了几年。 从转载到原创，从尝试到熟练(还没到精通)，有自己域名，有自己的互联网世界，有自己的思想，有……这一切来自网络。 大巧若拙，大智若愚。高中生活，我才真正思考未来！这次是真正经历了一些年月，原来重要的很多东西依然重要！已四散各方的朋友真正的朋友又走到一起，然而有些却变了——我发现了我与朋友的差距，或是思想差异吧。 然而我却认为这不是差异！！也不是差距……世界的认识不同，路不同。 我还是爱我自己的观点，自己的世界始终还在，身处孤独中，却又不想走出！ 我或许还是个影，我宁愿只是空虚，或者消失于你的白天，我宁愿只是黑暗，绝不占你的心地…… 忍不住还是要将影子博客成立的第一篇文章贴出，心态思想认识只稍稍有些不同。 王羲之说得好，世殊事异，所以兴怀，其致一也…… 新的路，新的开始……","tags":[{"name":"纪念","slug":"纪念","permalink":"http://blog.jfz.me/tags/纪念/"}]},{"title":"【影子博客旧文】关于鲁迅","date":"2010-02-28T12:37:00.000Z","path":"2010/about-luxun.html","text":"关于鲁迅，有许多话要说，然而想来想去，有了以下三点体味： 世道 鲁迅的看事，目光犀利，刻薄之外又多哲思。先生有学者的良知，又通晓市侩的伎俩，故有暖意的一面，又有冷峻的色调。因为有良知，故直面社会时不与黑暗妥协；又因为谙熟巧人的世界，于是便常常让天底下的政客、名流、愚民露出本色，逃避他的审问是殊难的。他谈皇帝，谈陋儒，谈民众，单刀直入，毫不温吞，决不说不痛不痒的话，所谓睁着眼看，就是将人们从自欺自骗中拉回到一个真实的王国中去。所以他的文章，血色之外又多了拷问之声，丑陋的、灰暗的、萎态的世道被一一点出。鲁迅知道人世间的恶因之多、之毒，与其较量时，用着比对象世界还残酷的手段，让其一个个败下阵来。你读他的书，仿佛置身于冷风之中，觉得彻骨的清醒和兴奋。也恰如久居洞穴的人忽地走到天地之间，知道了自己原来还是一个被囚的奴隶。他的文章有韩非子的峻急，亦多嵇康的狂放，内中也有尼采的高傲。通世道者未必是哲人，而哲人必通世道。鲁迅的智慧，固然来于书本的暗示，但多生命的体验，其解析人间冷暖的笔法，证明了他精神之光的来源。阅世者深，其天机非浅。这里的奇文奇句，非轻薄为文者可以模仿的。 人心 鲁迅的看人，有神来之笔。人的喜怒哀乐、善恶曲直，均有勾勒，且呼之欲出。民众的心久入膏肓，起死而救之，其情也真。中国人的思维，在他眼里有点病态的样子，比如健忘、浑沌、暧昧、虚妄，既然不敢正视现实，又不去反观己身。一天天堕落着，一天天自满着，明明是奴隶，却并不知道。爱面子者喜谈大话，逢场作戏者愿讲空言，见弱者一脸阔相，遇权贵则俨然奴才。鲁迅写人心之危、之陋，多警世之语。人的怎样虚伪，怎样卖己，将灵魂抽出，都历历在目。在名人与名言里看到虚无，从隐士的陶然里窥到伪装。时髦者往往有遗老的恶习，新派青年常常拾士大夫的牙慧……人心的蒙尘久矣，早已非明净之台。先生从古人到今人，从域外到中土，苦苦寻找救心之法。捣毁旧的，催促新的，与真人相遇，有慷慨之怀；悼念逝者则悲音动地。于是有魏晋的风度，傲视天下；也带尼采、托洛茨基的冲荡，不自囚思想。鲁迅的文字是飞腾灵动的。它让人看到了不累于俗物，高蹈于上苍的气象。人不仅应诗意地栖息在这个世上，还应自由地往来于天地之间。先生以溅血之迹写下了人世间素朴之心明亮之心。每每读之，让人回肠荡气，一唱三叹，确为旷世奇文。 己身 鲁迅看自己，多嘲讽之意，并无自恋的痕迹。他每谈往事，略带哀伤，幽愤之调也是有的。知道己身的有限，就坦然地对待生命。既不求圆满，又不自弃，于是便在沙漠里走来走去，给人刚敢刚毅的印象。他坦言内心有黑暗的东西，像毒一样扩散着，但又不愿将它传染给青年，使之陷入虚无里。于是一面拷问着灵魂，一面和无物之阵肉搏，在自我与自审里完成着生命的过程。人在世间，不过弱小的存在，不朽与伟大都是可笑之词。生命是渐渐进化的，旧的终究要消失，己身不过一种链条，总有一天要沉没于黑暗中。所以他不求所谓的永恒，也不妥协于恶的环境。悲则大叫，乐则高笑，对飞沙走石，坦然视之，毫无惧色。作者为文，苍凉悲苦，并云迅速消失于世间，对荣华富贵并不贪恋。生命的目的不过是走于无路之中，走的过程便是意义的过程，一切先验的预设和宏大的奢求，不过虚妄的怪影。你在他谈己身的文字间，能聆听到心的跳动，那是真的人的声音，它折射着人与世界复杂的联系，其惨烈与悲壮构成了生命的亮色。无己之人获得了自己，有限的自嘲获得了无限，这便是其文本的深切隐含。自孔老夫子至鲁迅，惟有后者将人本的意义引入到形而上的层面。人的尊严与个性终于确立于苍茫的大地上，我们何不为之击节赞叹！ （载自：《鲁迅文集》序言，孙郁作序）","tags":[{"name":"纪念","slug":"纪念","permalink":"http://blog.jfz.me/tags/纪念/"}]},{"title":"【影子博客旧文】Mathematica 7汉化版(影子圣域封装汉化包)","date":"2009-11-28T20:50:00.000Z","path":"2009/mathematica7.html","text":"注：现在Mathematica 8都出来了，汉化补丁网上肯定有高人跟进的，以后此类软件Sandeepin就不介绍了，没啥意义。2012-7-28 高中的Sandeepin越来越觉得不行了，课堂上有很多东西本来就难，老师又讲得快，唉。影子博客好久没啥动静，说实话，现在互联网这么发达，光是靠个人介绍新软有什么用？有一个词叫“人肉筛选”，我觉得我做的就是这样一个工作，然而让我放弃，却又不行，我建博的目标是什么，为什么要放弃？Sandeepin你真是…… 舍不得，舍不得，毕竟也写了数年怎又放弃得。影子博客还是要继续更新的，或者这也是人生的一收获吧，三十年后我相信我再次翻看此文时会笑的。细心的读者也许也发现，我将很多不好的文章都删掉了，影子不求有固定的更新频率，不会乱推新鲜的应用，做事在于精！我只求介绍的每一软件、每一网站、每篇文章都是我真正觉得好的，文章都是我认真写的，软件都是我自己使用觉得真好的。 最近我的精神动态大抵就是如上所说的这些吧，这次段考没考好，努力还是靠自己，博客上唠叨太多也无用，使读者受我情绪影响就不好了。 今天推荐一款数学软件——Mathematica，我这篇文章主讲Mathematica 7，这软件我很久前就用上了，可惜没有汉化版，最近在网上乱逛，偶然发现有人放出了汉化文件，于是心血来潮，就用Winrar封装了一个汉化包，^_^没啥技术含量，欢迎大家下载。关于Mathematica，我又不是使用这软件的专家，详细介绍自然也写不出。就随便抄来几段话吧： Mathematica是一款科学计算软件，它也是目前为止使用最广泛的数学软件之一。它是一个综合的数学软件环境，具有数值计算、符号推导、数据可视化和编程等多种功能，在符号计算领域有很高的知名度。整个Mathematica软件分为两大部分，Kernel和Front End。Kernel是软件的计算中心，而Front End负责与用户的交流。它们两者有一定的独立性。Kernel工作并不依赖特定的Front End。在Mathematica的安装文件夹下，可以发现有三个可执行文件：math.exe，mathkernel.exe和mathematica.exe。其中mathematica.exe就是Front End，其余两个分别是基于命令行和窗口的Kernel。双击mathkernel.exe，我们就可以直接运行Kernel。同样，如果不进行计算的话，比如只是编辑notebook，或观看动画，mathkernel.exe是不需要启动的…… 不想抄更多废话了，到百度百科、维基百科、Google等网一搜，介绍得更详细，这里我给大家看看我做的汉化封装包吧，当然不是我汉化的，资源都是从互联网找的，只不过是为了我自己安装方便才做此封装，毫无技术含量，属于懒人使用……看看截图吧：我觉得有些地方字大小不协调，哪位高人能改改啊？ Mathematica 7汉化包： 访问SkyDrive下载 **访问千脑下载 Mathematica 7原版： [电驴下载](ed2k://|file|TLF-SOFT-WOLFRAM.RESEARCH.MATHEMATICA.V7.0-EDGEISO.bin|551341728|a1a13162d3c479fa9b24d64bcaebb2c8|h=PDDNCBZ5JOKTXQ3CDQMJCRE64ODPEVUA|/) 注：本来不想提供下载的，但SkyDrive和千脑太稳定了，赞一个！看在它们的份上，下载还摆在那吧，不过不保证长久有效。**","tags":[]},{"title":"【影子博客旧文】主题图设计教程","date":"2009-07-30T11:44:00.000Z","path":"2009/zhutitu.html","text":"由于最近很多朋友对影子博客的主题图很感兴趣，浪13还专门问过我，故写篇文章详细说明。 说老实话，做主题图是件很累的事请，像Sandeepin这样不折腾会痒，折腾多了会累的人，偶尔几篇做做主题图倒还可以，篇篇做就抵不住了，说白了Sandeepin没毅力吧，太多精力放在做主题图上也不好，尽力而为，适可而止。 好了，到正文，由于做主题图这种活属于小道设计，PS(Photoshop)这重量级的老大是少不了的，虽然软件花钱，但中国这地儿，百度Google随便搜破解的一大堆，当然，Sandeepin是很尊重别人劳动成果的，别人设计软件是很累的活，买买正版也是应该的。所以本篇Sandeepin写得累的要死，转载还请注明来自Shadow Sacred影子圣域啊^_^，不然可要被人鄙视哦。 当然，如果你是设计高手，PS足够用了，这篇文章也没看法，由于Sandeepin只是个业余爱好者，PS不精，才需动用很多软件，加起来勉强凑合。由于本文涉及软件之多，每款软件都是有很多功能的，本文介绍只是涉及一些相关功能，其它功能还请大家自己挖掘。 其实设计一主题图根本不是每步都要用到，随便截个图放上去也就行了，本文为了说明详细，很多非必要的设计步骤也写了写，大家看着办把，有用就用，不想也就罢了，由于Sandeepin水平低，很多设计方法拐了弯，不要笑我啊。先列个提纲： 1、根据博客大小截好图大小，这是必须的，为了体现统一，最好每篇文章主题图一样大(如我的博客主题图截取大小是650x130，由于以后加阴影图片还会大的这里不要设太大，比博客边长小些最好)，这样才体现有序，整齐美观。当然，你若觉得这样博客就呆板了，也可以每篇主题图不一样大，我是喜欢一样大的，每人审美观不同，这个不强求。 2、用PS等软件设计主题图，加上文字、渐变或其他风格效果，这个是本文详细讲的，将会介绍很多软件，这里不多说了。 3、加上阴影(撕边)、水印等，这个用PS难做了，推荐SPX、WinSnap这些软件是这方面的傻瓜软件，菜鸟都懂用。 4、对图片优化、压缩，因为是要发在网络的，毕竟宽带有限，图片压缩小了，网友看着也快，再说，小图片打开占用内存CPU什么的都小，浏览器查看不易死机，不然图片太多了，网友一打开你的博客就死机，还以为有病毒呢，你说反不反感？ 5、发布，推荐将图片放在Yahoo Groups相册或天涯来吧相册，这个我在这篇文章说了，Yahoo Groups相册在这篇文章介绍了。最好不要放在梦想博客的相册，相册才100M，用了比较亏，不知可不可以通过管理员加空间大小，梦想博客的相册推荐放一些重要的原创内容，如重要Logo，原创软件，稀有资源啊等等。 6、插入图片到文章中……(接下来还要干什么不用说了吧) 本篇就以本文的主题图为例，首先选好素材，这个不多说了。直接看图 ，随便介绍下截图软件SPX。 打开在任务栏有一图标，点右键查看选项，选择矩形区域，点固定尺寸，我选择650x130，你依照你博客实际情况选择大小。（如图） 还有撕边、水印等功能，这个自己琢磨了。 点右键可出现框框，再点一下右键提示你保存，这样就截好了，这是我截的，当做背景。 用FotoBatch进行羽化，羽化可用PS做，但我觉得用FotoBatch方便。打开图像后点图像羽化。 羽化后的效果。 好的，开始PS。 点右键，混合选项。自己设置。 只是举例，PS其它特效自己专门学习PS，这不多说了，看完成图。 有些特效在本主题图中没用，但Sandeepin还是推荐几款软件，可达到一些PS很难达到的效果。 第一款：Inpaint，可去除照片上的物体。 第二款：S-Spline，图片放大不失真 影子圣域小Logo放大无锯齿。 第三款：RoundPic。进行圆角特效处理 第四款：PhotoFiltre Studio ，堪称小PS，功能强大，可做卷角特效。 觉得差不多了，就给图片加阴影、水印了，WinSnap极好，大家看图 完成图，这时可用了，建议最好再优化一下。 好了，这会说图片压缩，推荐用Image Optimizer，在异次元软件世界这里 有介绍，我就不多说了，看图。 最终效果图： 最后就是上传图片到相册，这个不说了，可来这里，这里看看我的拙文。 教程到此结束，本文就是整篇文章的预览效果了，不错吧，图文并茂！","tags":[{"name":"教程","slug":"教程","permalink":"http://blog.jfz.me/tags/教程/"}]},{"title":"【影子博客旧文】开张第一篇，不断打折的理想！","date":"2008-09-12T07:41:24.000Z","path":"2008/firstriji.html","text":"到目前为止，影子圣域的建设是一个懒人为了实现目标的不断偷懒的过程。最开始做影子圣域的时候，有着最大的想法就是做一个可以分享互联网精彩资源的网站，曾经做出来颇大的体系架构，但后来无法再支持，因为没有足够的时间，让自己对不起这个理想及这个太大的期望。于是我建立影子博客，其实没有理由一定要写，但总还可以找到一些乐趣吧，也还可以和很多朋友分享多多少少的资源……这就构成了影子博客的由来……大巧若拙，大智若愚。经历过一些年月之后，原来重要的很多东西已经不再重要，原来的一些朋友已经四散各方，不过还好，自己的世界始终还在，慢慢成长。","tags":[]}]